=====================================================================
* Intrusion Detection *
***********************

В этом задании мы сосредоточимся на конкретных вредоносных машинах.
Будут показаны примеры создания точных запросов и запуска оповещений для упреждающего повышения безопасности нашей среды.

Количество данных (наборов данных) которые мы будем использовать будет весьма обширным, а не только лишь одна коллекция журналов событий.
Мы будем стремиться отсеивать ложные срабатывания используя панель управления Splunk.
Поэтому, в этом задании мы сосредоточимся на наборе данных, который мы создали лично.
Вы будете работать с более чем 500 000 событий.
Установив выбор времени на Все время и отправив запрос ниже, мы можем получить все доступные события.

Мы будем проводить похожие расследования, но в гораздо большем масштабе, на нескольких машинах, чтобы обнаружить нерегулярные действия во всей сети, а не только на одном устройстве.
Наши инструменты по-прежнему будут включать журналы событий Windows, но область нашей работы значительно расширится, требуя тщательного изучения большего пула информации, а также выявления и отбрасывания ложных срабатываний, когда это возможно.
В этих данных мы столкнемся с различными типами атак и заражений.
Наша цель не в том, чтобы идентифицировать каждую из них, а в том, чтобы понять, как мы можем начать обнаруживать любой вид атаки в этом огромном пуле данных.
В итоге мы должны идентифицировать несколько атак.

IP  10.129.205.112:8000

    +++++++++++++++++++++++++
    + Listing Sourcetype(s) +
    +++++++++++++++++++++++++

    Наша первая цель — посмотреть, что мы можем идентифицировать в данных Sysmon.
    Начнем с перечисления всех наших sourcetypes, чтобы подойти к этому как к неизвестной среде с нуля.
    Данный запрос покажет Вам возможные/доступные источники данных (sourcetypes)

        index="main" | stats count by sourcetype
    
    +++++++++++++++++++++++++++++++++++++++++++++++++++
    + Sysmon EventCodes Identification and Processing +
    +++++++++++++++++++++++++++++++++++++++++++++++++++

    Давайте определим все Sysmon EventCodes, преобладающие в наших данных, с помощью этого запроса.

        index="main" sourcetype="WinEventLog:Sysmon" | stats count by EventCode
    
    На основе этих EventCodes мы можем выполнять предварительные запросы.
    Как уже говорилось, необычные родительско-дочерние деревья всегда подозрительны.
    
    Давайте проверим все родительско-дочерние деревья с помощью этого запроса.

        index="main" sourcetype="WinEventLog:Sysmon" EventCode=1 | stats count by ParentImage, Image
    
    В результате мы получаем 5427 событий, довольно много, чтобы вручную просеять.
    У нас есть выбор: отсеять то, что кажется безобидным, или нацелиться на дочерние процессы, которые, как известно, являются проблемными, например cmd.exe или powershell.exe.
    Давайте нацелимся на эти два.

        index="main" sourcetype="WinEventLog:Sysmon" EventCode=1 (Image="*cmd.exe" OR Image="*powershell.exe") | stats count by ParentImage, Image

    Цепочка notepad.exe to powershell.exe сразу бросается в глаза. Она подразумевает, что был запущен notepad.exe, который затем породил дочерний powershell для выполнения команды.
    Что дальше? Задайте себе вопрос «почему» и проверьте, типично ли это.

    Мы можем глубже разобраться, сосредоточившись исключительно на этих событиях.

        index="main" sourcetype="WinEventLog:Sysmon" EventCode=1 (Image="*cmd.exe" OR Image="*powershell.exe") ParentImage="C:\\Windows\\System32\\notepad.exe"
    
    Мы видим, что ParentCommandLine (просто notepad.exe без аргументов) запускает CommandLine powershell.exe, который, по-видимому, загружает файл с сервера с IP-адресом 10.0.0.229

    Теперь наш путь разветвляется.
    Мы могли бы отследить, что инициировало notepad.exe, или мы могли бы исследовать другие машины, взаимодействующие с этим IP, и оценить его легитимность.
    Давайте узнаем больше об этом IP, выполнив несколько запросов для исследования всех sourcetypes, которые могли бы пролить свет.

        index="main" 10.0.0.229 | stats count by sourcetype
    
    Полученный результат состоял только из 2 записей: одна - Windows; другая - Linux

        sourcetype              count
        WinEventLog:Sysmon      73
        linux:syslog            22
    
    Анализ журнала по системе Linux не выявил ничего интересного (на первый взгляд), кроме того, что этот IP принадлежит хосту с именем waldo-virtual-machine на его интерфейсе ens160.
    IP, похоже, делает что-то общее.

    А вот разбор журнала Windows, предоставил достаточно полезной информации

        index="main" 10.0.0.229 sourcetype="WinEventLog:sysmon" | stats count by CommandLine

    Он указывает на то, что наша машина участвовала в какой-то форме связи с системой Linux, в частности, загружая исполняемые файлы через PowerShell.
        Invoke-DCSync.ps1
        PsExec64.exe
        SHarpHound.exe
        file.exe
        comsvcs.dll

    Это вызывает некоторые опасения, намекая на потенциальную компрометацию системы Linux!
    По нашей оценке становится все более очевидным, что не только порождение notepad.exe в powershell.exe было вредоносным по своей природе, но и система Linux также, по-видимому, заражена.
    Похоже, что это играет важную роль в передаче дополнительных утилит.
    
    Поэтому давайте начнем еще одно расследование, используя данные Sysmon, чтобы обнаружить любые дальнейшие соединения, которые могли быть установлены.
    Теперь мы можем точно настроить наш поисковый запрос, чтобы увеличить масштаб хостов, выполняющих эти команды

        index="main" 10.0.0.229 sourcetype="WinEventLog:sysmon" | stats count by CommandLine, host
    
    Наш анализ показывает, что два хоста стали жертвой этого поворота Linux.

        host                    count
        DESKTOP-EGSS5IS         59
        DESKTOP-UN7T4R8         14

    Примечательно, что скрипт DCSync PowerShell был выполнен на втором хосте, что указывает на вероятную атаку DCSync.
    
    Вместо того чтобы делать предположение, мы попытаемся проверить это, разработав более целевой запрос, в данном случае сосредоточившись на атаке DCSync.
    А также вместо Sysmon Event ID воспользуемся Windows Security Event ID 4662

        index="main" EventCode=4662 Access_Mask=0x100 Account_Name!=*$
    
    Теперь давайте разберем обоснование этого запроса:

        -   EventCode 4662 запускается при доступе к объекту Active Directory (AD).
            Обычно он отключен по умолчанию и должен быть намеренно включен контроллером домена, чтобы начать появляться.
            
        -   Access_Mask 0x100 специально запрашивает Control Access, обычно необходимый для разрешений высокого уровня DCSync.
        
        -   Account_Name проверяет, где к объектам AD напрямую обращаются пользователи, а не учетные записи, поскольку DCSync должен выполняться только законно учетными записями компьютеров или SYSTEM, а не пользователями.
    
    Вам может быть интересно, как мы можем определить, что это попытки DCSync, поскольку они могут получать доступ к чему угодно.
    Чтобы решить эту проблему, мы оцениваем на основе данных поля Properties.

        Properties:		Control Access
		                {1131f6aa-9c07-11d1-f79f-00c04fc2dcd2}
	                    {19195a5b-6da0-11d0-afd3-00c04fd930c9}
    
    Мы замечаем два интересных GUID.
    Быстрый поиск в Google может дать ценную информацию.
    После исследования мы обнаружили, что первый связан с DS-Replication-Get-Changes-All, который, согласно его описанию, «...позволяет копировать секретные данные домена».

    Это дает нам твердое подтверждение того, что попытка DCSync была предпринята и успешно выполнена пользователем Waldo в домене UNIWALDO.
    Разумно предположить, что пользователь Waldo либо обладает правами администратора домена, либо имеет определенный уровень прав доступа, разрешающий это действие.
    Кроме того, весьма вероятно, что злоумышленник также извлек все учетные записи в AD
    Это означает полную компрометацию нашей сети, и нам следует рассмотреть возможность ротации нашего krbtgt на случай, если будет создан золотой билет.

    Более того, злоумышленник, должно быть, изначально проник в систему и предпринял несколько маневров, чтобы получить права администратора домена, организовать боковое перемещение и сбросить учетные данные домена.
    Обладая этими знаниями, мы применим дополнительную стратегию поиска, чтобы попытаться выяснить, как злоумышленнику изначально удалось получить права администратора домена.

    К примеру, мы ранее наблюдали обнаружения для lsass dumping как распространенного метода сбора учетных данных.
    Чтобы обнаружить это в нашей среде, мы стремимся идентифицировать процессы, открывающие дескрипторы для lsass, а затем оцениваем, считаем ли мы это поведение необычным или обычным.
    К счастью, код события Sysmon 10 может предоставить нам данные о доступе к процессу или процессах, открывающих дескрипторы для других процессов.
    Мы развернем следующий запрос, чтобы сосредоточиться на потенциальном lsass dumping.

        index="main" EventCode=10 lsass | stats count by SourceImage
    
    В большинстве случаем мы предпочитаем сортировку по количеству, чтобы сделать данные более понятными.
    Хотя не всегда безопасно делать предположения, общепринято, что часто происходящая активность является «нормальной» в среде.
    В связи с этим сложнее обнаружить вредоносную активность в море из 99 событий по сравнению с обнаружением ее всего в 1 или 5 возможных событиях.
    С этой логикой мы начнем с изучения любых заметных странных обращений процессов к lsass.exe любым source image.
    Наиболее заметными из них являются notepad (учитывая его абсурдность) и rundll32 (учитывая его ограниченную частоту).
    Для это воспользуемся следующим запросом

        index="main" EventCode=10 lsass SourceImage="C:\\Windows\\System32\\notepad.exe"
    
    Данный запрос поможет нам в расследовании случаев открытия дескриптора блокнотом.
    И хотя полученные данные ограничены, но ясно, что Sysmon, похоже, думает, что это связано с дампом учетных данных.
    Мы можем использовать стек вызовов, чтобы собрать дополнительную информацию о том, что что вызвало и откуда, чтобы выяснить, как была проведена эта атака.

    Неопытному глазу может быть не сразу очевидно, что стек вызовов ссылается на НЕИЗВЕСТНЫЙ сегмент в ntdll.
    В большинстве случаев любая форма шелл-кода будет расположена в так называемой неподдерживаемой области памяти.
    Это означает, что ЛЮБЫЕ вызовы API из этого шелл-кода не исходят из какого-либо идентифицируемого файла на диске, а из произвольных или НЕИЗВЕСТНЫХ областей в памяти, которые вообще не отображаются на диск.
    Хотя ложные срабатывания могут возникать, сценарии ограничены такими процессами, как JIT-процессы, и их можно в основном отфильтровать.

    +++++++++++++++++++
    + Creating Alerts +
    +++++++++++++++++++

    Используя полученную информацию, мы теперь можем стремиться создавать оповещения от вредоносных программ на основе вызовов API из НЕИЗВЕСТНЫХ областей памяти.
    
    Крайне важно помнить, что создание оповещений отличается от охоты.
    Наши оповещения должны быть устойчивыми и эффективными, иначе мы рискуем затопить нашу команду защиты избытком данных, непреднамеренно создавая дымовую завесу для злоумышленников, чтобы проскользнуть через наши ложные срабатывания.
    Более того, мы должны гарантировать, что их будет нелегко обойти, когда достаточно нескольких настроек и секунд.

    В этом случае мы попытаемся создать оповещение, которое может обнаруживать субъектов угроз на основе их вызовов из НЕИЗВЕСТНЫХ областей памяти.
    Мы хотим сосредоточиться на вредоносных потоках/регионах, оставляя стандартные элементы нетронутыми, чтобы избежать ненужных оповещений.
    
    Способ, который будет продемонстрирован, будет более упрощенным и легким, чем во многих реальных средах, из-за меньшего объема данных, с которыми нам нужно иметь дело.
    Однако те же концепции будут применяться при переходе к корпоративной сети — Вам просто нужно будет управлять ею с гораздо большим объемом данных более эффективно и креативно.

    Мы начнем с перечисления всех стеков вызовов, содержащих UNKNOWN в течение исследуемого периода работы, на основе кода события, чтобы увидеть, какой из них может дать наиболее значимые данные

        index="main" CallTrace="*UNKNOWN*" | stats count by EventCode

    Похоже, что только код события 10 показывает что-либо, связанное с нашим CallTrace, поэтому наше оповещение будет привязано к  process access
    Это означает, что мы будем оповещать обо всем, что пытается открыть дескрипторы для других процессов, которые не отображаются обратно на диск, предполагая, что это шеллкод.
    
        index="main" CallTrace="*UNKNOWN*" | stats count by SourceImage

    Изменненый запрос отобразил 1575 событий.
    Для удобности визуализации, отсортируем результат по убыванию
    Это поможем нам с определением  JIT-процессов, т.н. ложных срабатываний, о которых мы упоминали ранее
    
    .Net — это JIT, а утилиты Squirrel привязаны к electron, который является браузером Chromium и также содержит JIT.
    Даже с нашим небольшим набором данных, есть много чего просеять, и мы не уверены, что вредоносно, а что нет.
    Самый эффективный способ справиться с этим — связать несколько запросов вместе.

    Во-первых, нас не волнует, когда процесс обращается к самому себе (это обязательно), поэтому давайте пока отфильтруем эти случаи.
    
        index="main" CallTrace="*UNKNOWN*" | where SourceImage!=TargetImage | stats count by SourceImage
    
    Также, мы знаем, что C# довольно трудно отсеять, но мы все равно хотим получить высококачественное оповещение.
    Поэтому мы исключим все, что связано с C# из-за его JIT.
    Мы можем добиться этого, исключив папки Microsoft.Net и все, что имеет ni.dll в своей трассировке вызовов или clr.dll.

        index="main" CallTrace="*UNKNOWN*" SourceImage!="*Microsoft.NET*" CallTrace!=*ni.dll* CallTrace!=*clr.dll* | where SourceImage!=TargetImage | stats count by SourceImage
    
    Далее  мы сосредоточимся на искоренении всего, что связано с WOW64 в его стеке вызовов.
    Почему, спросите вы?
    Ну, довольно часто WOW64 включает в себя области памяти, которые не поддерживаются каким-либо конкретным файлом, (т.н. явление, которое, как мы считаем, связано с механизмом Heaven's Gate).

        index="main" CallTrace="*UNKNOWN*" SourceImage!="*Microsoft.NET*" CallTrace!=*ni.dll* CallTrace!=*clr.dll* CallTrace!=*wow64* | where SourceImage!=TargetImage | stats count by SourceImage
    
    Двигаясь вперед, мы также исключим Explorer.exe, учитывая его универсальную природу.
    Он сродни подстановочному знаку, способному выполнять ряд задач.
    Выявление любой вредоносной активности непосредственно в Explorer — почти геркулесовская задача.
    Широкий спектр законных действий, которые он выполняет, и множество инструментов, которые часто игнорируют его из-за его сложности, делают этот процесс более сложным.
    Трудно проверить UNKNOWN, особенно в этом контексте.

        index="main" CallTrace="*UNKNOWN*" SourceImage!="*Microsoft.NET*" CallTrace!=*ni.dll* CallTrace!=*clr.dll* CallTrace!=*wow64* SourceImage!="C:\\Windows\\Explorer.EXE" | where SourceImage!=TargetImage | stats count by SourceImage
    
    С помощью описанных выше шагов мы теперь создали достаточно надежную систему оповещения для нашего примера.
    Эта система оповещения отлично справляется с выявлением известных угроз.
    Однако крайне важно, чтобы мы проверили оставшиеся данные, чтобы проверить их легитимность.
    Кроме того, мы должны проверить систему, чтобы обнаружить любые невидимые действия.
    
    Чтобы получить более полное понимание, мы могли бы повторно ввести некоторые поля, которые мы удалили ранее, такие как TargetImage и CallTrace
    Или изучить каждое исходное изображение по отдельности, чтобы отсеять любые оставшиеся ложные срабатывания.

        index="main" CallTrace="*UNKNOWN*" SourceImage!="*Microsoft.NET*" CallTrace!=*ni.dll* CallTrace!=*clr.dll* CallTrace!=*wow64* SourceImage!="C:\\Windows\\Explorer.EXE" | where SourceImage!=TargetImage | stats count by SourceImage, TargetImage, CallTrace
    
    Обратите внимание, что создание этой системы оповещений было относительно простым в нашей текущей среде из-за ограниченного объема данных и ложных срабатываний, с которыми нам приходилось иметь дело.
    Однако в реальном сценарии вы можете столкнуться с обширными данными, которые требуют более тонких механизмов для выявления потенциально вредоносных действий.
    
    Более того, стоит задуматься о силе этого оповещения.
    Насколько легко его можно обойти? К сожалению, есть несколько способов обойти оповещение, которое мы создали.

    Представьте себе способы укрепления этого оповещения.
    Например, хакер может просто обойти наше оповещение, загрузив любую случайную DLL с добавленным к ее имени NI.

