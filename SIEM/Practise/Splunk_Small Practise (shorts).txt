Далее будут представлены синтаксис, который используется в Splunk для поиска информации по интресующему вопросу вне зависимости от данных

    *)  On one of the infected hosts, the adversary was successful in creating a backdoor user. What is the new username?
        На одном из зараженных хостов злоумышленнику удалось создать пользователя бэкдора. Каково новое имя пользователя?

        Сперва нам надо определить номер EventID, который рещистрируется при создании нового пользователя
        Используем гугл в любых вариация запроса (в том числе с добавленим sysmon)
        Результат   -   4720

            Поисковый запрос    -   index=<logs_collection_name> EventID=4720
    
        А дальше:
            -   либо просматривает лог(и) построчно
            -   либо просматриваем подходящие поля (к примеру - SamAccountName или TargetUserName)
        
        !!! Имя может быть завуалировано, т.е. использованы сходие символы (o=0, 1=l и т.д.)
    
    *)  On the same host, a registry key was also updated regarding the new backdoor user. What is the full path of that registry key?
        На том же хосте также был обновлен ключ реестра относительно нового пользователя бэкдора. Каков полный путь этого ключа реестра?

        Опять используем гугл для определения нужного EventID
        РЕКОМЕНДУЕТСЯ менять запрос гугл или использовать он-лайн базу по ОС логам
        Результат   -   13
        А если мы хотим посмотреть результат по конкретному пользователю, то просто добавляе его имя в конце запроса (в нашем случае - A1berto)

            Поисковый запрос    -   index=<logs_collection_name> EventID=13 A1berto
        
        Затем, мы либо в ручну шерстим лог(и), либо смотрим результат поля "TargetObject"


    *)  What is the command used to add a backdoor user from a remote computer?
        Какая команда используется для добавления пользователя бэкдора с удаленного компьютера?

        Тут варианта 2:

            1)  Так как мы знаем имя созданного пользователя, то мы просто ставим его в поисковый запрос 

                    Поисковый запрос    -   index=<logs_collection_name> <user_name>
                
                А затем просматриваем результаты поля "CommandLine"
                Но если у нас много шума, тогда фильтруем с помощью второго способа
            
            2)  Тут нам надо добавить два EventID
                Гуглим для опрееделния подходящие номеров
                Результат   -   1 и 4688 (оба отвечают за "создание процесса")
                1       -   просто говорит, что был создан какой-то процесса
                4688    -   создан процесс в дернале Security (создание пользователя относится к этому журналу)

                    Поисковый запрос    -   index=<logs_collection_name> EventID=1 OR EventID=4688 <user_name>
            
            В поле "CommandLine" ищем то, что может содержать user /add
    
    *)  How many times was the login attempt from the backdoor user observed during the investigation?
        Сколько раз в ходе расследования была зафиксирована попытка входа в систему со стороны пользователя бэкдора?

        Опять используем гугл для определения нужного EventID
        А так как у нас в запросе нужно выявить попытки входа, то будем определять как УСПЕШНЫЕ, так и ПРОВАЛЬНЫЕ
        Результат   -   4624 (успешные) т 4625 (провальные)

            Поисковый запрос    -   index=<logs_collection_name> EventID=4624 OR EventID=4625 <user_name>
    
    *)  What is the name of the infected host on which suspicious Powershell commands were executed?
        Каково имя зараженного хоста, на котором выполнялись подозрительные команды Powershell?

        Тут варианта 2:

            1)  Так как мы знаем имя созданного пользователя (злоумыщленика), то просто добавим PowerShell в конец строки запроса

                    Поисковый запрос    -   index=<logs_collection_name> <user_name> PowerShell
                
                А после, обратимся к полю "HostName"
                Ну или изучаем логи вручную
            
            2)  Используем гугл для поиска нужных EventID
                Скажу сразу, что банальный гугл-запрос "PowerShell" не даст никаких результатов
                Поэтом проявляем фантазию (в нашем случае это - Scriptblock и cmdlet)
                Результат   -   4104 (Scriptblock) и 4103 (cmdlet)

                    Поисковый запрос    -   index=<logs_collection_name> EventID=4104 OR EventID=4103
                
                Этот вариант хорош в том случае, если мы ищем среди всех пользователей
            
    *)  An encoded Powershell script from the infected host initiated a web request. What is the full URL?
        Закодированный скрипт Powershell с зараженного хоста инициировал веб-запрос. Каков полный URL?

        Тут все немного труднее, так как логи могут не содержать полей, фильрующих по типу запроса
        Так что нам придется немного по-химичить с запросом
        
        Ну сперва мы должны найти подходящие EventID для нашего фильтра
        Это будут   -   4104 (Scriptblock) и 4103 (cmdlet)
        Количество шума может быть достаточным, чтобы усовершенствовать наш запрос

        Далее нас интресуют поле - "ContextInfo"
        Но, информация, содержащаяся в данном поле каждого лога может быть огромна и трудночитаема
        Поэтому нам надо использовать RegEx, для извлечения нужного нам сегмента/лога

        Измененный запрос извлечет значение «Host Application» из поля «ContextInfo» и представит его в таблице без дублирующихся команд.
        А для красоты отображения и удобства анализа добавим пару фильров   -   tabla Command и dedup Command

            Поисковый запрос    -   index=main EventID=4104 OR EventID=4103 | rex field=ContextInfo "Host Application = (?<Command>[^\r\n]+)" | table Command | dedup Command
        
        Результат будет отображен во вкладе Statistics и скорее всего зашифрован (в нашем примере он был защифрован кодировкой Base64)
        Так что копируем только закодированное сообщение и раскодирем его через CyberChef
        Незабываем использовать фильтры -   from Base64, remove null bytes, Defang URL

    *)  Imposter Alert: There seems to be an imposter account observed in the logs, what is the name of that user?
        Предупреждение о самозванце: похоже, в журналах обнаружена учетная запись самозванца. Каково имя этого пользователя?

        Данное задание весьма простое   -   нам всего лишь надо посмотреть содержание поля "UserName"
        Однако пользователей может быть больше, чем может отобразить данное поле (если мы просто кликнем на него один раз)
        Чтобы, мы могли увидеть всех пользователей, нам надо, чтобы результат был продублирован во вкладку "Statistics"
        Для этого нам надо выбрать вариант "Top Values" (ну или "Rare Values", в зависимости от потребнойстей)
        Ну и во вкладке "Statistics" просматриваем результаты

        Также можно ввести фильр вручную и отредактировать количество отображаемых записей

            Поисковый запрос    -   index=<logs_collection_name> | top limit=## UserName
    
    *)  Which user from the HR department was observed to be running scheduled tasks?
        Какой пользователь из отдела кадров был замечен за выполнением запланированных задач?

        Тут также ничего трудного   -   в строке фильтра добавляем название приложениея ответственного за запланированые задачи (schtasks)

            Поисковый запрос    -   index=<logs_collection_name> schtasksо
        
        Однако, результат может содержать больше одного пользователя
        Так, что нам надо отсеять лишних
        Отпрываем поле "CommandLine" и смотрим на имеющиеся результаты
        Затем выбираем тот, который наиболее удовлетворяет нашему запросу
    
    *)  Which user from the HR department executed a system process (LOLBIN) to download a payload from a file-sharing host.
        Какой пользователь из отдела кадров запустил системный процесс (LOLBIN) для загрузки полезной нагрузки с файлообменного хоста.

        Ну, сперва отфильтруем только тех, кто имеет отношение к HR отделу

            Поисковый запрос    -   index=<logs_collection_name> HostName="*HR*"
        
        Затем, так как было запущено какое-то приложение для скачивания, то проверим    -   какие команды были использованы
        А так как (скорее всего), данная команда была задействована очень малое количество раз (врядли больше одного), то отсортируем по редкости

            Поисковый запрос    -   index=win_eventlogs HostName="*HR*"| rare limit=20 CommandLine
        
        Далее, по вкладке "Statistics" выберем подходящий для нас результат
        Нажмем на него один раз левой кнопкой мыши и выберем из выпадающего меню "New Search"
        Данное действие предоставит нам новый результат, гле в поле "UserName" будет наш ответ

    *)  Using "Search & Reporting" find through all 4624 events the account name that made the most login attempts within a span of 10 minutes.
        Используя функцию «Поиск и отчеты», найдите среди всех 4624 событий имя учетной записи, с которой было совершено наибольшее количество попыток входа в систему в течение 10 минут.

        Суть нижепредставленного запроса в том, что он  исключает определенные учетные записи и группирует события по интервалам времени (по 10 минут), подсчитывая количество попыток для каждой учетной записи в каждом интервале времени.

            index="main" EventCode=4624 Account_Name!="*$" Account_Name!="waldo" Account_Name!="SYSTEM"
            | bin _time span=10m as timespan
            | stats count as Attempts by timespan Account_Name
            | sort - Attempts
        
        Разбор запроса:
        
            -   index="*" EventCode=4624 Account_Name!="*$" Account_Name!="waldo" Account_Name!="SYSTEM"
                Этот блок фильтрует только те события, где успешный вход в систему был выполнен через обычные учетные записи (исключая $, waldo и SYSTEM).
                
                    index="*"
                    Указывает, что поиск будет выполняться во всех доступных индексах (* можно хаменить на конкретный индекс, к примеру main)
                    
                    EventCode=4624
                    Поиск будет осуществлять только среди событий зарактеризующих успешный вход в систему в Windows (event ID 4624).
                    
                    Account_Name!="*$"
                    Исключает учетные записи, которые оканчиваются на $, обычно это служебные учетные записи (например, компьютерные учетные записи).

                    Account_Name!="waldo"
                    Исключает учетную запись с именем пользователя "waldo" (парметр не обязательный)

                    Account_Name!="SYSTEM"
                    Исключает учетную запись SYSTEM.

            -   | bin _time span=10m as timespan
                Эта команда группирует все события в 10-минутные интервалы.
                В результате, поле _time будет преобразовано в поле timespan, которое содержит временные метки на уровне 10 минут.

            -   | stats count as Attempts by timespan Account_Name
                Эта команда подсчитывает количество попыток входа (событий 4624) по каждому уникальному сочетанию timespan (10-минутный интервал) и Account_Name (имя учетной записи).
                В итоге Вы получите количество попыток входа для каждой учетной записи за каждый 10-минутный интервал.

            -   | sort - Attempts
                Эир команда сортирует результаты по количеству попыток входа в порядке убывания (по убыванию значения Attempts).
                То есть учетные записи с наибольшим количеством попыток входа будут отображаться первыми.

    *)  Using "Search & Reporting" find through an SPL search against all data the other process that dumped lsass. 
        Используя «Поиск и отчеты», найдите с помощью поиска SPL по всем данным другой процесс, который создал дамп lsass.

        В данном примере ключевое значение играет   -   создал дамп
        Когда создается дамп какого-либо файла/процесса, то как правило ему присваивается расширение .dmp
        Поэтому, вместо простого поиска по названию процесса "*<process_name>*", мы будем искать с упоминанем расширения
        Однако, результат может быть весьма обширным
        И чтобы нам отобразить только процесс(-ы), который создал дамп, мы отсортируем по CommandLine

            index="main" "*lsass.dmp*" | stats count by CommandLine
        
        Существует альтернативный вариант базирующийся на отборе событий по Event ID 10

            index="main" sourcetype="WinEventLog:Sysmon" EventCode=10 lsass | stats count by SourceImage, TargetImage
        
        Далее ручной анализ поможет выявить непосредственно название процесса, который был использован для создания дампа
    
    *)  Using "Search & Reporting" find through an SPL search against all data any suspicious loads of clr.dll that could indicate a C# injection/execute-assembly attack.
        Then, again through SPL searches, find if any of the suspicious processes that were returned in the first place were used to temporarily execute code. 
        Используя «Поиск и отчетность», найдите с помощью поиска SPL по всем данным любые подозрительные загрузки clr.dll, которые могут указывать на атаку инъекции/выполнения сборки C#.
        Затем, снова с помощью поиска SPL, найдите, использовались ли какие-либо из подозрительных процессов, которые были возвращены в первую очередь, для временного выполнения кода.

        Выполнение данного задания требует наличия знаний взаимосвязи между crl.dll и системными процессами
        В стандартном, законном сценарии clr.dll не загружается rundll32.exe.
        Наблюдение такого поведения в журналах или событиях безопасности может быть индикатором вредоносной активности или внедрения процесса.
        Этот шаблон нетипичен для законного программного обеспечения, что позволяет предположить, что злоумышленник может пытаться использовать собственные утилиты Windows для выполнения своего вредоносного кода.

            index="main" EventCode=7 ImageLoaded="*clr.dll" | stats count by Image
    
    *)  Using "Search & Reporting" find through SPL searches against all data the two IP addresses of the C2 callback server. Answer format: 10.0.0.1XX and 10.0.0.XX
        Используя «Search & Reporting», найдите с помощью поиска SPL по всем данным два IP-адреса сервера обратного вызова C2

        В данном задании обратимся за помощью к Event ID 3 - Network connection
        Также, использую информацию, полученную из предыдущих анализов (кажый случай уникален, так что В вашем личном варианте, могут быть и другие IOC-находки), а если точнее, то подозрительные IOC/процессы
        В нашем случае это были - rundll32.exe, notepad.exe и powershell.exe
        Используем следующий код

            index="main" EventCode=3 (Image="*notepad.exe" OR Image="*rundll32.exe" OR Image="*powershell.exe") | stats count by DestinationIp, Image
        
        Image(s), используемые в запросе можно употреблять по-одному