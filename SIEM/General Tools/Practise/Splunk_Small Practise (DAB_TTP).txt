=====================================================================
* Detecting Attacker Behavior *
*******************************

В постоянно развивающемся мире кибербезопасности профессиональное обнаружение угроз имеет решающее значение.
Это требует глубокого понимания множества тактик, методов и процедур (TTP), используемых потенциальными противниками, а также глубокого понимания наших собственных сетевых систем и их типичного поведения.
Эффективное обнаружение угроз часто вращается вокруг выявления шаблонов, которые либо соответствуют известному вредоносному поведению, либо значительно отклоняются от ожидаемых норм.

При создании поисковых запросов SPL (Search Processing Language), связанных с обнаружением, в Splunk мы используем два основных подхода:

	1)	Первый подход основан на известных TTP противника, используя наши обширные знания о конкретных угрозах и векторах атак.
		Эта стратегия похожа на игру «найди известное».
		Если сущность ведет себя так, что мы распознаем ее как характерную для определенной угрозы, она привлекает наше внимание.

	2)	Второй подход, хотя и основан на понимании TTP злоумышленников
		Он в значительной степени опирается на статистический анализ и обнаружение аномалий для выявления аномального поведения в море нормальной активности.
		Эта стратегия больше похожа на игру «найди необычное».
		Здесь мы не просто полагаемся на уже имеющиеся знания о конкретных угрозах.
		Вместо этого мы широко используем математические и статистические методы для выделения аномалий, работая на предпосылке, что вредоносная активность часто будет проявляться как отклонение от нормы.

Вместе эти подходы дают нам комплексный инструментарий для выявления и реагирования на широкий спектр угроз кибербезопасности.
Каждая методология предлагает уникальные преимущества, и при использовании в тандеме они создают надежный механизм обнаружения, способный идентифицировать известные угрозы, а также выявлять потенциальные неизвестные риски.
Кроме того, в обоих подходах ключом является понимание наших данных и среды, а затем тщательная настройка наших запросов и пороговых значений для баланса между необходимостью точного обнаружения и желанием избежать ложных срабатываний.
Благодаря постоянному анализу и пересмотру наших запросов SPL мы можем поддерживать высокий уровень безопасности и готовности.

=====================================================================
* Detecting Attacker Behavior Based On TTPs (example) *
*******************************************************

Как упоминалось выше, первый подход вращается вокруг всестороннего понимания поведения известных злоумышленников и TTP.
С помощью этой стратегии мы фокусируемся на распознавании шаблонов, которые мы видели ранее, которые указывают на конкретные угрозы или векторы атак.

Ниже приведены некоторые примеры обнаружения, которые следуют этому подходу.

	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	+ Detection Of Reconnaissance Activities Leveraging Native Windows Binaries +
	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	Обнаружение разведывательной деятельности с использованием собственных двоичных файлов Windows

	Злоумышленники часто используют собственные двоичные файлы Windows (например, net.exe), чтобы получить представление о целевой среде, определить потенциальные возможности повышения привилегий и выполнить боковое перемещение.
	Событие Sysmon ID 1 может помочь в выявлении такого поведения.
	А также список двоичных файлов Windows, которые могут быть использованых в целях компроментации 

		index="main" sourcetype="WinEventLog:Sysmon" EventCode=1 Image=*\\ipconfig.exe OR Image=*\\net.exe OR Image=*\\whoami.exe OR Image=*\\netstat.exe OR Image=*\\nbtstat.exe OR Image=*\\hostname.exe OR Image=*\\tasklist.exe | stats count by Image,CommandLine | sort - count

	В результатах поиска появляются явные признаки, указывающие на использование собственных двоичных файлов Windows в разведывательных целях.

	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	+ Detection Of Requesting Malicious Payloads/Tools Hosted On Reputable/Whitelisted Domains (Such As githubusercontent.com) +
	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	Обнаружение запроса вредоносных полезных нагрузок/инструментов, размещенных на надежных/включенных в белый список доменах (например, githubusercontent.com)

	Атакующие часто используют githubusercontent.com в качестве хостинговой платформы для своих полезных нагрузок.
	Это связано с общим белым списком и допустимостью домена прокси-серверами компании.
	Событие Sysmon ID 22 может помочь в выявлении такого поведения.
	А также название домена/ресурса, который может быть использован как платформа, для размещения вредоносных ресурсов 

		index="main" sourcetype="WinEventLog:Sysmon" EventCode=22  QueryName="*github*" | stats count by Image, QueryName

	В результатах поиска появляются четкие указания, указывающие на использование githubusercontent.com для размещения полезной нагрузки/инструментов.
	
	+++++++++++++++++++++++++++++
	+ Detection Of PsExec Usage +
	+++++++++++++++++++++++++++++

	PsExec изначально задумывалась как утилита для помощи системным администраторам в управлении удаленными системами Windows.
	Она обеспечивает удобство подключения и взаимодействия с удаленными системами через интерфейс командной строки и доступна членам группы локальных администраторов компьютера.

	Вот несколько методов MITRE ATT&CK, которые делают его привлекательным вариантом для злоумышленнико:
		T1569.002 (System Services: Service Execution)
		T1021.002 (Remote Services: SMB/Windows Admin Shares)
		T1570 ((Lateral Tool Transfer)

	PsExec работает, копируя исполняемый файл службы в скрытый общий ресурс Admin$.
	Затем он подключается к API диспетчера служб Windows для запуска службы
	Служба использует именованные каналы для обратной ссылки на инструмент PsExec.
	Главной особенностью является то, что PsExec может быть развернут как на локальных, так и на удаленных машинах, и он может позволить пользователю действовать под учетной записью NT AUTHORITY\SYSTEM.
	
	Событие Sysmon Event ID 13, Sysmon Event ID 11 и Sysmon Event ID 17 или Sysmon Event ID 18 могут помочь в определении использования PsExec.
	***	За более детальной информацей, можно перейти по следубщим ссылкам

			-	https://www.synacktiv.com/publications/traces-of-windows-remote-command-execution
			-	https://hurricanelabs.com/splunk-tutorials/splunking-with-sysmon-part-3-detecting-psexec-in-your-environment/

	Рссмотрим использование следующих Sysmon Event ID более подробно

		//////////////////////////
		/// Sysmon Event ID 13 ///
		//////////////////////////

		index="main" sourcetype="WinEventLog:Sysmon" EventCode=13 Image="C:\\Windows\\system32\\services.exe" TargetObject="HKLM\\System\\CurrentControlSet\\Services\\*\\ImagePath" | rex field=Details "(?<reg_file_name>[^\\\]+)$" | eval reg_file_name = lower(reg_file_name), file_name = if(isnull(file_name),reg_file_name,lower(file_name)) | stats values(Image) AS Image, values(Details) AS RegistryDetails, values(_time) AS EventTimes, count by file_name, ComputerName

		Давайте разберем каждую часть этого запроса:

			index="main" sourcetype="WinEventLog:Sysmon" EventCode=13 Image="C:\\Windows\\system32\\services.exe" TargetObject="HKLM\\System\\CurrentControlSet\\Services\\*\\ImagePath"
				Эта часть запроса выбирает журналы из основного индекса с sourcetype WinEventLog:Sysmon.
				Мы специально ищем события с EventCode=13.
				В журналах Sysmon EventCode 13 представляет событие, в котором было установлено значение реестра.
				Поле Image установлено на C:\\Windows\\system32\\services.exe для фильтрации событий, в которых был задействован процесс services.exe, который является процессом Windows, отвечающим за обработку создания и управления службами.
				Поле TargetObject указывает разделы реестра, которые нас интересуют.
				В этом случае мы ищем изменения значения ImagePath в любом разделе службы в HKLM\\System\\CurrentControlSet\\Services.
				Значение реестра ImagePath службы указывает путь к исполняемому файлу для службы.

			rex field=Details "(?<reg_file_name>[^\\\]+)$"
				Команда rex здесь извлекает имя файла из поля Details с помощью регулярного выражения.
				Шаблон [^\\\]+)$ захватывает часть пути после последней обратной косой черты, которая обычно является именем файла.
				Это значение сохраняется в новом поле reg_file_name.

			eval file_name = if(isnull(file_name),reg_file_name,(file_name))
				Эта команда eval проверяет, является ли поле file_name пустым.
				Если это так, он устанавливает file_name в значение reg_file_name (имя файла, которое мы извлекли из поля Details). Если file_name не равно null, он остается прежним.

			stats values(Image), values(Details), values(TargetObject), values(_time), values(EventCode), count by file_name, ComputerName
				Наконец, команда stats объединяет данные по file_name и ComputerName.
				Для каждой уникальной комбинации file_name и ComputerName она собирает все уникальные значения Image, Details, TargetObject и _time и подсчитывает количество событий.

		Подводя итог, этот запрос ищет случаи, когда процесс services.exe изменил значение ImagePath любой службы.
		Вывод будет включать сведения об этих изменениях, включая имя измененной службы, новое значение ImagePath и время изменения.

		Таким образом, среди менее частых результатов поиска очевидны признаки выполнения, напоминающие PsExec.

		//////////////////////////
		/// Sysmon Event ID 11 ///
		//////////////////////////
		
		index="main" sourcetype="WinEventLog:Sysmon" EventCode=11 Image=System | stats count by TargetFilename

		Опять же, среди менее частых результатов поиска очевидны признаки выполнения, напоминающие PsExec.

		//////////////////////////
		/// Sysmon Event ID 18 ///
		//////////////////////////

		index="main" sourcetype="WinEventLog:Sysmon" EventCode=18 Image=System | stats count by PipeName

		На этот раз результаты более поддаются анализу, и они по-прежнему указывают на шаблон выполнения, напоминающий PsExec.

	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	+ Detection Of Utilizing Archive Files For Transferring Tools Or Data Exfiltration +
	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	Обнаружение использования архивных файлов для передачи инструментов или утечки данных

	Злоумышленники могут использовать файлы zip, rar или 7z для передачи инструментов на скомпрометированный хост или извлечения данных с него.
	Следующий поиск проверяет создание файлов zip, rar или 7z, а результаты сортируются в порядке убывания на основе количества.

		index="main" EventCode=11 (TargetFilename="*.zip" OR TargetFilename="*.rar" OR TargetFilename="*.7z") | stats count by ComputerName, User, TargetFilename | sort - count

	В результатах поиска появляются явные признаки использования архивных файлов для целей передачи инструментов и/или извлечения данных.

	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	+ Detection Of Utilizing PowerShell or MS Edge For Downloading Payloads/Tools +
	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	Обнаружение использования PowerShell или MS Edge для загрузки полезных данных/инструментов

	Злоумышленники могут использовать PowerShell для загрузки дополнительных полезных нагрузок и инструментов или обманывать пользователей, заставляя их загружать вредоносное ПО через веб-браузеры.
	Следующие поиски SPL проверяют файлы, загруженные через PowerShell или MS Edge.

		index="main" sourcetype="WinEventLog:Sysmon" EventCode=11 Image="*powershell.exe*" |  stats count by Image, TargetFilename |  sort + count

	Также мы можем ипользовать параметр Zone.Identifier
	*Zone.Identifier указывает на файл, загруженный из Интернета или другого потенциально ненадежного источника.
	Windows использует этот идентификатор зоны для отслеживания зон безопасности файла.
	Zone.Identifier — это ADS (Alternate Data Stream), который содержит метаданные о том, откуда был загружен файл, и его настройках безопасности.	

		index="main" sourcetype="WinEventLog:Sysmon" EventCode=11 Image="*msedge.exe" TargetFilename=*"Zone.Identifier" |  stats count by TargetFilename |  sort + count

	В обоих результатах поиска появляются явные признаки использования PowerShell и MS Edge для загрузки полезных данных/инструментов.

	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	+ Detection Of Execution From Atypical Or Suspicious Locations +
	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	Обнаружение запуска процессов/файлов из нетипичных или подозрительных мест

	Следующий поиск SPL предназначен для идентификации любого создания процесса (EventCode=1), происходящего в папке «Downloads» пользователя.

		index="main" EventCode=1 | regex Image="C:\\\\Users\\\\.*\\\\Downloads\\\\.*" |  stats count by Image

	Среди менее частых результатов поиска появляются четкие указания, указывающие на выполнение из папки «Downloads» пользователя.

	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	+ Detection Of Executables or DLLs Being Created Outside The Windows Directory +
	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	Обнаружение исполняемых файлов или библиотек DLL, создаваемых вне каталога Windows

	Следующий SPL идентифицирует потенциальную вредоносную активность, проверяя создание исполняемых и DLL-файлов вне каталога Windows.
	Затем он группирует и подсчитывает эти действия по пользователю и имени целевого файла.

		index="main" EventCode=11 (TargetFilename="*.exe" OR TargetFilename="*.dll") TargetFilename!="*\\windows\\*" | stats count by User, TargetFilename | sort + count

	В менее частых результатах поиска появляются явные признаки, указывающие на создание исполняемых файлов вне каталога Windows.

	++++++++++++++++++++++++++++++++++++++++++++++++
	+ Detection Of Misspelling Legitimate Binaries +
	++++++++++++++++++++++++++++++++++++++++++++++++

	Обнаружение ошибок в написании легитимных двоичных файлов

	Злоумышленники часто маскируют свои вредоносные двоичные файлы, намеренно неправильно описывая легитимные, чтобы слиться с толпой и избежать обнаружения.
	Целью следующего поиска SPL является обнаружение потенциальных ошибок в написании легитимного двоичного файла PSEXESVC.exe, обычно используемого PsExec.
	Проверяя поля Image, ParentImage, CommandLine и ParentCommandLine, поиск направлен на выявление случаев, когда используются вариации psexe, что потенциально указывает на присутствие вредоносных двоичных файлов, пытающихся маскироваться под легитимный двоичный файл службы PsExec.

		index="main" sourcetype="WinEventLog:Sysmon" EventCode=1 (CommandLine="*psexe*.exe" NOT (CommandLine="*PSEXESVC.exe" OR CommandLine="*PsExec64.exe")) OR (ParentCommandLine="*psexe*.exe" NOT (ParentCommandLine="*PSEXESVC.exe" OR ParentCommandLine="*PsExec64.exe")) OR (ParentImage="*psexe*.exe" NOT (ParentImage="*PSEXESVC.exe" OR ParentImage="*PsExec64.exe")) OR (Image="*psexe*.exe" NOT (Image="*PSEXESVC.exe" OR Image="*PsExec64.exe")) |  table Image, CommandLine, ParentImage, ParentCommandLine

	В результатах поиска появляются явные признаки, указывающие на неправильное написание PSEXESVC.exe с целью уклонения от ответственности.

	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	+ Detection Of Using Non-standard Ports For Communications/Transfers +
	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	Обнаружение использования нестандартных портов для связи/передачи

	Злоумышленники часто используют нестандартные порты во время своих операций.
	Следующий поиск SPL обнаруживает подозрительные сетевые соединения с нестандартными портами, исключая стандартные веб-порты и порты передачи файлов (80, 443, 22, 21).
	Команда stats объединяет эти соединения, и они сортируются в порядке убывания по количеству.

		index="main" EventCode=3 NOT (DestinationPort=80 OR DestinationPort=443 OR DestinationPort=22 OR DestinationPort=21) | stats count by SourceIp, DestinationIp, DestinationPort | sort - count

	В результатах поиска появляются четкие указания, указывающие на использование нестандартных портов для связи или передачи инструментов.

=====================================================================
* Detecting Attacker Behavior Based On Analytics (example) *
************************************************************

Как упоминалось ранее, второй подход в значительной степени опирается на пониманиии поведения TTPs, статистический анализ и обнаружение аномалий для выявления ненормального поведения.
Профилируя нормальное поведение и выявляя отклонения от этой базовой линии, мы можем обнаружить подозрительные действия, которые могут означать вторжение.
Эти статистические модели обнаружения, хотя и основаны на данных, неизменно формируются на основе более широкого понимания методов, тактик и процедур злоумышленников (TTP).

Хорошим примером этого подхода в Splunk является использование команды streamstats.
Эта команда позволяет нам выполнять аналитику данных в реальном времени, что может быть полезно для выявления необычных шаблонов или тенденций.

	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	+ Monitoring the number of network connections initiated by a process within a certain time frame +
	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	Рассмотрим сценарий, в котором мы отслеживаем количество сетевых подключений, инициированных процессом в течение определенного периода времени.

		index="main" sourcetype="WinEventLog:Sysmon" EventCode=3 | bin _time span=1h | stats count as NetworkConnections by _time, Image | streamstats time_window=24h avg(NetworkConnections) as avg stdev(NetworkConnections) as stdev by Image | eval isOutlier=if(NetworkConnections > (avg + (0.5*stdev)), 1, 0) | search isOutlier=1

	Давайте разберем каждую часть этого запроса:

		i)		Сначала мы сосредоточимся на событиях сетевых подключений (EventCode=3)
		ii)		Затем сгруппируем эти события в часовые интервалы (bin можно рассматривать как псевдоним сегмента)
		ii)		Для каждого уникального образа процесса (Image) мы вычисляем количество событий сетевых подключений за временной сегмент.
		iv)		Используя команду streamstats нам надо вычислить скользящую среднюю и стандартное отклонение количества сетевых подключений за 24-часовой период для каждого уникального образа процесса.
				Это дает нам динамическую базовую линию для сравнения каждой точки данных.
		v)		Далее используя команду eval создадим новое поле isOutlier и присвоим ему значение 1 для любого события, где количество сетевых подключений отличается от среднего более чем на 0,5 стандартных отклонений.
				Это помечает эти события как статистически аномальные и потенциально указывающие на подозрительную активность.
		vi)		Наконец, команда search фильтрует наши результаты, чтобы включить только выбросы, т. е. события, где isOutlier равен 1.

	Отслеживая аномалии в сетевых соединениях, инициированных процессами, мы можем обнаружить потенциально вредоносные действия, такие как попытки командно-контрольной связи или эксфильтрации данных.
	Однако, как и в случае с любым методом обнаружения аномалий, важно помнить, что он может давать ложные срабатывания и должен быть откалиброван в соответствии со спецификой вашей среды.

	При более внимательном рассмотрении результатов мы наблюдаем наличие многочисленных подозрительных процессов, которые были выявлены ранее, хотя не все из них очевидны.

	+++++++++++++++++++++++++++++++++++++++++
	+ Detection Of Abnormally Long Commands +
	+++++++++++++++++++++++++++++++++++++++++

	Обнаружение аномально длинных команд

	Злоумышленники часто используют чрезмерно длинные команды в своих операциях для достижения своих целей.
	Для обнаружения запросов с необычно длинной командой, можно использовать слежующий запрос

		index="main" sourcetype="WinEventLog:Sysmon" Image=*cmd.exe | eval len=len(CommandLine) | table User, len, CommandLine | sort - len

	После просмотра результатов мы замечаем некоторую безвредную активность, которую можно отфильтровать, чтобы уменьшить шум.
	Давайте применим следующие изменения к поиску.

		index="main" sourcetype="WinEventLog:Sysmon" Image=*cmd.exe ParentImage!="*msiexec.exe" ParentImage!="*explorer.exe" | eval len=len(CommandLine) | table User, len, CommandLine | sort - len

	Мы снова наблюдаем повторение вредоносной активности, которую мы ранее выявили в ходе нашего расследования.

	++++++++++++++++++++++++++++++++++++++++++
	+ Detection Of Abnormal cmd.exe Activity +
	++++++++++++++++++++++++++++++++++++++++++

	Обнаружение аномальной активности cmd.exe

	Следующий поиск определяет необычную активность cmd.exe в определенном временном диапазоне.
	Он использует команду bucket для группировки событий по часам, вычисляет количество, среднее значение и стандартное отклонение выполнений cmd.exe и отмечает выбросы.
		
		index="main" EventCode=1 (CommandLine="*cmd.exe*") | bucket _time span=1h | stats count as cmdCount by _time User CommandLine | eventstats avg(cmdCount) as avg stdev(cmdCount) as stdev | eval isOutlier=if(cmdCount > avg+1.5*stdev, 1, 0) | search isOutlier=1

	При более внимательном изучении результатов мы наблюдаем наличие подозрительных команд, которые были выявлены ранее, хотя не все из них очевидны.

	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	+ Detection Of Processes Loading A High Number Of DLLs In A Specific Time +
	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	Обнаружение процессов, загружающих большое количество DLL в определенное время

	Вредоносное ПО нередко загружает несколько DLL-файлов в быстрой последовательности.
	Следующий SPL может помочь в мониторинге этого поведения.

		index="main" EventCode=7 | bucket _time span=1h | stats dc(ImageLoaded) as unique_dlls_loaded by _time, Image | where unique_dlls_loaded > 3 | stats count by Image, unique_dlls_loaded

	После просмотра результатов мы замечаем некоторую безвредную активность, которую можно отфильтровать, чтобы уменьшить шум.
	Давайте применим следующие изменения к поиску
			
		index="main" EventCode=7 NOT (Image="C:\\Windows\\System32*") NOT (Image="C:\\Program Files (x86)*") NOT (Image="C:\\Program Files*") NOT (Image="C:\\ProgramData*") NOT (Image="C:\\Users\\waldo\\AppData*")| bucket _time span=1h | stats dc(ImageLoaded) as unique_dlls_loaded by _time, Image | where unique_dlls_loaded > 3 | stats count by Image, unique_dlls_loaded | sort - unique_dlls_loaded

	Давайте разберем каждую часть этого запроса:

		index="main" EventCode=7 NOT (Image="C:\\Windows\\System32*") NOT (Image="C:\\Program Files (x86)*") NOT (Image="C:\\Program Files*") NOT (Image="C:\\ProgramData*") NOT (Image="C:\\Users\\waldo\\AppData*")
			эта часть запроса отвечает за выборку всех событий из основного индекса, где EventCode равен 7 (события загрузки изображения в журналах Sysmon).
			Фильтры NOT исключают события из известных безопасных путей (например, "Windows\System32", "Program Files", "ProgramData" и каталог "AppData" определенного пользователя).
		
		bucket _time span=1h
			эта команда используется для группировки событий во временные интервалы длительностью в один час.
			Это используется для анализа данных в часовых интервалах.

		stats dc(ImageLoaded) as unique_dlls_loaded by _time, Image
			Команда stats используется для выполнения статистических операций над событиями.
			Здесь dc(ImageLoaded) вычисляет уникальное количество загруженных DLL (ImageLoaded) для каждого образа процесса (Image) в каждом часовом временном интервале.

		where unique_dlls_loaded > 3
			Этот фильтр исключает результаты, в которых количество уникальных DLL, загруженных процессом в течение часа, составляет 3 или меньше.\
			Это основано на предположении, что легальное программное обеспечение обычно загружает DLL с умеренной скоростью, тогда как вредоносное ПО может быстро загружать много разных DLL.

		stats count by Image, unique_dlls_loaded
			Эта команда вычисляет количество загрузок каждым процессом (Image) более 3 уникальных DLL в час.

		sort - unique_dlls_loaded
			Наконец, эта команда сортирует результаты в порядке убывания на основе количества загруженных уникальных DLL (unique_dlls_loaded).

	При более внимательном изучении результатов мы наблюдаем наличие подозрительных процессов, которые были выявлены ранее, хотя не все из них очевидны.

	Важно отметить, что такое поведение может демонстрироваться и легитимным программным обеспечением во многих случаях
	Поэтому для подтверждения вредоносной активности потребуются контекст и дополнительное расследование.

	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	+ Detection Of Transactions Where The Same Process Has Been Created More Than Once On The Same Computer +
	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	Обнаружение транзакций, в которых один и тот же процесс был создан более одного раза на одном компьютере

	Допустим, нам надо сопоставить события, когда один и тот же процесс (Image) выполняется на одном и том же компьютере (ComputerName), поскольку это может указывать на аномалии в зависимости от характера задействованных процессов.
	Как всегда, для подтверждения того, является ли это действительно вредоносным или просто безобидным явлением, понадобятся контекст и дополнительное расследование.
	Следующий SPL может помочь в мониторинге этого поведения.

		index="main" sourcetype="WinEventLog:Sysmon" EventCode=1 | transaction ComputerName, Image | where mvcount(ProcessGuid) > 1 | stats count by Image, ParentImage

	Давайте разберем каждую часть этого запроса:

		index="main" sourcetype="WinEventLog:Sysmon" EventCode=1
			эта часть запроса извлекает все события создания процесса Sysmon (EventCode=1) из основного индекса.
			Код события Sysmon 1 представляет событие создания процесса, которое включает такие сведения, как запущенный процесс, его аргументы командной строки, запустивший его пользователь и процесс, из которого он был запущен.

		transaction ComputerName, Image
			команда transaction используется для группировки связанных событий на основе общих значений полей.
			В этом случае события группируются, если они имеют одинаковые значения ComputerName и Image.
			Это может помочь связать все события создания процесса, связанные с определенной программой на определенном компьютере.

		where mvcount(ProcessGuid) > 1
			эта команда фильтрует результаты, чтобы включить только транзакции, в которых более одного уникального GUID процесса (ProcessGuid) связано с одним и тем же образом программы (Image) на одном и том же компьютере (ComputerName).
			Обычно это представляет случаи, когда одна и та же программа была запущена более одного раза.

		stats count by Image, ParentImage
			Наконец, эта команда stats используется для подсчета количества таких экземпляров по образу программы (Image) и образу ее родительского процесса (ParentImage).
	
	Давайте компнем еще чуть глубже и подробнее рассмотрим взаимосвязь между rundll32.exe и svchost.exe (поскольку эта пара имеет наибольшее количество).

		index="main" sourcetype="WinEventLog:Sysmon" EventCode=1  | transaction ComputerName, Image  | where mvcount(ProcessGuid) > 1 | search Image="C:\\Windows\\System32\\rundll32.exe" ParentImage="C:\\Windows\\System32\\svchost.exe" | table CommandLine, ParentCommandLine

	После тщательного изучения результатов становится очевидным, что мы не только выявляем наличие ранее выявленных подозрительных команд, но и новые.

////////////////////////////////////
Using "Search & Reporting" find through SPL searches against all data the password utilized during the PsExec activity. 
Используя «Поиск и отчеты», найдите с помощью поиска SPL все данные, пароли которых использовались во время активности PsExec.

	index="main"  CommandLine="*psexec*.exe*" | stats count by CommandLine | sort - count


///////////////////////////////////
Using "Search & Reporting" find through an analytics-driven SPL search against all data the source process images that are creating an unusually high number of threads in other processes.
Enter the outlier process name as your answer where the number of injected threads is greater than two standard deviations above the average. 

Используя «Поиск и отчетность», найдите с помощью аналитического поиска SPL по всем данным исходные образы процессов, которые создают необычно большое количество потоков в других процессах.
Введите в качестве ответа название процесса-выброса, где количество внедренных потоков превышает среднее значение более чем на два стандартных отклонения.

	index=* (EventCode=8 OR “CreateRemoteThread” OR “thread creation”) | stats count as ThreadCount by SourceProcess | eventstats avg(ThreadCount) as avgThreads, stdev(ThreadCount) as stdevThreads | where ThreadCount > (avgThreads + (2 * stdevThreads)) | table SourceProcess, ThreadCount 


index="main" EventCode=8 TargetImage="*rundll32.exe*" | stats count by SourceImage, TargetImage
10.129.215.250