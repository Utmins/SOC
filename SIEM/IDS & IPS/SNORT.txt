Snort — это инструмент с открытым исходным кодом, который служит как системой обнаружения вторжений (IDS), так и системой предотвращения вторжений (IPS), но также может функционировать как регистратор пакетов или сниффер, похожий на Suricata.
Тщательно проверяя весь сетевой трафик, Snort имеет возможность идентифицировать и регистрировать всю активность в этом трафике, предоставляя комплексное представление о ситуации и подробные журналы всех транзакций на уровне приложений.
Нам требуются определенные наборы правил, чтобы указать Snort, как выполнять проверку и что именно ему нужно идентифицировать.
Snort был создан для эффективной работы как на универсальном, так и на пользовательском оборудовании.

С полным гайдлм по SNORT можно ознакомиться тут	-	https://docs.snort.org/

=====================================================================
* General Terms *
*****************

	+++++++++++++++++++++++++
	+ Snort Operation Modes +
	+++++++++++++++++++++++++

	Snort обычно работает в следующих режимах:

		A) 	Sniffer Mode
        		Считывает IP-пакеты и запрашивает их в консольном приложении.

			Как и tcpdump, Snort имеет различные флаги, позволяющие просматривать различные данные о пакете, который он принимает.
			Вот основные параметры Sniffer Mode:

    			Parameter	Description
    			-v              Подробно/детальное отображение вывода TCP/IP в консоли.
    			-d              Отображение данных пакета (полезная нагрузка).
    			-e              Отображение заголовков канального уровня (TCP/IP/UDP/ICMP).
    			-X              Отображение полной информации о пакете в шестнадцатеричном формате.
    			-i              Этот параметр помогает определить конкретный сетевой интерфейс для прослушивания/анализа.
                   				Если у вас есть несколько интерфейсов, вы можете выбрать конкретный интерфейс для анализа.

			Пример запуска

    			<user_name>@<host_name>$ sudo snort -v -i eth0

		B)	Packet Logger Mode
			Регистрирует все IP-пакеты (входящие и исходящие), которые посещают сеть.

			Вы можете использовать Snort в качестве сниффера и регистрировать перехваченные пакеты через режим регистратора.
			Вам нужно только использовать параметры режима регистратора пакетов, а Snort сделает все остальное, чтобы добиться этого.

    			Parameter	    Description
    			-l              Режим логгера, целевой журнал и каталог вывода оповещений.
                   				Папка вывода по умолчанию — /var/log/snort
                   				Действие по умолчанию — выгрузить в формате tcpdump в /var/log/snort
    
    			-K ASCII        Пакеты журнала в формате ASCII.
                   				Логи, созданные с параметром "-K ASCII", совершенно другие.
                    
    			-r              Параметр чтения, чтение выгруженных журналов в Snort.
    
    			-n              Укажите количество пакетов, которые будут обработаны/прочитаны.
                   				Snort остановится после прочтения указанного количества пакетов.

			Перед созданием журналов и их исследованием мы должны помнить о владельце файлов Linux и разрешениях.
			***	Основное правило владения файлами: тот, кто создает файл, становится владельцем соответствующего файла.

			Snort НУЖНЫ ПРАВА суперпользователя (root) для прослушивания трафика, поэтому после запуска snort с помощью команды "sudo" учетная запись "root" будет владеть сгенерированными файлами журналов.
			Поэтому вам понадобятся права "root" для исследования файлов журналов.
			Существует два разных подхода к исследованию сгенерированных файлов журналов;

    			-  	Elevation of privileges
        			Вы можете повысить свои привилегии для исследования файлов.
        			Вы можете использовать команду "sudo" для выполнения своей команды как суперпользователь с помощью следующей команды sudo command.
        			Вы также можете повысить привилегии сеанса и переключиться на учетную запись суперпользователя, чтобы изучить сгенерированные файлы журнала, с помощью следующей команды: sudo su

    			-	Changing the ownership of files/directories
        			Вы также можете изменить владельца файла/папки, чтобы читать его как ваш пользователь: 
        
            			sudo chown имя_пользователя file
            			sudo chown имя_пользователя -R (каталог)

			Способы использования Packet Logger

				//////////////
				/// COMMON ///
				//////////////

				Чтобы использовать SNORT в режиме Packet Logger (пакетного регистратора) необходимо использовать следующие параметры (dev - это три разных параметра: -d, -e, -v)

    				<user_name>@<host_name>$ sudo snort -dev -l -<interface_name> /path/to/save/log/files

				После того Snort начнет показывать пакеты и регистрировать их в указанном каталоге.
				Вы можете настроить выходной каталог по умолчанию в файле snort.config.
				Но также вы можете использовать параметр "-l" для установки целевого каталога.
				***	Определение каталога журналов по умолчанию полезно для непрерывных операций мониторинга, а параметр "-l" гораздо полезнее для целей тестирования.

				/////////////
				/// ASCII ///
				/////////////
				
				Для создания логов в формате ASCII необходимо использовать следующую команду

        			<user_name>@<host_name>$ sudo snort -dev -K ASCII -<interface_name> -l /path/to/save/log/files

				Данный параметр создает две папки с именами IP-адресов и лог-файл.
				Если присмотреться к созданным папкам, то можно увидеть, что журналы находятся в формате ASCII и категоризируются, поэтому их можно читать без использования экземпляра Snort.

				В двух словах, режим ASCII предоставляет несколько файлов в удобном для чтения формате, поэтому можно легко читать журналы с помощью текстового редактора. 
				В отличие от формата ASCII, двоичный формат неудобен для чтения человеком и требует анализа с помощью Snort или приложения, такого как tcpdump.

				***	!ПОМНИТЕ! Если вы создаете журналы с параметром "-K ASCII", Snort не будет их читать, так как он может читать и обрабатывать только двоичный вывод

				//////////////////
				/// READIN LOG ///
				//////////////////				

				Для чтения логов в Snort  используют следующий синтаксис:

    				<user_name>@<host_name> sudo snort -r /path/to/the/log/<file_name>.log

				Если необходимо просматривать только определенные пакеты (к примеру только ICMP или TCP или конкретный #порта), то можно использовать Berkeley Packet Filters (BPF).

    				<user_name>@<host_name>$ sudo snort -r logname.log -X                   -  	указывает, что нужно выводить данные в человеко-читаемом виде.
     					                                                       					Он позволяет отображать полный содержимый трафик (включая пакеты данных) в шестнадцатеричном (hex) и ASCII формате.
    				<user_name>@<host_name>$ sudo snort -r logname.log icmp                 -	указывает, что нужно выводить только ICMP пакеты
    				<user_name>@<host_name>$ sudo snort -r logname.log tcp                  -	указывает, что нужно выводить только TCP пакеты
    				<user_name>@<host_name>$ sudo snort -r logname.log 'udp and port 53'	-	указывает, что нужно выводить только UDP пакеты c с порта 53
    				<user_name>@<host_name>$ sudo snort -dvr logname.log -n 10              -	указывает, что нужно выводить только первые 10 пакетов


		C)	NIDS (Network Intrusion Detection System)  and NIPS (Network Intrusion Prevention System) Modes
			Регистрирует/отбрасывает пакеты, которые считаются вредоносными в соответствии с определенными пользователем правилами.

			Вот несколько часто используемых параметров режима NIDS/NIPS

    			Parameter	Description
    			-c          Определение файла конфигурации
				-v			Детальное логирование
    			-T          Тестирование файла конфигурации
				-X			Полный дамп пакетов
    			-N          Отключения введения журнала записи (логгирования)
							
								<user_name>@<host_name>$ sudo snort -c /etc/snort/<config.filename> -N

    			-D          Запуск анализа трафика в фоновом режиме

								<user_name>@<host_name>$ sudo snort -c /etc/snort/<config.filename> -D

                    		Обратите внимание, что данный режим в основном используется для автоматизации Snort.
                    		Этот параметр в основном используется в скриптах для запуска службы Snort в фоновом режиме.
							Однако, если вы активируете детализацию (-v) или полный дамп пакетов (-X) с режимом пакетного регистратора (-l), у вас все равно будут журналы в папке журналов, но в консоли не будет вывода.
                    		***	Не рекомендуется использовать этот режим, если у вас нет практических знаний Snort и стабильной конфигурации.

							Для проверки активности snort в фоновом режиме, можно использовать следующую команду

            					<user_name>@<host_name>$ ps -ef | grep snort

    			-A          Режимы оповещений:
                        		full	-	Полный режим оповещения, предоставляющий всю возможную информацию о оповещении.
                            				Этот режим также является режимом по умолчанию (т.е. если вы используете -A и не указываете какой-либо режим, snort использует этот режим.)
                            
												<user_name>@<host_name>$ sudo snort -c /etc/snort/snort.conf -A full
    
                        		fast	- 	Быстрый режим показывает сообщение оповещения, временную метку, исходный и целевой IP-адреса, а также номера портов.
                                    		Помните, что в этом режиме нет вывода на консоль.
                                    					
												<user_name>@<host_name>$sudo snort -c /etc/snort/snort.conf -A fast

                        		console	-  	Консольный режим обеспечивает быстрые оповещения на экране консоли.
                                    		Проще говоря, консольный режим предоставляет базовую информацию о заголовках и правилах.
                                    					
												<user_name>@<host_name>$ sudo snort -c /etc/snort/<config.filename> -A console

                        		cmg     -  	Режим Cmg предоставляет основные сведения о заголовке с полезной нагрузкой в ​​шестнадцатеричном и текстовом формате.
                                    		Другими словами, Cmg-режим предоставляет полную информацию о пакетах вместе с информацией о правилах.
                                    					
												<user_name>@<host_name>$ sudo snort -c /etc/snort/snort.conf -A cmg

                        		none    -  	Этот режим не создает файл оповещения.
                                    		Однако он все равно регистрирует трафик и создает файл журнала в формате двоичного дампа.
                                    		Помните, что в этом режиме нет вывода на консоль.
                                    					
												<user_name>@<host_name>$ sudo snort -c /etc/snort/snort.conf -A none

			Вот пример сложного консольного запроса
			"Тихий анализ трафика с возможностью вмешательства в структуру трафика для блокировки/пропуска того или иного пакета в зависимости от настроек правил"

				<user_name>@<host_name>$  sudo snort -c /etc/snort/<config.filename> -q -Q --daq afpacket -i eth0:eth1 -A console

					-q:                 Опция -q переводит Snort в "тихий" режим, что означает, что стандартные диагностические сообщения не будут выводиться на экран.
                                        Это снижает шум в выводе и делает вывод более сжатым.

                    -Q:                 Включает режим "inline", который позволяет Snort не только анализировать трафик, но и вмешиваться в сетевой трафик.
                                        В этом режиме Snort может блокировать, изменять или пропускать пакеты в зависимости от настроек правил.

                    --daq afpacket:     Эта опция указывает Snort, какой драйвер захвата пакетов (Data Acquisition Library, DAQ) использовать.
                                        В данном случае используется afpacket, который позволяет Snort работать на уровне канального уровня (OSI Layer 2), обеспечивая мониторинг и вмешательство в сетевые пакеты между интерфейсами.
										afpacket поддерживает работу с несколькими интерфейсами.

                    -i eth0:eth1:       Указывает сетевые интерфейсы для мониторинга.
                                        Здесь используется два интерфейса: eth0 и eth1.
                                        Пара eth0:eth1 говорит Snort о том, что нужно использовать эти интерфейсы для захвата трафика (например, захват с одного и отправка на другой).

                    -A console:         Опция -A задает режим оповещения Snort.
										console указывает, что все оповещения о подозрительных пакетах будут выводиться непосредственно в консоль.

		D)	READING PCAP
			Возможности Snort не ограничиваются сниффингом, протоколированием и обнаружением/предотвращением угроз.
			Режим чтения/исследования PCAP помогает вам работать с файлами pcap.
			Если у вас есть файл pcap, то вы можете обработать его с помощью Snort, вы получить статистику трафика по умолчанию с оповещениями в зависимости от вашего набора правил.
			Мы исследуем pcap с помощью Snort, чтобы извлечь пользу из правил и ускорить процесс расследования, используя известные шаблоны угроз.

			Чтение pcap без использования дополнительных параметров, позволит только просмотреть пакеты и предоставить статистику о файле.
			В большинстве случаев это не очень удобно.
			
			Основные Параметры режима PCAP следующие:

    			Parameter				Description
    			-r / --pcap-single=	    Прочитать один pcap
    			--pcap-list=""	       	Прочитать pcap, указанные в команде (разделенные пробелом).
    			--pcap-show	            Показывать имя pcap на консоли во время обработки.

			Примеры использования параметров:

    			-	Анализ pcap-файла с выбранным файлом конфигурации (желательно находится в той же папке что и pcap-файл)

            			<user_name>@<host_name>$ sudo snort -c /etc/snort/<config.filename> -q -r <pcap.filename> -A console -n 10
    
    			-	Анализ нескольих pcap-файлов с выбранным файлом конфигурации (желательно находится в той же папке что и pcap-файлы)

            			<user_name>@<host_name>$ sudo snort -c /etc/snort/<config.filename> -q --pcap-list="<pcap.filename1> <pcap.filename2>" -A console -n 10
        
        			***	Один момент, на который следует обратить внимание   -   при обработке двх pcap-файлов, результаты суммируются
            		Из-за этого невозможно сопоставить оповещения по каждому pcap-файлу в отдельности.
            		Следовательно, нам нужно разделить результаты каждого pcap-файла, чтобы определить источник оповещений.
    
    			-   Анализ нескольих pcap-файлов с выбранным файлом конфигурации, но каждый pcap-файл проанализирован отдельно (желательно находится в той же папке что и pcap-файлы)

            			<user_name>@<host_name>$ sudo snort -c /etc/snort/<config.filename> -q --pcap-list="<pcap.filename1> <pcap.filename2>" -A console --pcap-show


	Согласно документации Snort	-	С некоторыми модулями сбора данных Snort может использовать два различных режима работы:

		-	Passive
			Пассивный режим дает Snort возможность наблюдать и обнаруживать трафик на сетевом интерфейсе, но он предотвращает прямую блокировку трафика.

		-	Inline
			С другой стороны, встроенный (inline) режим дает Snort возможность блокировать трафик, если конкретный пакет требует такого события.

	Snort определит конкретный режим работы на основе параметров (DAQ - Data Acquisition library), используемых в командной строке.
	Например

		i)		-r
				Чтение из файла pcap 

		ii)		-i
				Прослушивание интерфейса
				Этот параметр заставит Snort работать в пассивном режиме по умолчанию.

		iii)	-Q
				Однако, если DAQ поддерживает встроенный режим, пользователи могут указать флаг -Q для запуска Snort inline.

		iv)		afpacket
				Один из модулей DAQ, поддерживающий inline-режим, который предоставляет Snort доступ к пакетам, полученным на сетевых устройствах Linux.

	++++++++++++++++++++++
	+ Snort Architecture +
	++++++++++++++++++++++

	Для того чтобы Snort перешел от простого сниффера пакетов к надежной системе обнаружения вторжений, было добавлено несколько ключевых компонентов:

		-	Packet Sniffer
			Сниффер пакетов (включающий декодер пакетов) извлекает сетевой трафик, распознавая структуру каждого пакета.
			Собранные необработанные пакеты впоследствии пересылаются препроцессорам (preprocessors).

		-	Preprocessors
			Препроцессоры в Snort определяют тип или поведение пересылаемых пакетов.
			Snort имеет массив плагинов препроцессоров, таких как

				i)	Plugin HTTP, который различает пакеты, связанные с HTTP
				ii)	port_scan, который определяет потенциальные попытки сканирования портов на основе предопределенных протоколов, типов сканирования и пороговых значений.
			
			После того, как препроцессоры завершат свою задачу, информация передается в механизм обнаружения (Detection Engine).
			Конфигурацию этих препроцессоров можно найти в файле конфигурации Snort, snort.lua.
	
		-	Detection Engine
			Механизм обнаружения сравнивает каждый пакет с предопределенным набором правил Snort. 
			Если совпадение найдено, информация передается в систему регистрации и оповещения (Logging and Alerting System).

		-	Logging and Alerting System and Output modules
			Модули системы регистрации и оповещения и вывода отвечают за запись или запуск оповещений, как определено каждым действием правила.
			Журналы обычно хранятся в форматах syslog или unified2 или непосредственно в базе данных.
			Модули вывода настраиваются в файле конфигурации Snort, snort.lua.

	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	+ Snort Configuration & Validating Snort's Configuration +
	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	Сперва следует проверить, установлен ли snort.
	Следующая команда покажет вам версию экземпляра (и если Snort не установлен, то она сама предложит его установить).

    	<user_name>@<host_name>$ snort -V

       		,,_     -*> Snort! <*-
       		o"  )~   Version 2.9.7.0 GRE (Build XXXXXX) 
			''''    By Martin Roesch & The Snort Team: http://www.snort.org/contact#team
            		Copyright (C) 2014 Cisco and/or its affiliates. All rights reserved.
                   	Copyright (C) 1998-2013 Sourcefire, Inc., et al.
                    	Using libpcap version 1.9.1 (with TPACKET_V3)
                    	Using PCRE version: 8.39 2016-06-14
                    	Using ZLIB version: 1.2.11

	Далее, мы должны убедиться, что наш файл конфигурации действителен:

    	<user_name>@<host_name>$ sudo snort -c /etc/snort/snort.conf -T

            "-T" используется для тестирования конфигурации
            "-c" идентифицирует файл конфигурации (snort.conf).

	***	Обратите внимание, что можно использовать дополнительный файл конфигурации, указав его с помощью "-c".

	Как только мы используем файл конфигурации, snort становится намного мощнее!
	Файл конфигурации — это файл управления snort «все в одном».
	Здесь определяются правила, плагины, механизмы обнаружения, действия по умолчанию и настройки вывода.
	Можно иметь несколько файлов конфигурации для разных целей и случаев, НО можно использовать ТОЛЬКО ОДИН во время выполнения.

	***	Обратите внимание, что каждый раз при запуске Snort он автоматически отображает баннер по умолчанию и начальную информацию о вашей настройке.
    	Вы можете предотвратить это, используя параметр «-q».

	Если отсутствует файл snort.conf, его можно создать вручную или загрузить с официального сайта Snort.
	Вот что можно сделать:

    	-   Перейдите на Snort.org и выберите последнюю версию Snort.
    	-   В скачанном пакете будет файл snort.conf, который можно скопировать в нужное вам место (например, в /etc/snort/snort.conf).

	Так же можно создать файл вручную

	Snort предлагает широкий спектр вариантов конфигурации, и, к счастью, открытый исходный код Snort 3 предоставляет пользователям предварительно настроенные файлы для облегчения быстрого старта.
	Эти файлы конфигурации по умолчанию, а именно snort.lua и snort_defaults.lua, служат основой для настройки Snort и его скорейшего ввода в эксплуатацию.
	Они предоставляют стандартную структуру конфигурации для пользователей Snort.

	Файл snort.lua служит основным файлом конфигурации для Snort.
	Этот файл содержит следующие разделы:

		-	Network variables									(Сетевые переменные)
		-	Decoder configuration								(Конфигурация декодера)
		-	Base detection engine configuration					(Конфигурация базовой системы обнаружения)
		-	Dynamic library configuration						(Конфигурация динамической библиотеки)
		-	Preprocessor configuration							(Конфигурация препроцессора)
		-	Output plugin configuration							(Конфигурация выходного плагина)
		-	Rule set customization								(Настройка набора правил)
		-	Preprocessor and decoder rule set customization		(Настройка набора правил препроцессора и декодера)
		-	Shared object rule set customization				(Настройка набора правил общего объекта)
	
	Чтобы просмотреть файл snort.lua, используем следующую команду

		<user_name>@<host_name>$ sudo more /root/snorty/etc/snort/snort.lua

	Запуск и тонкая настройка модулей Snort является важным аспектом процесса конфигурации.
	Чтобы изучить полный список и получить краткое описание всех модулей Snort 3, вы можете использовать следующую команду.

		<user_name>@<host_name>$ snort --help-modules

	Эти модули включаются и настраиваются в файле конфигурации snort.lua как Lua table literals.
	Если модуль инициализируется как пустая таблица, это означает, что он использует свои предопределенные настройки "по умолчанию".
	Чтобы просмотреть эти настройки по умолчанию, вы можете использовать следующую команду.

		<user_name>@<host_name>$ snort --help-config <module_name>

	Передача (и проверка) файлов конфигурации в Snort может быть выполнена следующим образом.

		<user_name>@<host_name>$ snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq

	***	Примечание: --daq-dir /usr/local/lib/daq не требуется для передачи и проверки файла конфигурации.
		Он добавлен, чтобы мы могли реплицировать команду в цели этого раздела.

	Поскольку мы упомянули DAQ, Snort 3 должен знать, где найти соответствующий LibDAQ.
	LibDAQ — это «библиотека сбора данных», и на высоком уровне это уровень абстракции, используемый модулями для связи с аппаратными и программными сетевыми источниками данных.

	***	Настоятельно рекомендуем уделить время прочтению комментариев внутри файла snort.lua, поскольку они дают ценную информацию.


		//////////////////////////////////
		/// SNORT CONFIG FILE OVERVIEW ///
		//////////////////////////////////

		Navigate to the "Step #1: Set the network variables." section.

		1)	This section manages the scope of the detection and rule paths.

        		TAG NAME	        INFO	                                                                                EXAMPLE
        
        		HOME_NET                That is where we are protecting                                                         'any' OR '192.168.1.1/24'
        		EXTERNAL_NET            This field is the external network, so we need to keep it as 'any' or '!$HOME_NET'      'any' OR '!$HOME_NET'
        		RULE_PATH               Hardcoded rule path                                                                     /etc/snort/rules
        		SO_RULE_PATH            These rules come with registered and subscriber rules                                   $RULE_PATH/so_rules
        		PREPROC_RULE_PATH       These rules come with registered and subscriber rules                                   $RULE_PATH/plugin_rules

		2)	Navigate to the "Step #2: Configure the decoder." section.

			In this section, you manage the IPS mode of snort.
			The single-node installation model IPS model works best with "afpacket" mode.
			You can enable this mode and run Snort in IPS.

        		TAG NAME	        INFO	                        	EXAMPLE
        
        		#config daq:	    IPS mode selection.	            	afpacket
        		#config daq_mode:	Activating the inline mode	    	inline
        		#config logdir:	    Hardcoded default log path.	    	/var/logs/snort

			Data Acquisition Modules (DAQ) are specific libraries used for packet I/O, bringing flexibility to process packets.
			It is possible to select DAQ type and mode for different purposes.

		3) 	There are six DAQ modules available in Snort;

    			-   Pcap
        			Default mode, known as Sniffer mode.
    
    			-   Afpacket
        			Inline mode, known as IPS mode.
    
    			-   Ipq
        			Inline mode on Linux by using Netfilter.
        			It replaces the snort_inline patch.  
    
    			-   Nfq
        			Inline mode on Linux.
    
    			-   Ipfw
        			Inline on OpenBSD and FreeBSD by using divert sockets, with the pf and ipfw firewalls.
    
    			-   Dump
        			Testing mode of inline and normalisation.

			The most popular modes are the default (pcap) and inline/IPS (Afpacket).

		4) 	Navigate to the "Step #6: Configure output plugins" section.

			This section manages the outputs of the IDS/IPS actions, such as logging and alerting format details. 
			The default action prompts everything in the console application, so configuring this part will help you use the Snort more efficiently. 

		5) 	Navigate to the "Step #7: Customise your ruleset" section.

        		TAG NAME	                INFO	                                            EXAMPLE
        
        		# site specific rules       Hardcoded local and user-generated rules path       include $RULE_PATH/local.rules
        		#include $RULE_PATH/        Hardcoded default/downloaded rules path             include $RULE_PATH/rulename

			Note that "#" is commenting operator.
			You should uncomment a line to activate it.

	++++++++++++++++
	+ Snort Inputs +
	++++++++++++++++

	Чтобы понаблюдать за Snort в действии, самый простой способ — запустить его на файле захвата пакетов.
	Указав имя файла pcap в качестве аргумента опции -r в командной строке, Snort обработает файл соответствующим образом.

		<user_name>@<host_name>$ sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq -r /folder/where/you/keep/your/pcap_files/<file_name>.pcap

	Snort также имеет возможность прослушивать активные сетевые интерфейсы.
	Чтобы указать это поведение, вы можете использовать опцию -i, за которой следуют имена интерфейсов, на которых должен работать Snort.

		<user_name>@<host_name>$ sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq -i <interface_name>

	+++++++++++++++++
	+ Snort Outputs +
	+++++++++++++++++

	Во время использования Snort Вы можете столкнуться со значительным объемом данных.
	Чтобы предоставить сводку основных типов выходных данных, давайте рассмотрим ключевые аспекты:

		-	Basic Statistics (основная статистика)
			После завершения работы Snort генерирует различные счетчики на основе конфигурации и обработанного трафика.
			Сюда входит:

				i)		Packet Statistics (Статистика пакетов)
						Включает информацию из DAQ и декодеров, такую ​​как количество полученных пакетов и пакетов UDP.

				ii)		Module Statistics (Статистика модулей)
						Каждый модуль отслеживает активность с помощью счетчиков peg, указывающих частоту наблюдаемых или выполненных действий.
						Примеры включают количество обработанных запросов HTTP GET и обрезанных пакетов сброса TCP.

				iii)	File Statistics (Статистика файлов)
						В зависимости от потребонстей (целей и задач) можно разделе приводить разбивка по разным типпм
						К примеру по типам файлов, байтов и сигнатур.

				iv)		Summary Statistics (Сводная статистика)
						Охватывает общее время выполнения обработки пакетов, пакеты в секунду и, если настроено, данные профилирования.

		-	Alerts (Оповещения)
			При настройке правил необходимо включить оповещения (с помощью параметра -A), чтобы просмотреть сведения о событиях обнаружения.
			Доступно несколько типов выходных сигналов оповещения, в том числе:

				i)		-A cmg
						Этот параметр объединяет -A fast -d -e и отображает информацию оповещения вместе с заголовками пакетов и полезной нагрузкой.

				ii)		-A u2
						Этот параметр эквивалентен -A unified2 и регистрирует события и пакеты запуска в двоичном файле, который можно использовать для постобработки с другими инструментами.

				iii)	-A csv
						Этот параметр выводит поля в формате значений, разделенных запятыми, предоставляя возможности настройки и облегчая анализ pcap.

			Чтобы узнать доступные типы оповещений, мы можем выполнить следующую команду (на примере плагина logger):

				<user_name>@<host_name>$ snort --list-plugins | grep <plugin_type>
			
					logger::alert_csv v0 static
					logger::alert_fast v0 static
					logger::alert_full v0 static
					logger::alert_json v0 static
					logger::alert_syslog v0 static
					logger::alert_talos v0 static
					logger::alert_unixsock v0 static
					logger::log_codecs v0 static
					logger::log_hext v0 static
					logger::log_pcap v0 static
					logger::unified2 v0 static

		-	Performance Statistics (Статистика производительности)
			Помимо вышеупомянутых выводов данных, можно получить дополнительные данные.
				
				Настроив модуль perf_monitor, мы можем захватить настраиваемый набор peg счетчиков во время выполнения.
				Эти данные можно передать во внешнюю программу для мониторинга активности Snort, не прерывая ее работу.

				Модуль profiler позволяет отслеживать время и использование пространства модулями и правилами.
				Эта информация ценна для оптимизации производительности системы.
				Выходные данные модуля profiler отображаются в разделе «Summary Statistics» во время выключения.

			
			Для просмотра вывода нужного нам модуля можно использовать следующю комнаду

				<user_name>@<host_name>$ sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq -r /folder/where/you/keep/your/pcap_files/<file_name>.pcap -A <module_name>

			Та же команда, но с использованием файлов .rules, которые могут быть не «включены» в snort.lua, выглядит следующим образом.

				<user_name>@<host_name>$ sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq -r /folder/where/you/keep/your/pcap_files/<file_name>.pcap -R /folder/where/you/keep/your/local.rules -A <module_name>

	+++++++++++++++
	+ Snort Rules +
	+++++++++++++++

	*** NEVER REPLACE your configured Snort configuration files
    	You MUST EDIT your configuration files manually or update your rules with additional tools and modules to not face any fail/crash or lack of feature.

	Правила Snort, которые напоминают правила Suricata, состоят из заголовка правила и параметров правила.
	Используемые правила будут генерировать оповещения только в указанном направлении активности выбранного фильтра.
	К примеру:

   		alert icmp any any <> any any  (msg: "ICMP Packet Found"; sid: 100001; rev:1;)

	Несмотря на то, что правила Snort имеют сходство с правилами Suricata, мы настоятельно рекомендуем изучить написание правил Snort из следующих ресурсов: 

		-	https://docs.snort.org/
		-	https://docs.suricata.io/en/latest/rules/differences-from-snort.html.
	
	Самые последние правила Snort можно получить на веб-сайте Snort или веб-сайте Emerging Threats	-	https://community.emergingthreats.net/

	Подобные правила прописаны в кофигурационном файле, который по-умолчанию храниться в /etc/snort/snort.conf
	Поэтому, перед запуском SNORT необхоимо активировать тот, конфигурационный файл, который содержит список необходимых правил
	*** Если данного файла нет, то его НЕОБХОДИМО там завести

	Тем не менее, можно запустить Snort только с правилами без файла конфигурации.
	Запуск Snort в этом режиме поможет вам протестировать созданные пользователем правила.
	Однако этот режим обеспечит меньшую производительность.

    	<user_name>@<host_name>$ sudo snort -c /folder/where/you/keep/your/rules/local.rules -A consol


	В развертываниях Snort у нас есть гибкость в управлении правилами.
	Можно размещать правила (например, local.rules, находящиеся в /folder/where/you/keep/your/rules/local.rules) непосредственно в файле конфигурации snort.lua с помощью модуля ips следующим образом

		<user_name>@<host_name>$ sudo nano /root/snorty/etc/snort/snort.lua

			---SNIP---
			ips =
			{
				-- use this to enable decoder and inspector alerts
				--enable_builtin_rules = true,

				-- use include for rules files; be sure to set your path
				-- note that rules files can include other rules files
				-- (see also related path vars at the top of snort_defaults.lua)

				{ variables = default_variables, include = '/home/<user_name>/local.rules' }
			}
			---SNIP---

	После чего «included» правила будут автоматически загружены.

	Однако существует и альтернативный подход к включению правил непосредственно из командной строки.
	Мы можем передать либо один файл правил, либо путь к каталогу, содержащему файлы правил, непосредственно в Snort.
	Это можно сделать с помощью двух вариантов:

		1)	Для одного файла правил мы можем использовать параметр -R, за которым следует путь к файлу правил.
			Это позволяет нам указать конкретный файл правил, который будет использоваться Snort.

		2)	Чтобы включить весь каталог файлов правил, мы можем использовать параметр --rule-path, за которым следует путь к каталогу правил.
			Это позволяет нам предоставить Snort каталог, содержащий несколько файлов правил.


		//////////////////////
		/// Rule Structure ///
		//////////////////////

		Snort по умолчанию находится в пассивном режиме.
		Поэтому большую часть времени вы будете использовать Snort в качестве IDS.
		Чтобы включить режим IPS Вам нужно будет запустить "inline mode"
		Но прежде чем вы начнете играть с встроенным режимом, вы должны ознакомиться с функциями и правилами Snort.

		Структура правил Snort проста для понимания, но сложна в создании.
		Вы должны быть знакомы с параметрами правил и связанными с ними подробностями, чтобы создавать эффективные правила.
		Рекомендуется практиковать правила Snort и детали опций для разных вариантов использования.

		Правила не могут быть обработаны без заголовка.
		Параметры правил являются «необязательными» частями.
		Однако обнаружить сложные атаки без использования параметров правил практически невозможно.

		Мы рассмотрим базовую структуру правил.
		Но Вы всегда можете улучшить свои навыки создания правил с различными параметрами правил, практикуя различные варианты использования и подробно изучая детали опций правил.
		Каждое правило имеет следующуие параметры:

   			 тип действия    |    протокол   |   исходный IP & Port# |   Направления     |      целевой IP & Port#       |     опции
      			(action)     |   (protocol)  |   (source IP & Port#) |   (direction)     |   (destination IP & Port#)    |   (options)

		Примеры:

        		alert              tcp                                                                                              msg
        		drop               udp               ANY & ANY               <>                      ANY & ANY                reference
        		reject             icmp                                                                                             sid
        		log                ip                                                                                               rev


    		++++++++++
    		+ action +
    		++++++++++

			Для правил предусмотрено несколько действий. 
			Убедитесь, что вы понимаете функционал и протестируйте его перед созданием правил для работающих систем.
			Наиболее распространенные действия перечислены ниже.

    			-  	alert:
        			Используется для создания оповещения и логирования пакета.

    			-   log
        			Только для логирования пакет.
    
    			-   drop
        			Позволяет заблокировать и логировать пакет.

    			-   reject
        			Позволяет заблокировать пакет, залогировать его и завершить сеанс пакета.

    		++++++++++++
    		+ protocol +
    		++++++++++++

			Параметр протокола определяет тип протокола, который отфильтровывался для правила.
			К сожалению, Snort2 поддерживает только четыре фильтра протоколов в правилах (IP, TCP, UDP и ICMP).
			Однако вы можете обнаружить потоки приложений, используя номера портов и параметры.
			Например, если вы хотите обнаружить трафик FTP, вы не можете использовать ключевое слово FTP в поле протокола, а отфильтровываете трафик FTP, исследуя трафик TCP на порту 21.

    		++++++++++++++++++++++
    		+ IP & Port# Numbers +
    		++++++++++++++++++++++

			Эти параметры определяют sourcs and destination IP-адреса и соответствующие номера портов, отфильтрованные для правила.

    			IP Filtering                    -   alert icmp 192.168.1.56 any <> any any (msg: "ICMP Packet From "; sid: 100001; rev:1;)
                                        			Это правило создаст оповещение для каждого пакета ICMP, исходящего с IP-адреса 192.168.1.56.

    			Filter an IP range              -   alert icmp 192.168.1.0/24 any <> any any (msg: "ICMP Packet Found"; sid: 100001; rev:1;)
                                        			Это правило создаст оповещение для каждого пакета ICMP, исходящего из подсети 192.168.1.0/24.

    			Filter multiple IP ranges       -   alert icmp [192.168.1.0/24, 10.1.1.0/24] any <> any any (msg: "ICMP Packet Found"; sid: 100001; rev:1;)
                                        			Это правило создаст оповещение для каждого пакета ICMP, исходящего из подсетей 192.168.1.0/24 и 10.1.1.0/24.

    			Exclude IP addresses/ranges     -   alert icmp !192.168.1.0/24 any <> any any (msg: "ICMP Packet Found"; sid: 100001; rev:1;)
                                        			Это правило создаст оповещение для каждого пакета ICMP, исходящего не из подсети 192.168.1.0/24.
                                        			*** "оператор отрицания (!)" используется для исключения определенных адресов и портов. 
                                        
    			Port Filtering                  -   alert tcp any any <> any 21 (msg: "FTP Port 21 Command Activity Detected"; sid: 100001; rev:1;)
                                        			Это правило создаст оповещение для каждого пакета TCP, отправленного на порт 21.

    			Exclude a specific port         -   alert tcp any any <> any !21 (msg: "Traffic Activity Without FTP Port 21 Command Channel"; sid: 100001; rev:1;)
                                        			Это правило создаст оповещение для каждого пакета TCP, не отправленного на порт 21.

    			Filter a port range (Type 1)    -   alert tcp any any <> any 1:1024 (msg: "TCP 1-1024 System Port Activity"; sid: 100001; rev:1;)
                                        			Это правило создаст оповещение для каждого пакета TCP, отправленного на порты между 1-1024.

    			Filter a port range (Type 2)    -   alert tcp any any <> any :1024 (msg: "TCP 0-1024 System Port Activity"; sid: 100001; rev:1;)
                                        			Это правило создаст оповещение для каждого пакета TCP, отправленного на порты, меньшие или равные 1024.

    			Filter a port range (Type 3)    -   alert tcp any any <> any 1025: (msg: "TCP Non-System Port Activity"; sid: 100001; rev:1;)
                                        			Это правило создаст оповещение для каждого пакета TCP, отправленного на исходный порт, больший или равный 1025.

    			Filter a port range (Type 4)    -   alert tcp any any <> any [21,23] (msg: "FTP and Telnet Port 21-23 Activity Detected"; sid: 100001; rev:1;)
                                        			Это правило создаст оповещение для каждого TCP-пакета, отправленного на порты 21 и 23.

    		+++++++++++++
    		+ Direction +
    		+++++++++++++

			Оператор направления указывает поток трафика, который будет фильтроваться Snort.
			Левая часть правила показывает источник, а правая часть — пункт назначения.

    			->      Поток от источника к пункту назначения.
    			<>      Двунаправленный поток

			*** Обратите внимание, что в Snort нет оператора «<-»..

    		++++++++++++
    		+ Opntions +
    		++++++++++++

			В Snort есть три основных критерия для правил:

    			1) 	General Rule Options
				Основные параметры правил для Snort.

        			Параметры:
        
            			Msg			-   "Поле сообщения" это базовый запрос и быстрый идентификатор правила.
                        				После срабатывания правила сообщение появится в консоли или журнале. Обычно часть сообщения представляет собой однострочный текст, который резюмирует событие.

            			Sid     	-   "Идентификаторы правил Snort" (SID) имеют предопределенную область действия, и каждое правило должно иметь SID в правильном формате.
                        				Ниже показаны три различных области действия для SID.

                            				<100:           зарезервированные правила
                            				100-999,999:	правила поставляются со сборкой.
                            				>=1,000,000:    правила, созданные пользователем.

                        				Еще один важный момент  -   SID не должны перекрываться, и каждый id должен быть уникальным.

        				Reference   -   Каждое правило может иметь дополнительную информацию или ссылку для объяснения цели правила или шаблона угрозы.
                        				Это может быть идентификатор Common Vulnerabilities and Exposures (CVE) или внешняя информация.
                        				Наличие ссылок на правила всегда поможет аналитикам во время оповещения и расследования инцидента.

        				Rev         -   Правила Snort можно изменять и обновлять для решения проблем производительности и эффективности.
                        				Параметр Rev помогает аналитикам иметь информацию о ревизии каждого правила.
                        				Поэтому будет легко понять улучшения правил.
                        				Каждое правило имеет свой уникальный номер ревизии, и в истории правил нет функции автоматического резервного копирования.
                        				Аналитики должны сами хранить историю правил.
                        				Параметр Rev — это только индикатор того, сколько раз правило имело ревизии.

                            				alert icmp any any <> any any (msg: "ICMP Packet Found"; sid: 100001; reference:cve,CVE-XXXX; rev:1;)

    			2)  Payload Rule Options
					Параметры правил, которые помогают исследовать данные полезной нагрузки.
                    Эти параметры полезны для обнаружения определенных шаблонов полезной нагрузки.
        
        				Параметры:

            				Content			-	Данные полезной нагрузки.
                                				Сопоставляются с определенными данными полезной нагрузки по ASCII, HEX или обоим.
                                				Эту опцию можно использовать несколько раз в одном правиле.
                                				Однако чем больше вы создаете определенных функций сопоставления с шаблоном, тем больше времени требуется для исследования пакета.

                                				Следующие правила создадут оповещение для каждого HTTP-пакета, содержащего ключевое слово «GET».
                                				****	Эта опция правила ЧУВСТВИТЕЛЬНА к регистру!

                                    				ASCII mode  -   alert tcp any any <> any 80 (msg: «GET Request Found»; content:«GET»; sid: 100001; rev:1;)
                                    				HEX mode    -   alert tcp any any <> any 80 (msg: «GET Request Found»; content:«|47 45 54|»; sid: 100001; rev:1;)

            				Nocase          -   Отключение чувствительности к регистру.
                                				Используется для улучшения поиска контента.
                        
                                    				alert tcp any any <> any 80 (msg: "GET Request Found"; content:"GET"; nocase; sid: 100001; rev:1;)

            				Fast_pattern    -   Установите приоритет поиска контента для ускорения операции поиска полезной нагрузки.
                                				По умолчанию Snort использует самый большой контент и оценивает его по правилам.
                                				Параметр "fast_pattern" помогает выбрать начальное соответствие пакета с определенным значением для дальнейшего исследования.
                                				Этот параметр всегда работает без учета регистра и может использоваться один раз для каждого правила.
                                				Обратите внимание, что этот параметр обязателен при использовании нескольких параметров "content".

                                				Следующее правило имеет два параметра контента, а параметр fast_pattern указывает snort использовать первый параметр контента (в данном случае "GET") для начального соответствия пакета.

                                    				alert tcp any any <> any 80 (msg: "GET Request Found"; content:"GET"; fast_pattern; content:"www"; sid:100001; rev:1;)

    				3)  Non-Payload Rule Options
						Параметры правил, которые фокусируются на данных, не относящихся к полезной нагрузке.
               			Эти параметры помогут создать определенные шаблоны и выявить проблемы в сети.
        
        				Параметры:

            				ID		-	Фильтрация поля IP id.

                            				alert tcp any any <> any any (msg: "ID TEST"; id:123456; sid: 100001; rev:1;)

            				Flags   -   Фильтрация флагов TCP.

                            				F - FIN
                            				S - SYN
                            				R - RST
                            				P - PSH
                            				A - ACK
                            				U - URG

                            				alert tcp any any <> any any (msg: "FLAG TEST"; flags:S; sid: 100001; rev:1;)

            				Dsize   -   Фильтрация размера полезной нагрузки пакета.

                            				dsize:min<>max;
                            				dsize:>100
                            				dsize:<100
                            
                            				alert ip any any <> any any (msg: "SEQ TEST"; dsize:100<>300; sid: 100001; rev:1;)

            				Sameip  -   Фильтрация исходных и целевых IP-адресов для дублирования.

                            				alert ip any any <> any any (msg: "SAME-IP TEST"; sameip; sid: 100001; rev:1;)

		***	Помните, что после создания правила оно становится локальным и должно быть в вашем файле "local.rules".
    		Этот файл находится в "/etc/snort/rules/local.rules".
    		Ниже приведено краткое напоминание о том, как редактировать локальные правила.

		*** Обратите внимание, что есть некоторые правила по умолчанию, активированные с экземпляром snort.
    		Эти правила деактивируются для управления вашими правилами и улучшения вашего опыта упражнений.
    		Для получения дополнительной информации обратитесь к руководству TASK-10 или Snort.

		/////////////////////////////////////////////////////////////////////////
		/// Snort Rule Development Example - Detecting Ursnif (Inefficiently) ///
		/////////////////////////////////////////////////////////////////////////
		
		Данное правило Snort предназначено для обнаружения определенных разновидностей вредоносного ПО Ursnif.
		Правило неэффективно, поскольку оно пропускает HTTP-sticky buffers.

		Ursnif	-	это банковский троян (также известный как Dreambot, Gozi и ISFB), который обычно собирает системную активность, записывает данные о нажатиях клавиш и отслеживает активность сети и интернет-браузера.
		Обычно он архивирует эти конфиденциальные данные и отправляет их обратно на сервер управления и контроля, которым управляют киберпреступники.
		
		Подробно об Ursnif можно почитать тут	-	https://www.fortinet.com/blog/threat-research/ursnif-variant-spreading-word-document
													https://www.vmray.com/glossary/ursnif/
													https://nordvpn.com/cybersecurity/threat-center/ursnif/
		
		Давайте разберем важные части этого правила, чтобы понять его работу.

			alert tcp any any -> any any 
				(msg:"Possible Ursnif C2 Activity"; 
					flow:established,to_server; 
					content:"/images/", depth 12; 
					content:"_2F"; content:"_2B"; 
					content:"User-Agent|3a 20|Mozilla/4.0 (compatible|3b| MSIE 8.0|3b| Windows NT"; 
					content:!"Accept"; content:!"Cookie|3a|"; content:!"Referer|3a|"; 
				sid:1000002; rev:1;)

				-	flow: Established, to_server;
					Гарантирует, что это правило соответствует только установленным TCP-соединениям, где данные передаются от клиента к серверу.
			
				-	content: "/images/", глубина 12;
					Указывает Snort искать строку /images/ в первых 12 байтах полезной нагрузки пакета.

				-	content: "_2F"; и content: "_2B";
					Указывают Snort искать строки _2F и _2B в любом месте полезной нагрузки.

				-	content:"User-Agent|3a 20|Mozilla/4.0 (compatible|3b| MSIE 8.0|3b| Windows NT";
					Ищет определенный User-Agent.
					|3a 20| и |3b| в правиле являются шестнадцатеричными представлениями символов : и ; соответственно.

				-	content:!"Accept"; content:!"Cookie|3a|"; content:!"Referer|3a|";
					Ищит отсутствие определенных стандартных заголовков HTTP, таких как Accept, Cookie: и Referer:. ! обозначает отрицание.

		Команда для использоавния данного правила следующая (при условия что мы используем DAQ)

			<user_name>@<host_name>$ sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq -R /folder/where/you/keep/your/local.rules -r /folder/where/you/keep/pcap_files/<file_name>.pcap -A cmg

		/////////////////////////////////////////////////////////
		/// Snort Rule Development Example - Detecting Cerber ///
		/////////////////////////////////////////////////////////

		Данное правило Snort разработано для обнаружения определенных вариаций вредоносного ПО Cerber.
		
		Cerber	-	это программа вымогатель, которая была обнаружена в марте 2016
		Как программа-вымогатель как услуга (RaaS), она может быть развернута нетехническими злоумышленниками.
		Она шифрует файлы с помощью криптографически безопасных шифров

		Более подробно про Cerber можно почитать тут	-	https://blog.checkpoint.com/research/14959/
															https://www.proofpoint.com/us/threat-reference/cerber-ransomware
															https://www.fortinet.com/blog/threat-research/the-first-major-update-of-cerber-4-ransomware-has-surfaced									
		
		Давайте разберем важные части этого правила, чтобы понять его работу.
	
			alert udp $HOME_NET any -> $EXTERNAL_NET any 
				(msg:"Possible Cerber Check-in"; 
					dsize:9; content:"hi", depth 2, fast_pattern; 
					pcre:"/^[af0-9]{7}$/R"; 
					detection_filter:track by_src, count 1, seconds 60; 
				sid:2816763; rev:4;)

				-	udp $HOME_NET any -> $EXTERNAL_NET any
					Означает, что правило применяется к любому трафику UDP, идущему с любого порта в домашней сети на любой порт во внешних сетях.

				-	dsize:9;
					Это условие ограничивает правило датаграммами UDP, размер данных которых составляет ровно 9 байт.

				-	content:"hi", depth 2, fast_pattern;
					Это проверяет первые 2 байта полезной нагрузки на наличие строки hi.
					Модификатор fast_pattern заставляет сопоставитель шаблонов искать этот шаблон перед любыми другими в правиле, оптимизируя производительность правила.

				-	pcre:"/^[af0-9]{7}$/R";
					Это правило ищет семь шестнадцатеричных символов (из набора a-f и 0-9), начиная с начала полезной нагрузки (после hi), и это должна быть полная полезная нагрузка (обозначенная конечным якорем $).

				-	detection_filter:track by_src, count 1, seconds 60;
					Ключевое слово detection_filter в языке правил Snort используется для подавления оповещений, если только определенный порог совпавших событий не происходит в течение указанного периода времени.
					В этом правиле фильтр настроен на отслеживание по исходному IP (by_src) со счетчиком 1 и в течение периода времени 60 секунд.
					Это означает, что правило вызовет оповещение только в том случае, если оно соответствует более чем одному событию (в частности, более чем count событий, что здесь равно 1) с одного и того же исходного IP-адреса в течение 60 секунд.

		Команда для использоавния данного правила следующая (при условия что мы используем DAQ)

			<user_name>@<host_name>$ sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq -R /folder/where/you/keep/your/local.rules -r /folder/where/you/keep/pcap_files/<file_name>.pcap -A cmg

		////////////////////////////////////////////////////////////
		/// Snort Rule Development Example - Detecting Patchwork ///
		////////////////////////////////////////////////////////////

		Это правило Snort разработано для обнаружения определенных разновидностей вредоносного ПО, используемого Patchwork APT.
		Обратите внимание на использование HTTP sticky buffers в этом правиле.

		Patchwork APT	-	это группа кибершпионажа, которая впервые была замечена в декабре 2015 года.
		Хотя группа не была окончательно атрибутирована, косвенные доказательства указывают на то, что группа может быть проиндийской или индийской организацией.
		Patchwork была замечена в атаках на отрасли, связанные с дипломатическими и государственными учреждениями.
		Большая часть кода, используемого этой группой, была скопирована и вставлена ​​с онлайн-форумов.
		Patchwork также была замечена в проведении кампаний целевого фишинга, нацеленных на группы аналитических центров США в марте и апреле 2018 года.

		Более подробно узнать про atchwork APT можно тут	-	https://attack.mitre.org/groups/G0040/
																https://cyble.com/blog/nexe-backdoor-unleashed-patchwork-apt-groups-sophisticated-evasion-of-defenses/
																https://paper.seebug.org/papers/APT/APT_CyberCriminal_Campagin/2016/2016.07.07.UNVEILING_PATCHWORK/Unveiling-Patchwork.pdf
										
		Давайте разберем важные части этого правила, чтобы понять его работу.

			alert http $HOME_NET any -> $EXTERNAL_NET any 
				(msg:"OISF TROJAN Targeted AutoIt FileStealer/Downloader CnC Beacon"; 
					flow:established,to_server; 
					http_method; content:"POST"; 
					http_uri; content:".php?profile="; 
					http_client_body; content:"ddager=", depth 7; 
					http_client_body; content:"&r1=", distance 0; 
					http_header; content:!"Accept"; http_header; content:!"Referer|3a|"; 
				sid:10000006; rev:1;)

				-	flow: Established,to_server;
					В этом случае мы рассматриваем установленные соединения, где трафик идет от клиента к серверу.

				-	http_method; content:"POST";
					Мы ищем HTTP-трафик, где используется метод POST.

				-	http_uri; content:".php?profile=";
					Это указывает, что мы ищем HTTP URI, содержащие строку .php?profile=

				-	http_client_body; content:"ddager=", depth 7;
					Мы проверяем тело HTTP-запроса.
					В частности, мы ищем строку ddager= в первых 7 байтах тела.

				-	http_client_body; content:"&r1=", distance 0;
					Мы все еще проверяем тело HTTP-запроса, но теперь мы ищем строку &r1= сразу после предыдущего совпадения содержимого.

				-	http_header; content:!"Accept"; http_header; content:!"Referer|3a|";
					Эти условия ищут отсутствие HTTP-заголовков Accept и Referer.
					Знак ! перед содержимым означает «нет», поэтому мы ищем ситуации, в которых эти заголовки отсутствуют

		Команда для использоавния данного правила следующая (при условия что мы используем DAQ)

			<user_name>@<host_name>$ sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq -R /folder/where/you/keep/your/local.rules -r /folder/where/you/keep/pcap_files/<file_name>.pcap -A cmg
		
		///////////////////////////////////////////////////////////////////
		/// Snort Rule Development Example -  Detecting Patchwork (SSL) ///
		///////////////////////////////////////////////////////////////////

		Данное правило Snort разработано для обнаружения определенных вариаций вредоносного ПО, используемого Patchwork APT.
		
		Давайте разберем важные части этого правила, чтобы понять его работу.
		
			alert tcp $EXTERNAL_NET any -> $HOME_NET any 
				(msg:"Patchwork SSL Cert Detected"; 
					flow:established,from_server; 
					content:"|55 04 03|"; 
					content:"|08|toigetgf", distance 1, within 9; 
					classtype:trojan-activity; 
				sid:10000008; rev:1;)

				-	flow: Established,from_server;
					Эта пара ключевых слов означает, что мы заинтересованы в наблюдении за установленными потоками трафика, исходящими от сервера.

				-	content:"|55 04 03|";
					Это правило ищет определенные шестнадцатеричные значения 55 04 03 в полезной нагрузке пакета.
					Эти шестнадцатеричные значения представляют тег ASN.1 (Abstract Syntax Notation One) для поля "common name" в сертификате X.509, который часто используется в сертификатах SSL/TLS для обозначения доменного имени, к которому применяется сертификат.

				-	content:"|08|toigetgf", distance 1, within 9;
					После поля common name это правило ищет строку toigetgf.
					Расстояние 1 означает, что Snort должен начать искать строку toigetgf через 1 байт после окончания предыдущего совпадения содержимого.
					Значение within 9 устанавливает верхний предел того, насколько глубоко Snort должен искать в полезной нагрузке пакета, начиная с начала этого поля содержимого.

		Команда для использоавния данного правила следующая (при условия что мы используем DAQ)

			<user_name>@<host_name>$ sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq -R /folder/where/you/keep/your/local.rules -r /folder/where/you/keep/pcap_files/<file_name>.pcap -A cmg

		/////////////////////////////////////////////////////////////////////
		/// Snort Rule Development Example -  Detecting Overpass-the-Hash ///
		/////////////////////////////////////////////////////////////////////

		Overpass-the-Hash (Pass-the-Key) — это тип атаки, при котором злоумышленник получает несанкционированный доступ к ресурсам, используя украденный хэш NTLM (NT LAN Manager) или ключ Kerberos, без необходимости взлома пароля, из которого был получен хэш.
		Атака включает использование хеша для создания Kerberos TGT (Ticket-Granting Ticket) для аутентификации в Active Directory (AD).

		Когда злоумышленник использует Overpass-the-Hash, у него есть NTLM-хэш пароля пользователя, который используется для создания AS-REQ (Authentication Service Request) в Key Distribution Center (KDC).
		Чтобы выглядеть подлинным, AS-REQ содержит поле PRE-AUTH, которое содержит зашифрованную временную метку (Enc-Timestamp).
		Обычно это используется легитимным клиентом для подтверждения знания пароля пользователя, поскольку он зашифрован с использованием хеша пароля пользователя.
		В этом сценарии атаки хэш, используемый для шифрования временной метки, не выводится из фактического пароля, а является украденным хэшем NTLM.
		Другими словами, в этой атаке злоумышленник не использует этот хэш для шифрования Enc-Timestamp.
		Вместо этого злоумышленник напрямую использует украденный хэш NTLM для вычисления Kerberos AS-REQ, обходя обычный процесс Kerberos, который включал бы пароль пользователя и Enc-Timestamp.
		ТАким образом, злоумышленник по сути «обходит» обычный процесс аутентификации на основе пароля, отсюда и название Overpass-the-Hash.

		Одним из ключевых аспектов этого типа атаки, который мы можем использовать для обнаружения, является тип шифрования, используемый для Enc-Timestamp.
		Стандартный AS-REQ от современного клиента Windows обычно использует тип шифрования AES256-CTS-HMAC-SHA1-96 для Enc-Timestamp, но атака Overpass-the-Hash с использованием старого NTLM-хеша будет использовать тип шифрования RC4-HMAC.
		Это несоответствие можно использовать как индикатор потенциальной атаки.

		В приведенных ниже ресурсах, обсуждаются схемы работы данного Over-the-Hash метода:

			-	https://www.labofapenetrationtester.com/2017/08/week-of-evading-microsoft-ata-day2.html
			-	https://blog.3or.de/mimikatz-deep-dive-on-lsadumplsa-patch-and-inject
			-	https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/c0be3f43-bcf9-43ee-b027-3d02ab372c53?redirectedfrom=MSDN
			-	https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/50d17755-c6b8-40bd-8cac-bd6cfa31adf2?redirectedfrom=MSDN	
			-	https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/6b0dff90-5ac0-429a-93aa-150334adabf6?redirectedfrom=MSDN
	
		А также ссылки на используемые интсрументы:

			-	kuhl_m_lsadump 		(https://github.com/gentilkiwi/mimikatz/blob/master/mimikatz/modules/kuhl_m_lsadump.c#L971)
			-	kull_m_patch 		(https://github.com/gentilkiwi/mimikatz/blob/master/modules/kull_m_patch.c#L8)
			-	kull_m_remotelib	(https://github.com/gentilkiwi/mimikatz/blob/master/modules/kull_m_remotelib.c#L159)
	
		Ну и сам pcap-файл для личного пользования и практически (имя файла - wannamine.pcap)

			-	https://github.com/elcabezzonn/Pcaps

		Решение:

			Без обширных знаний HEX-конвертации и по-байтного расположения данный в пакетах Snort или Wireshark будет очень трудно найти ответ
			Благо в этом примере все было достаточно просто
			Тем не менее без ChatGPT не обошлось

			Итак....

				1)	Сперва запускаем на анлиз наш pcap-файл с имеющимся правилом (не забываем закоментировать все ненужный правила и раскоментировать нужное)

						<user_name>@<host_name>$ sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq -R /home/htb-student/local.rules -r /home/htb-student/pcaps/wannamine.pcap -v -A cmg
					
					В результате у нас должно быть отображено помимо прочей информации несколько пакетов в интрепритации Snort с разными номерами (тут показан пакет под номеров 316)
					***	Хочу сразу сказать, что искать взаимосвязь с Wireshark не стоит, так как строгого соответсвия вы не найдете (особенно среди байтовой информации)

						03/05-11:10:08.031575 [**] [1:9999999:0] "Kerberos Ticket Encryption Downgrade to RC4 Detected" [**] [Priority: 0] {TCP} 192.168.183.101:65101 -> 192.168.183.100:88
						00:0C:29:0F:26:E1 -> 00:0C:29:54:64:A9 type:0x800 len:0x172
						192.168.183.101:65101 -> 192.168.183.100:88 TCP TTL:128 TOS:0x0 ID:11253 IpLen:20 DgmLen:356 DF
						***AP*** Seq: 0xB7231400  Ack: 0xA9B75DD1  Win: 0x100  TcpLen: 20

						snort.raw[316]:
						- - - - - - - - - - - -  - - - - - - - - - - - -  - - - - - - - - -
						00 00 01 38 6A 82 01 34  30 82 01 30 A1 03 02 01  ...8j..4 0..0....
						05 A2 03 02 01 0A A3 63  30 61 30 4C A1 03 02 01  .......c 0a0L....
						02 A2 45 04 43 30 41 A0  03 02 01 12 A2 3A 04 38  ..E.C0A. .....:.8
						C9 39 CE CC EF 3C D0 57  9D C5 20 1E 54 78 7F EA  .9...<.W .. .Tx..
						F5 81 A5 B4 22 F0 39 B7  C0 CD 3F 8B 12 AA F5 34  ....".9. ..?....4
						5A C5 6E 37 68 6A 43 C1  C0 BB 27 58 75 D8 5A 85  Z.n7hjC. ..'Xu.Z.
						E4 BC D8 11 3C 67 0A 21  30 11 A1 04 02 02 00 80  ....<g.! 0.......
						A2 09 04 07 30 05 A0 03  01 01 FF A4 81 BE 30 81  ....0... ......0.
						BB A0 07 03 05 00 40 81  00 10 A1 17 30 15 A0 03  ......@. ....0...
						02 01 01 A1 0E 30 0C 1B  0A 61 63 63 6F 75 6E 74  .....0.. .account
						61 6E 74 A2 0F 1B 0D 4E  45 47 41 54 49 56 45 2E  ant....N EGATIVE.
						54 45 43 48 A3 22 30 20  A0 03 02 01 02 A1 19 30  TECH."0  .......0
						17 1B 06 6B 72 62 74 67  74 1B 0D 4E 45 47 41 54  ...krbtg t..NEGAT
						49 56 45 2E 54 45 43 48  A5 11 18 0F 32 30 33 37  IVE.TECH ....2037
						30 39 31 33 30 32 34 38  30 35 5A A6 11 18 0F 32  09130248 05Z....2
						30 33 37 30 39 31 33 30  32 34 38 30 35 5A A7 06  03709130 24805Z..
						02 04 38 F8 4E B7 A8 15  30 13 02 01 12 02 01 11  ..8.N... 0.......
						02 01 17 02 01 18 02 02  FF 79 02 01 03 A9 1D 30  ........ .y.....0
						1B 30 19 A0 03 02 01 14  A1 12 04 10 41 43 43 20  .0...... ....ACC 
						20 20 20 20 20 20 20 20  20 20 20 20                           
						- - - - - - - - - - - -  - - - - - - - - - - - -  - - - - - - - - -
				
				2)	Чтобы удалить ненужный мусор нам надо отредактировать правило
					Для этого мы удаляем XX из content: "|A0 03 02 01 XX| в правиле
					И запускаем еще раз
					У нас будут отабражены только 3 разных номера пакектов - 305, 315 и 316
				
				3)	Если Вы не размираетесь в байтном расположение, тогда спросите ChatGPT или погуглите (будет полезно для общего ознакомления)
					Скажу наперед - каждые 2 символа = 1 байту
					Таким опразом первой правило	-	content: "|A1 03 02 01 05 A2 03 02 01 0A|", offset 12, depth 10; гласит

						Это первый байтовый паттерн для поиска в пакете. Он ищет конкретный набор байтов начиная с 12-го байта пакета (offset 12) и продолжает искать в пределах 10 байтов (depth 10).
					
					Получается, что это правило начинает анализировать с байта А1 (12й по счету, при этом считаем в строку обе колонки сразу, а не сперва левую колонку, а затем правую)

				4)	Следующее правило	-	content: "|A1 03 02 01 02|", distance 5, within 6; гласит

						Это второй байтовый паттерн для поиска, с учетом дополнительных ограничений:
							distance 5: искомая строка должна быть на расстоянии 5 байтов от предыдущего паттерна.
							within 6: искомая строка должна находиться в пределах 6 байтов от предыдущего паттерна.
					
					Тут анализ начианется не сразу после кончания первого условия, а только спустя 5 байтов после его последнего байта
				
				5)	Последнее правило	-	content: "|A0 03 02 01|", distance 6, within 6; гласит

						Это третий паттерн для поиска в пакете, аналогично предыдущему с условиями:
							distance 6: паттерн должен быть через 6 байтов от предыдущего.
							within 6: паттерн должен находиться в пределах 6 байтов от предыдущего.
				
					Тут аналогично с предыдущем правилом, однако это наше последнее по-байтовое правило
					Таким образом нам нужно среди найденных пакетов найти тот пакет, который удоблетворяет по-байтовым правилам
					И как только мы найдем поледний совпадающий байт, то ответом для данного задания будет следующий байт