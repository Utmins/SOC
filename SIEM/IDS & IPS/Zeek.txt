Zeek (ранее Bro) — это коммерческий инструмент с открытым исходным кодом для мониторинга сети (анализатор трафика).
Обычно он используется для тщательного изучения каждого бита трафика в сети, глубокого поиска любых признаков подозрительной или вредоносной активности.
Но Zeek не ограничивается только этим.
Он также может быть удобным инструментом для устранения неполадок в сети и проведения различных измерений в сети.

После развертывания Zeek команда по защите от киберугроз может немедленно получить доступ к множеству файлов журналов, которые предлагают расширенный обзор всех типов сетевой активности.
В частности, эти журналы содержат подробные записи каждого соединения, выполненного по сети, а также расшифровки действий на уровне приложений, таких как запросы и ответы DNS, сеансы HTTP и многое другое.
Но возможности Zeek выходят за рамки простого ведения журнала.
Он поставляется в комплекте с набором функций для анализа и обнаружения сетевой активности.

Что отличает Zeek, так это его высокоэффективный язык сценариев, который позволяет пользователям создавать сценарии Zeek, функционально похожие на правила Suricata.
Эта мощная функция позволяет Zeek быть полностью настраиваемым и расширяемым, позволяя разрабатывать собственную логику и стратегии для анализа сети и обнаружения вторжений.
В настоящее время Zeek предоставляет более 50 журналов в 7 категориях.

Zeek работает в следующих режимах:

	-	Полностью пассивный анализ трафика
	-	Интерфейс libpcap для захвата пакетов
	-	Анализ в реальном времени и офлайн (например, на основе PCAP)
	-	Поддержка кластера для крупномасштабных развертываний

Ключевые функции, которые повышают эффективность Zeek, включают:

	-	Комплексное ведение журнала сетевых действий
	-	Анализ протоколов прикладного уровня (независимо от порта, включая такие протоколы, как HTTP, DNS, FTP, SMTP, SSH, SSL и т. д.)
	-	Возможность проверки содержимого файлов, передаваемых по протоколам прикладного уровня
	-	Поддержка IPv6
	-	Обнаружение и анализ туннелей
	-	Возможность проводить проверки работоспособности во время анализа протоколов
	-	Сопоставление шаблонов, подобное IDS
	-	Мощный, доменно-ориентированный язык сценариев, позволяющий выражать произвольные задачи анализа и управлять состоянием сети с течением времени
	-	Интерфейсинг, который по умолчанию выводит хорошо структурированные журналы ASCII и предлагает альтернативные бэкэнды для ElasticSearch и DataSeries
	-	Интеграция внешнего ввода в анализ в реальном времени
	-	Внешняя библиотека C для совместного использования событий Zeek с внешними программами
	-	Возможность запуска произвольных внешних процессов из языка сценариев

Для быстрого стартового руководства по Zeek перейдите по следующей ссылке	-	https://docs.zeek.org/en/stable/quickstart/index.html

=====================================================================
* General Terms *
*****************

	++++++++++++++++++++
	+ Архитектура Zeek +
	++++++++++++++++++++
	
	Архитектура Zeek состоит из двух основных компонентов: 

    	-  	«Event Engine» (or core)
        	Уровень Event Engine — это то, где обрабатываются пакеты
        	Он также называется ядром событий и отвечает за описание события без фокусировки на деталях события.
        	Здесь пакеты делятся на части, такие как исходные и конечные адреса, идентификация протокола, анализ сеанса и извлечение файла.

		Механизм событий принимает входящий поток пакетов и преобразует его в ряд высокоуровневых событий.
		В контексте Zeek эти события описывают сетевую активность в терминах, нейтральных по отношению к политике, то есть они информируют нас о том, что происходит, но не предлагают интерпретацию или оценку этого.
		Например, HTTP-запрос будет преобразован в событие http_request.
		Хотя это событие предоставляет все детали запроса, оно не предлагает никаких суждений или анализов
		Например, соответствует ли порт порту, который, как известно, используется вредоносным ПО.

		События, генерируемые ядром Zeek, выстраиваются в очередь в порядке очереди, ожидая своей очереди на обработку по принципу «первым пришел, первым обслужен».
		Большинство событий Zeek определены в файлах .bif, расположенных в каталоге /scripts/base/bif/plugins/.
		
		Для более полного списка событий обратитесь к следующему ресурсу	-	https://docs.zeek.org/en/stable/scripts/base/bif/

    	-	«Policy Script Interpreter».
        	Уровень Policy Script Interpreter — это то, где проводится семантический анализ.
        	Он отвечает за описание корреляций событий с помощью сценариев Zeek.

		Такая интерпретация или анализ предоставляются интерпретатором скриптов Zeek, который выполняет набор обработчиков событий, написанных на языке скриптов Zeek (скрипты Zeek).
		Эти скрипты выражают политику безопасности, определяя действия, которые необходимо предпринять при обнаружении определенных событий.		

	+++++++++++++++++++
	+ Zeek Frameworks +
	+++++++++++++++++++

	Zeek имеет несколько фреймворков для предоставления расширенных функций на уровне сценариев.
	Эти фреймворки повышают гибкость Zeek и совместимость с другими сетевыми компонентами.
	Каждый фреймворк фокусируется на определенном варианте использования и легко запускается с установкой Zeek. 
	Наличие ide по функциональности каждого фреймворка может помочь пользователям быстро идентифицировать интересующее событие

	Доступные фреймворки:

		-	Logging	Notice
		-	Input
		-	Configuration
		-	Intelligence
		-	Cluster
		-	Broker Communication
		-	Supervisor
		-	GeoLocation
		-	File Analysis
		-	Signature
		-	Summary
		-	NetControl
		-	Packet Analysis
		-	TLS Decryption

	Более детально о каждом фреймворке можно прочитать тут  -   https://docs.zeek.org/en/master/frameworks/index.html

	+++++++++++++++
    	+ Zeek Output +
    	+++++++++++++++

	Как упоминалось ранее, Zeek предоставляет более 50 файлов журналов в семи различных категориях
	Которые полезны в различных областях, таких как мониторинг трафика, обнаружение вторжений, поиск угроз и веб-аналитика.

	После запуска Zeek он автоматически начнет исследовать трафик или заданный файл pcap и автоматически сгенерирует журналы.
	После обработки pcap с помощью Zeek он создаст журналы в рабочем каталоге.
	Если вы запустите Zeek как службу, ваши журналы будут расположены в пути журнала по умолчанию.
	Путь журнала по умолчанию   -   /opt/zeek/logs/

	+++++++++++++
	+ ZEEK Logs +
	+++++++++++++

	Zeek генерирует файлы журналов в соответствии с данными трафика.
	У вас будут журналы для каждого соединения в сети, включая протоколы и поля уровня приложения.
	Zeek способен идентифицировать более 50 журналов и классифицировать их по семи категориям.
	
	Журналы Zeek — это хорошо структурированные и разделенные табуляцией файлы ASCII, поэтому их чтение и обработка просты, но требуют усилий.
	Вы должны быть знакомы с сетями и протоколами, чтобы сопоставлять журналы в расследовании, знать, на чем сосредоточиться, и находить конкретные доказательства.

	Каждый вывод журнала состоит из нескольких полей, и каждое поле содержит другую часть данных трафика.
	Корреляция выполняется с помощью уникального значения, называемого «UID».
	«UID» представляет собой уникальный идентификатор, назначенный каждому сеансу.

	Что касается ведения журнала Zeek, когда мы используем Zeek для автономного анализа файла PCAP, журналы будут храниться в текущем каталоге.

	Zeek logs in a nutshell:

		Category                    Description                                                                     Log Files

		Network                     Network protocol logs                                                           conn.log, dce_rpc.log, dhcp.log, dnp3.log, dns.log, ftp.log, http.log, irc.log,
                	                                                                                                kerberos.log, modbus.log, modbus_register_change.log, mysql.log, ntlm.log, ntp.log,
                        	                                                                                        radius.log, rdp.log, rfb.log, sip.log, smb_cmd.log, smb_files.log, smb_mapping.log,
                                	                                                                                smtp.log, snmp.log, socks.log, ssh.log, ssl.log, syslog.log, tunnel.log.

		Files                       File analysis result logs                                                       files.log, ocsp.log, pe.log, x509.log.
	
		NetControl                  Network control and flow logs                                                   netcontrol.log, netcontrol_drop.log, netcontrol_shunt.log, netcontrol_catch_release.log, openflow.log.

		Detection                   Detection and possible indicator logs                                           intel.log, notice.log, notice_alarm.log, signatures.log, traceroute.log.
		
		Network Observations        Network flow logs.                                                              known_certs.log, known_hosts.log, known_modbus.log, known_services.log, software.log.

		Miscellaneous               Additional logs cover external alerts, inputs and failures          		    arnyard2.log, dpd.log, unified2.log, unknown_protocols.log, weird.log, weird_stats.log.

		Zeek Diagnostic             Zeek diagnostic logs cover system messages, actions and some statistics.        broker.log, capture_loss.log, cluster.log, config.log, loaded_scripts.log, packet_filter.log, print.log, prof.log, reporter.log, stats.log, stderr.log, stdout.log.


	За более детальной информацией следует обратиться к
		
		-	полный список общих журналов Zeek с описанием полей каждого журнала (https://docs.zeek.org/en/master/logs/index.html)
		-	официальной документации Zeek (https://docs.zeek.org/en/current/script-reference/log-files.html)
		-	шпаргалке по журналам Corelight (https://corelight.com/about-zeek/zeek-data).

	Некоторые файлы журналов обновляются ежедневно, а некоторые — в каждом сеансе.
	Следует отметить, что Zeek в своей стандартной конфигурации применяет сжатие gzip к файлам журналов каждый час.
	Затем старые журналы переносятся в каталог, названный в формате YYYY-MM-DD. При работе с этими сжатыми журналами могут пригодиться альтернативные инструменты, такие как

		-	gzcat
			для печати журналов

		-	zgrep
			для поиска в журналах.

	Вы можете найти примеры того, как работать с журналами Zeek, сжатыми gzip, по этой ссылке	-	https://blog.rapid7.com/2016/06/02/working-with-bro-logs-queries-by-example/

	Вы можете классифицировать журналы перед началом расследования.
	Таким образом, будет проще найти искомые вами доказательства/аномалии.

	Приведенная таблица является кратким примером использования нескольких файлов журналов.
	***	Вы можете создать свою рабочую модель или настроить заданную.

		Overall Info            Protocol Based      Detection           Observation
        
		conn.log                http.log            notice.log          known_host.log
		files.log               dns.log             signatures.log      known_services.log
		intel.log               ftp.log             pe.log              software.log
		loaded_scripts.log      ssh.log             traceroute.log      weird.log

		-	Overall Info:		Цель состоит в том, чтобы просмотреть все соединения, общие файлы, загруженные скрипты и индикаторы одновременно.
                        			Это первый шаг расследования.

		-	Protocol Based:		После того, как вы просмотрите весь трафик и обнаружите подозрительные индикаторы или захотите провести более глубокое расследование, вы сосредоточитесь на определенном протоколе.
    
		-	Detection:		Используйте готовые или пользовательские скрипты и результаты сигнатур для подтверждения своих выводов с помощью дополнительных индикаторов или связанных действий.
    
		-	Observation:		Сводка по хостам, службам, программному обеспечению и статистике неожиданной активности поможет вам обнаружить возможные недостающие точки и завершить расследование.

	И хотя журналы ZEEK хорошо структурированы, каждый их них содержит огромный объем информации, который очень тяжело распределить используя обычные утилиты команднеой строки Линукс (cat, cut, grep sort, and uniq)
	Поэтому утилиты Линукс чаще всего используют с утилитой Zeek, которая призвана сократить усилия по извлечению определенных столбцов из файлов журнала
	Данная утилита  -   zeek cut

	Каждый файл журнала предоставляет "имена полей" в начале.
	Эта информация поможет вам при использовании zeek-cut.
	***	Убедитесь, что вы используете "поля", а не "типы".
	Вот пример совместного использования Линукс утилит с утилитой zeek cut

		<user_name>@<host_name>$ cat <log.filename> | zeek-cut uid proto id.orig_h id.orig_p id.resp_h id.resp_p | sort -u | wc -lack

	+++++++++++++++++++
	+ ZEEK Signatures +
	+++++++++++++++++++

	Zeek поддерживает сигнатуры для правил и корреляций событий, чтобы находить заслуживающие внимания действия в сети.
	Сигнатуры Zeek используют низкоуровневое сопоставление шаблонов и охватывают условия, аналогичные правилам Snort.
	В отличие от правил Snort, правила Zeek не являются основной точкой обнаружения событий.
	Zeek имеет язык сценариев и может объединять несколько событий, чтобы найти событие, представляющее интерес.

	Подписи Zeek состоят из трех логических путей:

		1)	Signature id
        		Уникальное имя подписи.
    
    		2)	Conditions	
            		
			-	Header
                		Фильтрация заголовков пакетов по определенным адресам источника и назначения, протоколам и номерам портов.
            		
			-	Content
                		Фильтрация полезной нагрузки пакета по определенному значению/шаблону.

    		3)	Action	
            
			-	Default action
                		Создать файл «signatures.log» в случае совпадения подписи.
            		
			-	Additional action
               			Запустить скрипт Zeek.

	В таблице ниже приведены наиболее распространенные условия и фильтры для подписей Zeek.

    		Condition Field				Available Filters
    
    		Header					src-ip      (Source IP)
               		                                dst-ip      (Destination IP)
    		                                        src-port    (Source port)
                	                                dst-port    (Destination port)
                        	                        ip-proto    (Target protocol. Supported protocols; TCP, UDP, ICMP, ICMP6, IP, IP6)
    
    		Content	                                payload                 (Packet payload)
                        	                        http-request            (Decoded HTTP requests)
                                	                http-request-header     (Client-side HTTP headers)
                                        	        http-request-body       (Client-side HTTP request bodys)
                                                	http-reply-header       (Server-side HTTP headers)
	                                                http-reply-body         (Server-side HTTP request bodys)
        	                                        ftp                     (Command line input of FTP sessions)

    		Context                                 same-ip     (Filtering the source and destination addresses for duplication.)
    
    		Action   	                        event       (Signature match message)
    
		Comparison Operators                    ==, !=, <, <=, >, >=
    
    		NOTE!                                   Filters accept string, numeric and regex values

	***	Подписи Zeek используют расширение «.sig».

	Не забываем, что "подписи" Zeek поддерживают регулярные выражения (RegEx).
	Регулярное выражение ".*" соответствует любому символу ноль или более раз.
	Правило сработает, если в полезной нагрузке пакета будет обнаружена искомая фраза
	Как только совпадение произойдет, Zeek сгенерирует оповещение и создаст дополнительные файлы журнала (signatures.log и notification.log).

	Для использования "подписи", ее сперва необходимо создать

		//////////////////////////////////////////////////
		/// Example | Cleartext Submission of Password ///
		//////////////////////////////////////////////////

		Вот примерный образец "подписи", который мы можем использовать для поиска пароля в файле журнала, который (пароль) не был зашифрован, т.е. был в формате cleartext

    		signature http-password {
        		ip-proto == tcp
        		dst-port == 80
        		payload /.*password.*/
        		event "Cleartext Password Found!"
    		}

    			-	signature:
					Signature name.

				-	ip-proto
					Filtering TCP connection.

				-	dst-port
					Filtering destination port 80.

				-	payload
					Filtering the "password" phrase.

				-	event
					Signature match message.

		Теперь надо запустить Zeek с использование определенных ключей, а также указанием имени pcap-файла и sig-файла

			<user_name>@<host_name>$ zeek -C -r http.pcap -s http-password.sig

		После использования данной команды будут сгенерированы несколько лог-файло, согласно имеющейяся в pcap-файле информации и соответсвующим категортям

			<user_name>@<host_name>$ ls
				clear-logs.sh  conn.log  files.log  http-password.sig  http.log  http.pcap  notice.log  packet_filter.log  signatures.log

		Далее мы можем просмотреть, интересующие нас, лог-файлы с использованием Линус и Zeek утилит

			<user_name>@<host_name>$ cat notice.log  | zeek-cut id.orig_h id.resp_h msg

            			10.10.57.178	44.228.249.3	10.10.57.178: Cleartext Password Found!
            			10.10.57.178	44.228.249.3	10.10.57.178: Cleartext Password Found!
    
			<user_name>@<host_name>$ cat signatures.log | zeek-cut src_addr dest_addr sig_id event_msg 

            			10.10.57.178		http-password	10.10.57.178: Cleartext Password Found!
            			10.10.57.178		http-password	10.10.57.178: Cleartext Password Found!

		Как показано в выходных данных терминала выше, signatures.log и notification.log предоставляют основные сведения и сообщение подписи.
		Оба журнала также имеют поле баннера приложения.
		Таким образом, можно узнать, где происходит совпадение подписи. Давайте посмотрим на баннер приложения!

		/////////////////////////////////
    	/// Example | FTP Brute-force ///
    	/////////////////////////////////

		Давайте создадим еще одно правило для фильтрации FTP-трафика.
		На этот раз мы будем использовать фильтр содержимого FTP для исследования командных строк FTP-трафика.
		Цель состоит в том, чтобы обнаружить попытки входа "admin" на FTP.
		Эта базовая сигнатура поможет нам идентифицировать попытки входа администратора и получить представление о возможных злоупотреблениях учетной записью администратора или событиях компрометации.

    		signature ftp-admin {
        		ip-proto == tcp
    			ftp /.*USER.*dmin.*/
    			event "FTP Admin Login Attempt!"
			}

		После создания "полписи" мы можем запустить Zeek с подписью и исследуем signatures.log и notification.log

   			<user_name>@<host_name>$ zeek -C -r ftp.pcap -s ftp-admin.sig
    		<user_name>@<host_name>$ cat signatures.log | zeek-cut src_addr dst_addr event_msg sub_msg | sort -r| uniq

        		10.234.125.254	10.121.70.151	10.234.125.254: FTP Admin Login Attempt!	USER administrator
        		10.234.125.254	10.121.70.151	10.234.125.254: FTP Admin Login Attempt!	USER admin

		Наше правило показывает нам, что есть несколько попыток регистрации с именами учетных записей, содержащими фразу «admin».
		Вывод дает нам отличную информацию, что были осуществленны попытки брутфорсинга учетной записи администратора.

		Сигнатуру, указанную выше можно считать сигнатурой случая.
		Хотя она точна и отлично работает, в реальной жизни нам придется использовать более глобальные сигнатуры для обнаружения «известных угроз/аномалий», таких как атаки нулевого дня и инсайдерские атаки в реальной среде.

		Главное помнить, что нелогично созданные правила/сигнатуры могут приветси к пропуску реальной аномалии.
		Поэтому при создании сигнатур надо руководствоватсья простым правилос — логическая регистрация, а не регистрация всего.

		К примеру   -   мы можем улучшить нашу подпись, не ограничивая фокус только на учетной записи администратора.
		В этом случае нам нужно знать, как работает протокол FTP и коды ответов по умолчанию.
		Если вы не знаете этих подробностей, обратитесь к документации RFC.

    		!!!	Улучшенный вариант №1	!!!
			Создаст журналы для каждого события, содержащего «ответ FTP 530», что позволит нам отслеживать события сбоев входа независимо от имени пользователя.

        		signature ftp-brute {
            			ip-proto == tcp
        				payload /.*530.*Login.*incorrect.*/
        				event "FTP Brute-force Attempt"
    			}
    
			Файлы подписей Zeek могут состоять из нескольких подписей.
			Поэтому у нас может быть один файл для каждого протокола/ситуации/типа угрозы.

    		!!!	Улучшенный вариант №2	!!!

        		signature ftp-username {
            			ip-proto == tcp
        				ftp /.*USER.*/
        				event "FTP Username Input Found!"
    			}

        		signature ftp-brute {
            			ip-proto == tcp
        				payload /.*530.*Login.*incorrect.*/
        				event "FTP Brute-force Attempt!"
    			}

			В результате использования "Улучшенного варианта №2" мы получили Следующее

				<user_name>@<host_name>$ zeek -C -r ftp.pcap -s ftp-admin.sig
				<user_name>@<host_name>$ cat notice.log | zeek-cut uid id.orig_h id.resp_h msg sub | sort -r| nl | uniq | sed -n '1001,1004p'

        				1001	CeMYiaHA6AkfhSnd	10.234.125.254	10.121.70.151	10.234.125.254:	FTP Username Input Found!	USER admin
        				1002	CeMYiaHA6AkfhSnd	10.234.125.254	10.121.70.151	10.121.70.151:	FTP Brute-force Attempt!	530 Login incorrect.
        				1003	CeDTDZ2erDNF5w7dyf	10.234.125.254	10.121.70.151	10.234.125.254:	FTP Username Input Found!	USER administrator
        				1004	CeDTDZ2erDNF5w7dyf	10.234.125.254	10.121.70.151	10.121.70.151:	FTP Brute-force Attempt!	530 Login incorrect.

	++++++++++++++++
	+ ZEEK SCRIPTS +
	++++++++++++++++

	Zeek имеет свой собственный язык сценариев, управляемый событиями, который так же мощен, как языки высокого уровня, и позволяет нам исследовать и сопоставлять обнаруженные события.
	Поскольку он так же мощен, как языки программирования высокого уровня, вам нужно будет потратить время на язык сценариев Zeek, чтобы стать профессионалом.
	Ниже будут представленны только основы сценариев Zeek, чтобы помочь понять, изменить и создать базовые сценарии.
	***	Обратите внимание, что сценарии можно использовать для применения политики, и в этом случае они называются сценариями политики.

	Существуют 3 категории скриптов ZEEK:

    		-	BASE Scripts
        		В Zeek по умолчанию установлены базовые скрипты, и они не предназначены для изменения.
        		Расположены     -   /opt/zeek/share/zeek/base
    
    		-	USER Generated/Modified Scripts
        		Должны быть расположены     -   /opt/zeek/share/zeek/site

    		-	POLICY Scripts
        		Расположены     -   /opt/zeek/share/zeek/policy

	Как и в случае со Snort, для автоматической загрузки/использования скрипта в режиме живого сниффинга необходимо идентифицировать скрипт в файле конфигурации Zeek.
	Вы также можете использовать скрипт для одного запуска, как и сигнатуры.
	Файл конфигурации расположена   -   /opt/zeek/share/zeek/site/local.zeek

	Вот несколько ВАЖНЫХ моментов при работе с ZEEK:

    		-	Скрипты Zeek используют расширение ".zeek".
    		-   Не изменяйте ничего в каталоге "zeek/base".
    		-   Скрипты, созданные и измененные пользователем, должны находиться в каталоге "zeek/site".
    		-	Вы можете вызывать скрипты в режиме мониторинга в реальном времени, загрузив их с помощью команды load @/script/path или load @script-name в файле local.zeek.
    		-   Zeek ориентирован на события, а не на пакеты!
        	-	Нам нужно использовать/писать скрипты для обработки интересующего события.

	Скрипты содержат:
    
    		-   операторы
    		-  	типы
    		-  	атрибуты
    		-  	объявления и операторы
    		-	директивы.
	
	Пример ZEEK Script

    		event dhcp_message (c: connection, is_orig: bool, msg: DHCP::Msg, options: DHCP::Options)
    		{
    		print options$host_name;
    		}

	Если вы заинтересованы в изучении примеров Zeek, вариантов использования и изучении основ написания скриптов Zeek	-	https://docs.zeek.org/en/stable/examples/index.html

    		/////////////////////////////////////////
    		/// Scripts 101 | Write Basic Scripts ///
    		/////////////////////////////////////////


		101)    Давайте рассмотрим простой пример события под названием "zeek_init" и "zeek_done".
        		Эти события срабатывают после запуска и остановки процесса Zeek.
        		Обратите внимание, что эти события не имеют параметров, а некоторые события потребуют параметров.

            			event zeek_init()
                		{
                			print ("Started Zeek!");
                		}
            			event zeek_done()
                		{
                			print ("Stopped Zeek!");
                		}

            			-	zeek_init
					Do actions once Zeek starts its process.
            		
				-	zeek_done
					Do activities once Zeek finishes its process.
            			
				-	print
					Prompt a message on the terminal.

        		Вышеприведенный вывод показывает, как работает скрипт и предоставляет сообщения на терминале.
        		Zeek будет создавать журналы в рабочем каталоге отдельно от задач скриптов.

		102)	Давайте выведем данные пакета на терминал и посмотрим необработанные данные.
        		В этом скрипте мы запрашиваем сведения о соединении и извлекаем их без какой-либо фильтрации или сортировки данных.
        		Для этого мы используем событие "new_connection".
        		Это событие автоматически генерируется для каждого нового соединения.
        
        		Этот скрипт предоставляет объемную информацию на терминале.
        		Нам нужно ознакомиться со структурой данных Zeek, чтобы уменьшить объем информации и сосредоточиться на интересующем нас событии.
        		Для этого нам нужно исследовать объемные данные.

            			event new_connection(c: connection)
            			{
                			print c;
            			}
        
        		Скрипт #102 предоставляет объемные данные для каждого соединения.
        		Этот стиль не является лучшим использованием, и в реальной жизни нам нужно будет фильтровать информацию для определенных целей.
        		Если вы внимательно посмотрите на вывод, вы увидите идентификатор и значение поля для каждой части.
        		Поэтому мы немного доработаем данный скрипт

		103)    Чтобы отфильтровать интересующее событие, мы будем использовать первичный тег (в данном случае это c --происходит от "c: connection"--), значение идентификатора (id=) и имя поля.
       			Вы должны заметить, что поля такие же, как и поля в файлах журнала.

            			event new_connection(c: connection)
            			{
               				print ("###########################################################");
                			print ("");
                			print ("New Connection Found!");
                			print ("");
                			print fmt ("Source Host: %s # %s --->", c$id$orig_h, c$id$orig_p);
                			print fmt ("Destination Host: resp: %s # %s <---", c$id$resp_h, c$id$resp_p);
                			print ("");
            			}

            			-	%s
					Identifies string output for the source.
            
				-	c$id
					Source reference field for the identifier.
        
        		Вышеприведенный вывод показывает, что мы успешно извлекаем определенную информацию из событий.
        		Помните, что этот скрипт извлекает интересующее нас событие (в этом примере — новое соединение), и у нас все еще есть журналы в рабочем каталоге.
        		Мы всегда можем изменить и оптимизировать скрипты в любое время.
        
        		Результат использования данного скрипта будет выглядеть примерно так:

				<user_name>@<host_name>$ zeek -C -r sample.pcap 103.zeek

                		###########################################################
                		New Connection Found! Source Host: 192.168.121.2 # 58304/udp ---> 
                		Destination Host: resp: 192.168.120.22 # 53/udp <--- 
                		###########################################################

    		/////////////////////////////////////////////////////////
    		/// Scripts 201 | Use Scripts and Signatures Together ///
    		/////////////////////////////////////////////////////////

			До сих пор мы рассматривали основы скриптов Zeek.
			Теперь пришло время использовать скрипты совместно с другими скриптами и сигнатурами, чтобы приблизиться на один шаг к корреляции событий.
			Скрипты Zeek могут ссылаться на сигнатуры и другие скрипты Zeek.
			Эта гибкость обеспечивает огромное преимущество в корреляции событий.

			Давайте продемонстрируем эту концепцию на примере.
			Мы создадим скрипт, который определяет, есть ли у нашего ранее созданного правила "ftp-admin" попадание

    			event signature_match (state: signature_state, msg: string, data: string)
    			{
    				if (state$sig_id == "ftp-admin")
        			{
        				print ("Signature hit! --> #FTP-Admin ");
        			}
    			}

			Этот базовый скрипт быстро проверяет, есть ли совпадение подписи, и предоставляет вывод терминала для уведомления нас.
			Для этого мы используем событие "signature_match". 
		
			***	Подробнее о событиях можно прочитать здесь  -   https://docs.zeek.org/en/master/scripts/base/bif/event.bif.zeek.html

			Обратите внимание, что мы ищем только совпадения подписи "ftp-admin". 
			Поэтому, нам также необходимо создать файл-подпись
			Подпись показана ниже.

    			signature ftp-admin {
        			ip-proto == tcp
        			ftp /.*USER.*admin.*/
        			event "FTP Username Input Found!"
    			}

			Теперь, когда у нас есть файл-скрипт и файл-подпись, мы можем использовать их вместе при анализе pcap-файла

    			<user_name>@<host_name>$ zeek -C -r ftp.pcap -s ftp-admin.sig 201.zeek 

        			Signature hit! --> #FTP-Admin Signature hit! --> #FTP-Admin
        			Signature hit! --> #FTP-Admin Signature hit! --> #FTP-Admin

			Вышеприведенный вывод показывает, что мы успешно объединили подпись и скрипт.
			Zeek обработал подпись и журналы, затем скрипт контролировал выходные данные и предоставлял терминальный вывод для каждого попадания в правило.

    		////////////////////////////////////////
    		/// Scripts 202 | Load Local Scripts ///
    		////////////////////////////////////////

			Выше было сказано, что Zeek имеет базовые скрипты, расположенные в "/opt/zeek/share/zeek/base".
			Вы можете загрузить все локальные скрипты, указанные в вашем файле "local.zeek".
			***	Обратите внимание, что базовые скрипты охватывают множество функций фреймворка.

			Вы можете загрузить все базовые скрипты, легко выполнив команду     -   local

    			<user_name>@<host_name>$ zeek -C -r ftp.pcap local
    			<user_name>@<host_name>$ ls
        
				101.zeek  103.zeek          clear-logs.sh  ftp.pcap            packet_filter.log  stats.log
        			102.zeek  capture_loss.log  conn.log       loaded_scripts.log  sample.pcap        weird.log

			Вышеприведенный вывод демонстрирует, как запустить все базовые скрипты с помощью команды "local".
			Посмотрите на вышеприведенный вывод терминала   -   на этот раз Zeek предоставил дополнительные файлы журнала.
			Загруженные скрипты сгенерировали файлы load_scripts.log, capture_loss.log, notification.log, stats.log.
			Также обратите внимание, что в нашем случае было загружено и использовано 465 скриптов с помощью команды "local".
			Однако Zeek не предоставляет файлы журнала для скриптов, у которых нет попаданий или результатов.

			Другой способ загрузки скриптов — указание пути к интересующему нас скрипту.
			В этом случае у вас есть возможность загрузить определенный скрипт или фреймворк.

			Давайте вернемся к случаю перебора паролей FTP.
			На предыдущих этапах мы создали скрипт, который обнаруживает множественные неудачные попытки входа администратора.
			У Zeek также есть скрипт обнаружения перебора паролей FTP.
			Теперь давайте воспользуемся скриптом по умолчанию и выявим различия.

    			<user_name>@<host_name>$ zeek -C -r ftp.pcap /opt/zeek/share/zeek/policy/protocols/ftp/detect-bruteforcing.zeek 
    			<user_name>@<host_name>$ cat notice.log | zeek-cut ts note msg 

        			1024380732.223481	FTP::Bruteforcing	10.234.125.254 had 20 failed logins on 1 FTP server in 0m1s

			Этот скрипт предоставляет гораздо больше информации, чем тот, который мы создали.
			Он предоставляет один однострочный вывод и сводку соединения для подозрительного инцидента.

			***	Вы можете найти и прочитать больше о готовых скриптах и ​​фреймворках, посетив онлайн-книгу -   https://docs.zeek.org/en/master/frameworks/index.html

    		/////////////////////////////////////
    		/// Scripts 203 | Load Frameworks ///
    		/////////////////////////////////////

			Zeek имеет более 15 фреймворков, которые помогают аналитикам обнаруживать различные интересующие события.
			Больше информации о готовых скриптах и ​​фреймворках можно найти тут   -   https://docs.zeek.org/en/master/frameworks/index.html

			Ниже будут рассмотренны только несколько из них:

    			*)	File Framework | Hashes

        			Не все функции фреймворка предназначены для использования в режиме CLI.
        			Большинство из них используются в скриптах.
        			Вы можете легко увидеть использование фреймворков в скриптах, вызвав определенный фреймворк как -   load @ $PATH/base/frameworks/framework-name.
        
        			Теперь давайте используем готовую функцию файлового фреймворка и получим хэши MD5, SHA1 и SHA256 обнаруженных файлов.
        			Но сперва посмотрим, как устроен скрипт, призванный запускать, указанный в нем, фреймворк 
        
            			<user_name>@<host_name>$ cat hash-demo.zeek 

                			# Enable MD5, SHA1 and SHA256 hashing for all files.
                			@load /opt/zeek/share/zeek/policy/frameworks/files/hash-all-files.zeek
        
        			В предыдущих задачах мы упоминали, что Zeek в значительной степени полагается на скрипты, а фреймворки зависят от скриптов.
        			Давайте подробнее рассмотрим фреймворк хэша файла и увидим стоящий за ним скрипт.
        
            			<user_name>@<host_name>$ cat /opt/zeek/share/zeek/policy/frameworks/files/hash-all-files.zeek 
                
                			# Enable MD5, SHA1 and SHA256 hashing for all files.

                			@load base/files/hash
                			event file_new(f: fa_file)
                    			{
                    			Files::add_analyzer(f, Files::ANALYZER_MD5);
                    			Files::add_analyzer(f, Files::ANALYZER_SHA1);
                    			Files::add_analyzer(f, Files::ANALYZER_SHA256);
                				}
        
        			А теперь выполним скрипт и исследуем файл журнала.
        			Для этого мы вызовем скрипт фреймворка "File Analysis"  -   «hash-all-files».

            			<user_name>@<host_name>$ zeek -C -r case1.pcap hash-demo.zeek
            			<user_name>@<host_name>$ cat files.log | zeek-cut md5 sha1 sha256

                			cd5a4d3fdd5bffc16bf959ef75cf37bc	33bf88d5b82df3723d5863c7d23445e345828904	6137f8db2192e638e13610f75e73b9247c05f4706f0afd1fdb132d86de6b4012
            
            		либо

        				<user_name>@<host_name>$ zeek -C -r case1.pcap /opt/zeek/share/zeek/policy/frameworks/files/hash-all-files.zeek
        				<user_name>@<host_name>$ cat files.log | zeek-cut md5 sha1 sha256

                			cd5a4d3fdd5bffc16bf959ef75cf37bc	33bf88d5b82df3723d5863c7d23445e345828904	6137f8db2192e638e13610f75e73b9247c05f4706f0afd1fdb132d86de6b4012
        
        			Посмотрите на приведенные выше выходные данные терминала.
        			Оба скрипта дали одинаковый результат.
        			Здесь предпочтение остается за пользователем.
        
        			Готовые фреймворки обычно используются в скриптах с методом "@load".
        			Конкретные скрипты используются как практические скрипты для конкретных случаев использования.

    			*)   File Framework | Extract Files

        			Файловый фреймворк может извлекать не только логи из pcap-файла, но и различные файлы, которые передавались в исследуемом (захваченном) pcap-файле.
        			Давайте посмотрим на эту функцию в действии!
        			***	Мы также можем обратиться к фреймворку либо через наш собственный скрипт, либо напрямую
            			В данном пример обратимся напрямую
        
            			<user_name>@<host_name>$ zeek -C -r case1.pcap /opt/zeek/share/zeek/policy/frameworks/files/extract-all-files.zeek
            			<user_name>@<host_name>$ ls -l

                			-rw-r--r-- 1 ubuntu ubuntu 1344660 Jun 27  2019 case1.pcap
                			drwxr-xr-x 2 ubuntu ubuntu    4096 Oct 12 18:19 extract_files
                			-rw-r--r-- 1 ubuntu ubuntu    1179 Oct 12 18:19 files.log
                			-rw-r--r-- 1 ubuntu ubuntu    1551 Oct 12 18:19 http.log
                			-rw-r--r-- 1 ubuntu ubuntu     254 Oct 12 18:19 packet_filter.log
                			-rw-r--r-- 1 ubuntu ubuntu     564 Oct 12 18:19 pe.log
                			-rw-r--r-- 1 ubuntu ubuntu    6237 Oct 12 18:19 conn.log
                			-rw-r--r-- 1 ubuntu ubuntu     850 Oct 12 18:19 dhcp.log
                			-rw-r--r-- 1 ubuntu ubuntu   12466 Oct 12 18:19 dns.log

        			После извлечения автоматически создается новая папка с именем "extract_files", в которой находятся все обнаруженные файлы.
        			При делании мы можем определить тип извлеченных файлова с помощью команды file

            			<user_name>@<host_name>$ file * | nl
                		
							1	extract-1561667874.743959-HTTP-Fpgan59p6uvNzLFja:  ASCII text, with no line terminators
                			2	extract-1561667889.703239-HTTP-FB5o2Hcauv7vpQ8y3:  Composite Document File V2 Document, Little Endian, Os: Windows, Version 6.3, Code page: 1252, Template: Normal.dotm, Last Saved By: Administrator, Revision Number: 2, Name of Creating Application: Microsoft Office Word, Create Time/Date: Thu Jun 27 18:24:00 2019, Last Saved Time/Date: Thu Jun 27 18:24:00 2019, Number of Pages: 1, Number of Words: 0, Number of Characters: 1, Security: 0
                			3	extract-1561667899.060086-HTTP-FOghls3WpIjKpvXaEl: PE32 executable (GUI) Intel 80386, for MS Windows

        			Zeek извлек три файла.
					Команда "file" показывает нам один файл .txt, один файл .doc/.docx и один файл .exe.
        
					Zeek переименовывает извлеченные файлы.
        			Формат имени состоит из четырех значений, которые берутся из файлов conn.log и files.log
       				 Ключевое слово "extract" по умолчанию, значение временной метки (ts), протокол (source) и идентификатор соединения (conn_uids).

    			*)	Notice Framework | Intelligence

        			Интеллектуальная структура может работать с потоками данных для обработки и корреляции событий и выявления аномалий.
        			Интеллектуальной структуре требуется поток для сопоставления и создания оповещений из сетевого трафика.
        			Давайте продемонстрируем один файл разведданных об угрозах, созданный пользователем, и позволим Zeek использовать его в качестве основного источника разведданных.
        			Расположение источника разведданных: /opt/zeek/intel/zeek_intel.txt

        			***	Есть два критических момента, о которых вы никогда не должны забывать.
            				1)	Во-первых, исходный файл должен быть разделен табуляцией.
            				2)	Во-вторых, вы можете вручную обновить источник, и добавление дополнительных строк не требует повторного развертывания.
                				Однако, если вы удалите строку из файла, вам нужно будет повторно развернуть экземпляр Zeek.

        			Давайте добавим подозрительный URL-адрес, собранный из файла case1.pcap, в качестве исходной разведывательной информации и посмотрим на эту функцию в действии!
        			Перед выполнением скрипта давайте рассмотрим файл разведданных и содержимое скрипта.

            			<user_name>@<host_name>$ cat /opt/zeek/intel/zeek_intel.txt 
                
							#fields	indicator	indicator_type		meta.source	meta.desc
                			smart-fax.com		Intel::DOMAIN		zeek-intel-test	Zeek-Intelligence-Framework-Test

            			<user_name>@<host_name>$ cat intelligence-demo.zeek 
                
							# Load intelligence framework!
            				@load policy/frameworks/intel/seen
            				@load policy/frameworks/intel/do_notice
            				redef Intel::read_files += { "/opt/zeek/intel/zeek_intel.txt" };
        
        			Вышеприведенный вывод показывает содержимое файла intel и содержимое скрипта.
        			Есть один вход разведки, и он сосредоточен на доменном имени, поэтому, когда это доменное имя появляется в сетевом трафике, Zeek создаст файл "intel.log" и предоставит доступные подробности.
        			Проще говоря, файл-источник разведданных содержит критерии, по которым будет формироваться лог-файл после обработки файла-захвата
        			А скрипт говорит о том, какие фреймворки должны быть использованы, при анализе файла-захвата с учетом критериев, указанных в файле-источнике разведданных

        			Чтож, давайте проанализируем наш файл-захвата с использованием скрипта разведки, а затем просмотри содержимое соответсвующего лог-файла

            			<user_name>@<host_name>$ zeek -C -r case1.pcap intelligence-demo.zeek 
            			<user_name>@<host_name>$ cat intel.log | zeek-cut uid id.orig_h id.resp_h seen.indicator matched

                			CZ1jLe2nHENdGQX377	10.6.27.102	10.6.27.1	smart-fax.com	Intel::DOMAIN	
            				C044Ot1OxBt8qCk7f2	10.6.27.102	107.180.50.162	smart-fax.com	Intel::DOMAIN 

       				Вышеприведенный вывод показывает, что Zeek обнаружил указанный домен и создал файл intel.log.
        			Это один из самых простых способов использования фреймворка разведки.

        			Подробнее о фреймворке разведки можно прочитать	-	https://docs.zeek.org/en/master/frameworks/intel.html
            															https://docs.zeek.org/en/current/scripts/base/frameworks/intel/main.zeek.html#type-Intel::Type

    		/////////////////////////////////////
    		/// Scripts 204 | Package Manager ///
    		/////////////////////////////////////

			Менеджер пакетов Zeek помогает пользователям устанавливать сторонние скрипты и плагины для легкого расширения функциональности Zeek.
			Менеджер пакетов устанавливается вместе с Zeek и доступен с помощью команды zkg.
			Пользователи могут устанавливать, загружать, удалять, обновлять и создавать пакеты с помощью инструмента "zkg". \
			Вы можете прочитать больше и просмотреть доступные пакеты здесь и здесь.
			***	Обратите внимание, что для использования инструмента "zkg" вам потребуются права root.

			Основные команды при работе с пакетами:

    			Command                         Description

    			zkg install package_path        Install a package. Example (zkg install zeek/j-gras/zeek-af_packet-plugin).
    			zkg install git_url             Install package from GIT. Example (zkg install https://github.com/corelight/ztest).
    			zkg list                        List installed package.
    			zkg remove                      Remove installed package.
    			zkg refresh                     Check version updates for installed packages.
    			zkg upgrade                     Update installed packages.

			Существует несколько способов использования пакетов

    			1)  	Первый подход заключается в использовании их в качестве фреймворков и вызове определенного пути/каталога пакета для каждого использования.
    			2)  	Второй и наиболее распространенный подход заключается в вызове пакетов из скрипта с помощью метода "@load".
    			3)  	Третий и последний подход к использованию пакетов заключается в вызове их имен пакетов
        			*** 	Обратите внимание, что этот метод работает только для пакетов, установленных с помощью метода установки "zkg".

			Давайте установим пакет, проверим установился он (отображается ли в списке установленных пакетов), а затем продемонстрируем его использование в различных подходах.

    			<user_name>@<host_name>$ zkg install zeek/cybera/zeek-sniffpass
        			
				The following packages will be INSTALLED:
        			zeek/cybera/zeek-sniffpass (master)
        			Proceed? [Y/n] Y
        			Installing "zeek/cybera/zeek-sniffpass"
        			Installed "zeek/cybera/zeek-sniffpass" (master)
        			Loaded "zeek/cybera/zeek-sniffpass"

    			<user_name>@<host_name>$ zkg list
        
				zeek/cybera/zeek-sniffpass (installed: master) - Sniffpass will alert on cleartext passwords discovered in HTTP POST requests

			Как указано в описании на терминале выше, этот пакет создает оповещения для открытых текстовых паролей, найденных в HTTP-трафике.
			Давайте используем этот пакет тремя разными способами!

    			### Calling with script
        			<user_name>@<host_name>$ zeek -Cr http.pcap sniff-demo.zeek 

    			### Calling from path
        			<user_name>@<host_name>$ zeek -Cr http.pcap /opt/zeek/share/zeek/site/zeek-sniffpass

    			### Calling with package name
        			<user_name>@<host_name>$ zeek -Cr http.pcap zeek-sniffpass

			Вышеприведенный вывод демонстрирует, как выполнить/загрузить пакеты с помощью pcap.
			Вы можете использовать лучший для вашего случая.
			Пакет "zeek-sniffpass" предоставляет дополнительную информацию в файле notification.log.

    			<user_name>@<host_name>$ cat notice.log | zeek-cut id.orig_h id.resp_h proto note msg
            
					10.10.57.178	44.228.249.3	tcp	SNIFFPASS::HTTP_POST_Password_Seen	Password found for user BroZeek
            		10.10.57.178	44.228.249.3	tcp	SNIFFPASS::HTTP_POST_Password_Seen	Password found for user ZeekBro

			Вышеприведенный вывод показывает, что пакет нашел отправку паролей в открытом виде, предоставил уведомление и захватил имена пользователей.
			Помните, использовали SIGNATURE для выполнения того же действия.
			Теперь мы можем выполнить то же действие без использования файла подписи.
			Это простая демонстрация преимуществ и гибкости скриптов Zeek.

=====================================================================
* Начало работы с Zeek *
************************

Существует два варианта работы Zeek:

    1)  Запуск его как службы
    2)  Запуск Zeek с помощью pcap.

1)  Перед началом работы с Zeek рекомендуется проверять версию экземпляра Zeek.
Это как правило делается только когда вы либо впервые запускаете Zeek на своей системе, либо работает на новой или чужой системе
Это помогает понять установлен ли вообще Zeek и какой версии
Для этого используют команду    -   zeek -v

Для запуска Zeek как службы нам нужно использовать модуль «ZeekControl».
Для использования модуля «ZeekControl» требуются права суперпользователя.
Вы можете повысить привилегии сеанса и переключиться на учетную запись суперпользователя, чтобы изучить сгенерированные файлы журнала с помощью следующей команды: sudo su

Здесь мы можем управлять службой Zeek и просматривать ее состояние.
Основное управление службой Zeek осуществляется с помощью трех команд:

    -   status
    -   start
    -   stop

Вы также можете использовать режим "ZeekControl" со следующими командами:

    -   zeekctl status
    -   zeekctl start
    -   zeekctl stop

Использование Zeek как службы   -   единственный способ прослушивать сетевой трафик в реальном времени.

2)  Помимо использования Zeek в качестве инструмента мониторинга сети, мы также можем использовать его в качестве исследователя пакетов.
Для этого нам нужно обработать файлы pcap с помощью Zeek.
После обработки файла pcap Zeek автоматически создает файлы журналов в соответствии с трафиком.

В режиме обработки pcap журналы сохраняются в рабочем каталоге.
Вы можете просмотреть сгенерированные журналы с помощью команды ls -l

Вот некоторые коючи, которые используются в режиме работы с pcap-файлами:

    Parameter	    Description
    
    -r	            Параметр чтения, чтение/обработка файла pcap.
    -C              Игнорирование ошибок контрольной суммы.
    -v              Информация о версии.
    -S              Использовать файл подписи
    zeekctl         ZeekControl модуль.

Для исследования сгенерированных журналов потребуются инструменты командной строки (cat, cut, grep sort и uniq) и дополнительные инструменты (zeek-cut). 

=====================================================================
* Intrusion Detection With Zeek *
*********************************

***	Для личной практики можно скаяать на свою вриатульную машину (прдварительно подклюбчившися к машине HTB через VPN) все pcap-файлы используя следующую команду

		<user_name>@<host_name>$ scp htb-student@[TARGET IP]:/home/htb-student/pcaps/<fule_name>.pcap
 
	++++++++++++++++++++++++++++++++++++++++++
	+ Example 1: Detecting Beaconing Malware +
	++++++++++++++++++++++++++++++++++++++++++

	Beaconing — это процесс, посредством которого вредоносное ПО взаимодействует со своим сервером управления и контроля (C2) для получения инструкций или извлечения данных.
	Обычно он характеризуется постоянным или шаблонным интервалом исходящих сообщений.

	Анализируя журналы подключений (conn.log), мы можем искать закономерности в исходящем трафике.
	Эти закономерности могут включать повторяющиеся подключения к одному и тому же IP-адресу или домену назначения, постоянный размер данных в отправленных данных или время подключения.
	Все это указывает на потенциальное поведение beaconing.
	Аномалии можно дополнительно исследовать с помощью скриптов Zeek, специально разработанных для обнаружения закономерностей beaconing.

	Итак, начнем

		<user_name>@<host_name>$ zeek -C -r /folder/where/you/keep/pcap_files/<file_name>.pcap
		<user_name>@<host_name>$ cat conn.log

	Если мы посмотрим достаточно внимательно, то заметим, что соединения с 51.15.197.127:80 устанавливаются примерно каждые 5 секунд, что является признаком вредоносного маяка.

	Файл psempire.pcap, который находится в каталоге //folder/where/you/keep/pcap_files, включает трафик, связанный с PowerShell Empire.
	PowerShell Empire действительно маячит каждые 5 секунд в своей конфигурации по умолчанию.

	***	Уделите немного времени изучению файла psempire.pcap с помощью Wireshark.

	+++++++++++++++++++++++++++++++++++++++++
	+ Example 2: Detecting DNS Exfiltration +
	+++++++++++++++++++++++++++++++++++++++++

	Zeek также полезен, когда мы подозреваем утечку данных.
	Утечку данных может быть трудно обнаружить, поскольку она часто имитирует обычный сетевой трафик.
	Однако с помощью Zeek мы можем анализировать наш сетевой трафик на более глубоком уровне.

	Файлы files.log Zeek можно использовать для идентификации больших объемов данных, отправляемых в необычное внешнее место назначения или через нестандартные порты, что может указывать на утечку данных.
	Файлы http.log и dns.log также можно использовать для идентификации потенциальных скрытых каналов утечки, таких как DNS-туннелирование или HTTP-запросы POST к подозрительному домену.

	Кроме того, способность Zeek повторно собирать файлы, переданные по сети (независимо от используемого протокола), может помочь в определении характера украденных данных.

	Итак, начнем

		<user_name>@<host_name>$ zeek -C -r /folder/where/you/keep/pcap_files/<file_name>.pcap
		<user_name>@<host_name>$ cat dns.log

	Давайте сосредоточимся на запрошенных (под)доменах, используя zeek-cut следующим образом

		<user_name>@<host_name>$ cat dns.log | zeek-cut query | cut -d . -f1-7

	При внимательном рассмотрении становится очевидным, что домен letsgohunt.online обладает значительным количеством поддоменов, похожих на облачных провайдеров.
	Однако стоит отметить, что взаимодействие с десятками или даже сотнями поддоменов, как правило, не считается типичным поведением.

	Файл dnsexfil.pcapng, который находится в каталоге /folder/where/you/keep/pcap_files, включает трафик, связанный с утечкой DNS.

	+++++++++++++++++++++++++++++++++++++++++
	+ Example 3: Detecting TLS Exfiltration +
	+++++++++++++++++++++++++++++++++++++++++

	Давайте теперь рассмотрим пример обнаружения утечки данных через TLS.
	Файл tlsexfil.pcap, который находится в каталоге /folder/where/you/keep/pcap_files, включает трафик, связанный с утечкой данных через TLS.

	Итак, начнем

		<user_name>@<host_name>$ zeek -C -r /folder/where/you/keep/pcap_files/<file_name>.pcap
		<user_name>@<host_name>$ cat conn.log

	Вывод немного сложен для анализа. Давайте сузим поиск, используя zeek-cut

		<user_name>@<host_name>$ cat conn.log | zeek-cut id.orig_h id.resp_h orig_bytes | sort | grep -v -e '^$' | grep -v '-' | datamash -g 1,2 sum 3 | sort -k 3 -rn | head -10

	Разберем данную комнаду:

		-	cat conn.log:
			Эта команда используется для чтения содержимого файла conn.log.
			Файл conn.log, сгенерированный Zeek, содержит запись всех подключений, которые имели место в нашей сети.

		-	zeek-cut id.orig_h id.resp_h orig_bytes:
			В этом случае мы извлекаем поля id.orig_h (исходный хост), id.resp_h (отвечающий хост) и orig_bytes (количество байтов, отправленных исходным хостом).

		-	sort:
			Эта команда используется для сортировки вывода предыдущей команды.
			По умолчанию sort упорядочивает строки в порядке возрастания на основе содержимого первого поля (в данном случае id.orig_h).

		-	grep -v -e '^$':
			Эта команда отфильтровывает все пустые строки.
			Параметр -v инвертирует выборку, параметр -e допускает регулярное выражение, а '^$'` соответствует пустым строкам.

		-	grep -v '-':
			Эта команда отфильтровывает строки, содержащие дефис -.
			В контексте журналов Zeek дефис часто представляет собой отсутствующее значение или неопределенное поле.

		-	datamash -g 1,2 sum 3:
			datamash — это инструмент командной строки, который выполняет основные числовые, текстовые и статистические операции.
			Параметр -g 1,2 группирует вывод по первым двум полям (IP-адреса исходного и отвечающего хостов), а sum 3 вычисляет сумму третьего поля (количество отправленных байтов) для каждой группы.

		-	sort -k 3 -rn:
			Эта команда сортирует вывод предыдущей команды в порядке убывания (-r) на основе числового значения (-n) третьего поля (-k 3), которое является суммой orig_bytes для каждой пары IP-адресов.

		-	head -10:
			Эта команда используется для ограничения вывода верхними 10 строками, тем самым отображая верхние 10 пар IP-адресов по общему количеству байтов, отправленных с исходного хоста на отвечающий хост.

	Мы замечаем, что ~270 МБ (на самом деле немного меньше) данных было отправлено на 192.168.151.181.

	+++++++++++++++++++++++++++++++
	+ Example 4: Detecting PsExec +
	+++++++++++++++++++++++++++++++

	PsExec, часть Sysinternals Suite, часто используется для удаленного администрирования в средах Active Directory.
	Учитывая его мощные возможности, неудивительно, что злоумышленники часто предпочитают PsExec при проведении атак удаленного выполнения кода.

	Чтобы проиллюстрировать типичную последовательность атаки, давайте рассмотрим следующее:
	
		злоумышленник передает двоичный файл PSEXESVC.exe на целевую машину, используя общий ресурс ADMIN$, специальную общую папку, используемую в сетях Windows, через протокол SMB (Server Message Block).
		После этого злоумышленник удаленно запускает этот файл как временную службу, используя общий ресурс IPC$, еще один специальный общий ресурс, который обеспечивает межпроцессное взаимодействие.

	Мы можем определить передачи SMB и типичное использование PsExec, используя smb_files.log, dce_rpc.log и smb_mapping.log Zeek следующим образом.

	***	Интернет ресурс для pcap-файла	-	https://raw.githubusercontent.com/401TRG/detections/master/pcaps/20171220_smb_psexec_add_user.pcap

	Итак, начнем

		<user_name>@<host_name>$ zeek -C -r /folder/where/you/keep/pcap_files/<file_name>.pcap
		<user_name>@<host_name>$ cat smb-files.log

		<user_name>@<host_name>$ cat dce_rpc.log
	
		<user_name>@<host_name>$ cat smb_mapping.log

	Создание временной службы очевидно в последних двух журналах выше.

	Файл psexec_add_user.pcap, который находится в каталоге folder/where/you/keep/pcap_files, включает трафик, связанный с типичным использованием PsExec.

	++++++++++++++++++++++++++++++++++++++++++++++++++
	+ Example 5: Detecting Gootkit's SSL Certificate +
	++++++++++++++++++++++++++++++++++++++++++++++++++

	Neutrino (печально известный набор эксплойтов) и Gootkit (мощный банковский троян) в прошлом сотрудничали для совершения кибератак.

	Набор эксплойтов Neutrino предоставлял точку входа, а затем Gootkit начал общаться по сети, используя шифрование SSL/TLS.
	Именно в этих зашифрованных сообщениях мы столкнулись с особенно поразительной деталью — сертификаты SSL, используемые Gootkit, содержали общее имя (CN) «My Company Ltd.».

	Киберпреступники часто используют самоподписанные или ненадежные сертификаты, выпущенные CA, для содействия зашифрованному общению.
	Эти сертификаты часто содержат поддельные или общие данные.
	В этом случае общее название My Company Ltd. выделяется как аномалия, которую мы можем использовать для идентификации этой конкретной инфекции Gootkit, доставленной через набор эксплойтов Neutrino.
		
	Описание атаки и возможные точки обнаружения, а также различные ресурсы на эту тему:

		-	https://web.archive.org/web/20230128061716/https://www.malware-traffic-analysis.net/2016/07/08/index.html
		-	https://any.run/malware-trends/gootkit/
		-	https://www.cyber.nj.gov/threat-landscape/malware/exploit-kits/neutrino
		-	https://www.cyber.nj.gov/threat-landscape/malware/trojans/gootkit
		-	https://securelist.com/gootkit-the-cautious-trojan/102731/

	Ну и сам pcap-файл для личного пользования и практически (имя файла - neutrinogootkit.pcap)

		-	https://web.archive.org/web/20230128061716/https://www.malware-traffic-analysis.net/2016/07/08/index.html 


/usr/local/zeek/bin/zeek -C -r /home/htb-student/pcaps/neutrinogootkit.pcap
