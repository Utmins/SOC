Suricata, считающаяся мощным инструментом для систем обнаружения вторжений в сеть (IDS), систем предотвращения вторжений (IPS) и мониторинга безопасности сети (NSM)

Цель Suricata — анализировать каждую йоту сетевого трафика, ища потенциальные признаки вредоносной деятельности.
Его сила заключается в способности не только проводить всеобъемлющую оценку состояния нашей сети, но и вникать в детали отдельных транзакций на уровне приложений.
Ключ к успешной работе Suricata заключается в тщательно разработанном наборе правил.
Эти руководящие принципы направляют процесс анализа Suricata, выявляя потенциальные угрозы и области интереса.
Suricata, оснащенный для работы на высоких скоростях как на готовом, так и на специально разработанном оборудовании, по эффективности не имеет себе равных.

Ключевые функции, которые повышают эффективность Suricata, включают:

	-	Глубокая проверка пакетов и регистрация захвата пакетов
	-	Обнаружение аномалий и мониторинг сетевой безопасности
	-	Обнаружение и предотвращение вторжений с доступным гибридным режимом
	-	Скриптинг Lua
	-	Географическая идентификация IP (GeoIP)
	-	Полная поддержка IPv4 и IPv6
	-	Репутация IP
	-	Извлечение файлов
	-	Расширенная проверка протоколов
	-	Мультиарендность

Примечание: Suricata также может использоваться для обнаружения «нестандартного/аномального» трафика.
Мы можем использовать стратегии, описанные на странице Suricata «Protocol Anomalies Detection» -  https://redmine.openinfosecfoundation.org/projects/suricata/wiki/Protocol_Anomalies_Detection
Такой подход улучшает нашу видимость необычного или несоответствующего поведения в нашей сети, тем самым усиливая нашу позицию безопасности

За более детальной информацией настоятельно рекомендуем изучить документацию Suricata, чтобы глубже понять его возможности - https://docs.suricata.io/en/latest/

=====================================================================
* General Terms *
*****************

	++++++++++++++++++++++++++++
	+ Suricata Operation Modes +
	++++++++++++++++++++++++++++

	Suricata работает в четырех различных режимах:

		-	Intrusion Detection System (IDS) mode
			Этот режим позиционирует Suricata как молчаливого наблюдателя.
			В этом качестве Suricata тщательно проверяет трафик, отмечая потенциальные атаки, но воздерживаясь от любой формы вмешательства.
			Предоставляя глубокий обзор сетевой активности и ускоряя время отклика, этот режим увеличивает видимость сети, хотя и не предлагая прямой защиты.

		-	Intrusion Prevention System (IPS) mode
			В данном режиме Suricata занимает проактивную позицию.
			Весь сетевой трафик должен проходить через строгие проверки Suricata и получает доступ к внутренней сети только после одобрения Suricata.
			Этот режим усиливает безопасность, проактивно пресекая атаки до того, как они проникнут в нашу внутреннюю сеть.
			Развертывание Suricata в режиме IPS требует глубокого понимания сетевого ландшафта, чтобы предотвратить непреднамеренную блокировку законного трафика.
			Кроме того, каждая активация правила требует тщательного тестирования и проверки.
			Хотя этот режим повышает безопасность, процесс проверки может вносить задержку.

		-	Intrusion Detection Prevention System (IDPS) mode
			Данный режим объединяет лучшее из IDS и IPS.
			Хотя Suricata продолжает пассивно отслеживать трафик, она обладает способностью активно передавать пакеты RST в ответ на аномальные действия.
			Этот режим обеспечивает баланс между активной защитой и поддержанием низкой задержки, что имеет решающее значение для бесперебойной работы сети.

		-	etwork Security Monitoring (NSM) mode
			В режиме мониторинга сетевой безопасности (NSM) Suricata переходит в специальный механизм ведения журнала, избегая активного или пассивного анализа трафика или возможностей предотвращения.
			Он тщательно регистрирует каждую часть сетевой информации, с которой сталкивается, предоставляя ценный массив данных для ретроспективных расследований инцидентов безопасности, несмотря на большой объем генерируемых данных.

	+++++++++++++++++++++++++++++++++++++++
	+ Configuring Suricata & Custom Rules +
	+++++++++++++++++++++++++++++++++++++++

	Расположкемк правил Suricata может быть в любом удобном для Вас месте
	Но по умолчанию они располагаются в следующем каталоге, содержимое которого можно просмотреть использую даннуюкоманду

		<user_name>@<host_name>$ ls -lah /etc/suricata/rules/

	Если вы хотите подробнее почитать и изучить то или иное правило, чтобы понять его функциональность, то лучше использовать утилиту more, так как содержание правила может быть огромным

		<user_name>@<host_name>$ more /etc/suricata/rules/<rule_name>.rules

	Правила могут быть закомментированы, то есть они не загружены и не влияют на систему.
	Обычно это происходит, когда в игру вступает новая версия правила или если угроза, связанная с правилом, становится устаревшей или неактуальной.
	Каждое правило обычно включает определенные переменные, такие как $HOME_NET и $EXTERNAL_NET.
	Правило проверяет трафик с IP-адресов, указанных в переменной $HOME_NET, направляющийся к IP-адресам в переменной $EXTERNAL_NET.

	Эти переменные можно определить в файле конфигурации suricata.yaml
	Это позволяет нам настраивать эти переменные в соответствии с нашей конкретной сетевой средой и даже определять наши собственные переменные.

		<user_name>@<host_name>$ more /etc/suricata/suricata.yaml

	Наконец, чтобы настроить Suricata для загрузки подписей из файла пользовательских правил (например local.rules, который может располагать в любом месте на диске, допустим в каталоге /home/<user_name>), мы должны выполнить следующее.

		1)	<user_name>@<host_name>$ sudo vim /etc/suricata/suricata.yaml
			OR
			<user_name>@<host_name>$ sudo nano /etc/suricata/suricata.yaml

		2)	Add /folder/where/you/keep/your/local.rules to rule-files section

		3)	Save and exit

	+++++++++++++++++++++++++++++++++++++++
	+ Validating Suricata's Configuration +
	+++++++++++++++++++++++++++++++++++++++

	Проверка конфигурации Suricata также является неотъемлемой частью поддержания надежности нашей настройки IDS/IPS.
	Для проверки конфигурации мы можем использовать опцию -T, предоставляемую командой Suricata.
	Эта команда запускает тест, чтобы проверить, является ли файл конфигурации допустимым и все ли файлы, указанные в конфигурации, доступны.

	Вот как мы можем это сделать

		<user_name>@<host_name>$ sudo suricata -T -c /etc/suricata/suricata.yaml

	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	+ Live Rule Reloading Feature & Updating Suricata Rulesets +
	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	Перезагрузка правил в реальном времени — это важная функция в Suricata, которая позволяет нам обновлять набор правил, не прерывая текущую проверку трафика.
	Эта функция обеспечивает непрерывный мониторинг и сводит к минимуму вероятность пропуска вредоносной активности.

	Чтобы включить перезагрузку правил в реальном времени в Suricata, нам нужно настроить файл конфигурации Suricata (suricata.yaml).
	В файле suricata.yaml нам следует найти раздел detect-engine и установить значение параметра reload на true.
	Это выглядит примерно так:

		detect-engine:
  			- reload: true

	Затем необходимо выполнить команду kill, которая даст сигнал процессу Suricata (определяемому $(pidof suricata)) обновить свой набор правил без необходимости полного перезапуска

		<user_name>@<host_name>$ sudo kill -usr2 $(pidof suricata)

	Эта модификация сообщает Suricata о необходимости периодически проверять наличие изменений в наборе правил и применять их без необходимости перезапуска службы.

	Обновление набора правил Suricata может быть выполнено с помощью инструмента suricata-update.
	Мы можем выполнить простое обновление набора правил Suricata с помощью следующей команды (перед началом работы с suricata)
	***	Необходимо подклбчение к интеренту

		<user_name>@<host_name>$ sudo suricata-update
		<user_name>@<host_name>$ sudo suricata -T -c /etc/suricata/suricata.yaml

	Чтобы создать полный список всех поставщиков наборов правил, необходжимо выполнить следующую команду

		<user_name>@<host_name>$ sudo suricata-update list-sources
		<user_name>@<host_name>$ sudo suricata -T -c /etc/suricata/suricata.yaml

	Если мы хотим, чтобы Suricata извлекала определенные наборы правил, а затем активировала их в наших правилах (на примере набора правил et/open), то нужно использовать следующую комнаду

		<user_name>@<host_name>$ sudo suricata-update enable-source et/open

	А затем необходимо повторно выполнить команду suricata-update, чтобы загрузить недавно полученный набор правил

		<user_name>@<host_name>$ sudo suricata-update

	При этом может потребоваться перезапуск службы Suricata

		<user_name>@<host_name>$ sudo systemctl restart suricata


	+++++++++++++++++++
	+ Suricata Inputs +
	+++++++++++++++++++

	Что касается данных для анализа (inputs) Suricata, то есть две основные категории:

		-	Offline Input
			Это включает чтение файлов PCAP для обработки ранее захваченных пакетов в формате файла LibPCAP.
			Это не только выгодно для проведения "посмертной" проверки данных, но и полезно при экспериментировании с различными наборами правил и конфигурациями.

		-	Live Input
			Живой ввод может быть облегчен через LibPCAP, где пакеты считываются непосредственно с сетевых интерфейсов.
			Однако LibPCAP несколько ограничен своими ограничениями производительности и отсутствием возможностей балансировки нагрузки.
			Для встроенных операций доступны параметры NFQ и AF_PACKET.

				.] 	NFQ
					Специфичный для Linux встроенный режим IPS, сотрудничает с IPTables для перенаправления пакетов из пространства ядра в Suricata для детального изучения.
					Обычно используемый встроенный NFQ требует правил отбрасывания для Suricata, чтобы эффективно препятствовать пакетам

				.]	AF_PACKET
					Он в отличии от NFQ обеспечивает улучшение производительности по сравнению с LibPCAP и поддерживает многопоточность.
					Тем не менее, он несовместим со старыми дистрибутивами Linux и не может быть использован в качестве встроенного, если машина также выполняет задачу маршрутизации пакетов.

	***	Обратите внимание, что доступны и другие, менее часто используемые или более продвинутые источники данных.

	С помощью Suricata мы можем экспериментировать как с офлайн-, так и с живым потоком данных:

		//////////////////////
		/// OFF-Line Input ///
		//////////////////////

		Для автономного (off-line) ввода (чтения файлов PCAP) необходимо выполнить следующую команду, и Suricata создаст различные журналы (в основном eve.json, fast.log и stats.log)

			<user_name>@<host_name>$ suricata -r /folder/where/you/keep/pcap_files/<file_name>.pcap

		Можно выполнить альтернативную команду для обхода контрольных сумм (флаг -k) и входа в другой каталог (флаг -l)

			<user_name>@<host_name>$ suricata -r /folder/where/you/keep/pcap_files/<file_name>.pcap -k none -l 

		//////////////////
		/// LIVE Input ///
		//////////////////

		Для живого ввода можно попробовать режим LibPCAP Suricata (Live) следующим образом

			<user_name>@<host_name>$ ifconfig

			<user_name>@<host_name>$  sudo suricata --pcap=<interface_name> -vv

		Чтобы понаблюдать, как Suricata обрабатывает «живой» трафик, давайте установим дополнительное SSH-соединение и воспользуемся tcpreplay для воспроизведения сетевого трафика из файла PCAP

			<user_name>@<host_name>$ sudo tcpreplay -i <interface_name> /folder/where/you/keep/pcap_files/<file_name>.pcap

		Выждав некоторое время (5-10 секунд) смело завершайте и tcpreplay, и Suricata.
		Журналы наблюдаемого (воспроизведенного) трафика будут доступны в /var/log/suricata

		***	Параметр -i помогает Suricata выбрать лучший параметр ввода.
			В случае Linux лучшим параметром ввода является AF_PACKET.
			Если необходим режим pcap, рекомендуется параметр --pcap.
			Конфигурацию (Live) LibPCAP можно выполнить с помощью файла suricata.yaml, включая настройки размера буфера, фильтров BPF или tcpdump, проверки контрольной суммы, потоков, смешанного режима, длины снимка и т. д.

		///////////
		/// NFQ ///
		///////////

		Для Suricata в режиме Inline (NFQ) сначала необходимо выполнить следующую команду.
		
			<user_name>@<host_name>$ sudo iptables -I FORWARD -j NFQUEUE

		Затем мы сможем выполнить следующее.

			<user_name>@<host_name>$ sudo suricata -q 0
		
		/////////////////
		/// AF_PACKET ///
		/////////////////

		Чтобы попробовать Suricata в режиме IDS с входом AF_PACKET, выполните одно из следующих действий

			<user_name>@<host_name>$ sudo suricata -i <interface_name>

			OR

			<user_name>@<host_name>$ sudo suricata --af-packet=<interface_name>
	
	++++++++++++++++++++
	+ Suricata Outputs +
	++++++++++++++++++++

	Suricata создает несколько различных вариантов результатов анализа, включая журналы, оповещения и дополнительные данные, связанные с сетью, такие как запросы DNS и сетевые потоки.
	Одним из наиболее важных выходов является EVE - журнал в формате JSON, который записывает широкий спектр типов событий, включая оповещения, HTTP, DNS, метаданные TLS, drop, метаданные SMTP, flow, netflow и многое другое.
	Такие инструменты, как Logstash, могут легко потреблять этот выход, облегчая анализ данных.

	Мы также можем столкнуться с вариантом Unified2 Suricata, который по сути является двоичным форматом оповещения Snort, что позволяет интегрировать его с другим программным обеспечением, использующим Unified2.
	Любой вывод Unified2 можно прочитать с помощью инструмента Snort u2spewfoo, который является простым и эффективным методом получения информации о данных оповещения.

		///////////////////////
		/// File Extraction ///
		///////////////////////

		Suricata имеет недоиспользуемую, но очень мощную функцию — извлечение файлов.
		Эта функция позволяет нам захватывать и хранить файлы, передаваемые по ряду различных протоколов, предоставляя бесценные данные для поиска угроз, криминалистики или просто анализа данных.

		Вот как мы включаем извлечение файлов в Suricata.

		Начнем с внесения изменений в файл конфигурации Suricata (suricata.yaml).
		В этом файле мы найдем раздел с именем file-store.
		Здесь мы сообщаем Suricata, как обрабатывать извлекаемые файлы.
		В частности, нам нужно:
			
			-	установить версию на 2,
			-	установить eneabled на yes
			-	установить force-filestore на yes.

		Результирующий раздел должен выглядеть примерно так.

			file-store:
				version: 2
				enabled: yes
				force-filestore: yes

		В том же разделе (file-store) мы определяем, где Suricata хранит извлеченные файлы.
		Мы устанавливаем опцию dir на каталог по нашему выбору
		К примеру

				dir: /home/<user_name>/log/suricata/filestore		

		В соответствии с рекомендациями, изложенными в документации Suricata, извлечение файлов не является автоматическим процессом, который происходит без наших явных указаний.
		Для нас принципиально важно создать конкретное правило, которое инструктирует Suricata, когда и какие файлы она должна извлекать.
		Простейшее правило, которое мы можем добавить в наш файл local.rules для экспериментов с извлечением файлов, это следующий

			alert http any any -> any any (msg:"FILE store all"; filestore; sid:2; rev:1;)

		Если мы правильно настроили Suricata, в каталоге хранилища файлов будет храниться несколько файлов.
		В качестве быстрого упражнения давайте включим извлечение файлов и запустим Suricata на файле /home/htb-student/pcaps/vm-2.pcap, который предварительно был скачан с www.netresec.com
		***	www.netresec.com - Publicly available PCAP files

			<user_name>@<host_name>$ suricata -r /home/htb-student/pcaps/vm-2.pcap

		И сели все настройки в файла конфигурации правильны, то мы должны получить такой вывод на экран

			7/3/2025 -- 23:49:46 - <Notice> - This is Suricata version 6.0.13 RELEASE running in USER mode
			7/3/2025 -- 23:49:46 - <Notice> - all 3 packet processing threads, 4 management threads initialized, engine started.
			7/3/2025 -- 23:49:46 - <Notice> - Signal Received.  Stopping engine.
			7/3/2025 -- 23:49:46 - <Notice> - Pcap-file module read 1 files, 803 packets, 683915 bytes

		Далее переходим в папку filestore

			<user_name>@<host_name>$ cd /.../.../.../filestore
			<user_name>@<host_name>$ find . -type f

				./fb/fb20d18d00c806deafe14859052072aecfb9f46be6210acfce80289740f2e20e
				./21/214306c98a3483048d6a69eec6bf3b50497363bc2c98ed3cd954203ec52455e5
				./21/21742fc621f83041db2e47b0899f5aea6caa00a4b67dbff0aae823e6817c5433
				./26/2694f69c4abf2471e09f6263f66eb675a0ca6ce58050647dcdcfebaf69f11ff4
				./2c/2ca1a0cd9d8727279f0ba99fd051e1c0acd621448ad4362e1c9fc78700015228
				./7d/7d4c00f96f38e0ffd89bc2d69005c4212ef577354cc97d632a09f51b2d37f877
				./6b/6b7fee8a4b813b6405361db2e70a4f5a213b34875dd2793667519117d8ca0e4e
				./2e/2e2cb2cac099f08bc51abba263d9e3f8ac7176b54039cc30bbd4a45cfa769018
				./50/508c47dd306da3084475faae17b3acd5ff2700d2cd85d71428cdfaae28c9fd41
				./c2/c210f737f55716a089a33daf42658afe771cfb43228ffa405d338555a9918815
				./ea/ea0936257b8d96ee6ae443adee0f3dacc3eff72b559cd5ee3f9d6763cf5ee2ab
				./1a/1aab7d9c153887dfa63853534f684e5d46ecd17ba60cd3d61050f7f231c4babb
				./c4/c4775e980c97b162fd15e0010663694c4e09f049ff701d9671e1578958388b9f
				./63/63de4512dfbd0087f929b0e070cc90d534d6baabf2cdfbeaf76bee24ff9b1638
				./48/482d9972c2152ca96616dc23bbaace55804c9d52f5d8b253b617919bb773d3bb
				./8e/8ea3146c676ba436c0392c3ec26ee744155af4e4eca65f4e99ec68574a747a14
				./8e/8e23160cc504b4551a94943e677f6985fa331659a1ba58ef01afb76574d2ad7c
				./a5/a52dac473b33c22112a6f53c6a625f39fe0d6642eb436e5d125342a24de44581

		Опять же, в соответствии с рекомендациями, изложенными в документации Suricata, модуль хранения файлов использует свой собственный каталог журналов (по умолчанию: filestore в каталоге журналов по умолчанию) и регистрирует файлы, используя SHA256 содержимого в качестве имени файла.
		Затем каждый файл помещается в каталог с именем от 00 до ff, где каталог разделяет первые 2 символа имени файла.
		Например, если шестнадцатеричная строка SHA256 извлеченного файла начинается с f9bc6d... файл мы помещаем в каталог filestore/f9.

		Если мы хотим проверить, например, файл /21/21742fc621f83041db2e47b0899f5aea6caa00a4b67dbff0aae823e6817c5433 внутри каталога хранения файлов, мы можем использовать инструмент xxd следующим образом.

			<user_name>@<host_name>$ cd /.../.../.../filestore
			<user_name>@<host_name>$ xxd ./21/21742fc621f83041db2e47b0899f5aea6caa00a4b67dbff0aae823e6817c5433 | head

				00000000: 4d5a 9000 0300 0000 0400 0000 ffff 0000  MZ..............
				00000010: b800 0000 0000 0000 4000 0000 e907 0000  ........@.......
				00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................
				00000030: 0000 0000 0000 0000 0000 0000 8000 0000  ................
				00000040: 0e1f ba0e 00b4 09cd 21b8 014c cd21 5468  ........!..L.!Th
				00000050: 6973 2070 726f 6772 616d 2063 616e 6e6f  is program canno
				00000060: 7420 6265 2072 756e 2069 6e20 444f 5320  t be run in DOS 
				00000070: 6d6f 6465 2e0d 0d0a 2400 0000 0000 0000  mode....$.......
				00000080: 5045 0000 4c01 0300 fc90 8448 0000 0000  PE..L......H....
				00000090: 0000 0000 e000 0f01 0b01 0600 00d0 0000  ................

		В этом случае файл был исполняемым файлом Windows, судя по заголовку файла.
		Подробнее о формате MS-DOS EXE можно узнать в следующем ресурсе MZ	-	https://wiki.osdev.org/MZ	



	Suricata записывает различные данные в журналы, которые по умолчанию находятся в каталоге /var/log/suricata.
	Чтобы получить доступ к этим журналам и управлять ими, нам требуется доступ на уровне root.
	Среди этих журналов мы находим файлы eve.json, fast.log и stats.log, которые предоставляют бесценную информацию о сетевой активности.
	Давайте рассмотрим каждый из них:

		////////////////
		/// eve.json ///
		////////////////

		Этот файл является рекомендуемым выходом Suricata и содержит объекты JSON, каждый из которых несет разнообразную информацию, такую ​​как

			-	временные метки
			-	flow_id
			-	event_type
			-	многое другое

		Для проверки содержимого файла <smth>_eve.json, находящегося в /var/log/suricata, можно использовать следующую команду

			<user_name>@<host_name>$ less /var/log/suricata/<smth>_eve.json

		А, если мы хотим отфильтровать только события оповещений, мы можем использовать процессор командной строки JSON jq следующим образом
	
			<user_name>@<host_name>$ cat /var/log/suricata/<smth>_eve.json | jq -c 'select(.event_type == "alert")'

		Ну а, если мы хотим определить самое раннее событие DNS, мы можем использовать процессор командной строки JSON jq следующим образом.

			<user_name>@<host_name>$ cat /var/log/suricata/<smth>_eve.json | jq -c 'select(.event_type == "dns")' | head -1 | jq .

		Особо внимание стоит удилеть некоторым ИДЕНТИФИКАТОРАМ (заголовкам), которым будут представленны в ввыводе вышеупомянутой комнады:

			-	flow_id
				Это уникальный идентификатор, назначаемый Suricata каждому сетевому потоку.
				Поток, в терминах Suricata, определяется как набор IP-пакетов, проходящих через сетевой интерфейс в определенном направлении и между заданной парой исходных и конечных точек назначения.
				Каждый из этих потоков получает уникальный flow_id.
				Этот идентификатор помогает нам отслеживать и сопоставлять различные события, связанные с одним и тем же сетевым потоком в журнале EVE JSON.
				Используя flow_id, мы можем связывать различные фрагменты информации, связанные с одним и тем же потоком, такие как оповещения, сетевые транзакции и пакеты, предоставляя целостное представление о том, что происходит на определенном канале связи.

			-	pcap_cnt
				Это счетчик, который Suricata увеличивает для каждого пакета, который он обрабатывает из сетевого трафика или из файла PCAP (в автономном режиме).
				pcap_cnt позволяет нам отслеживать пакет обратно до его исходного порядка в файле PCAP или сетевом потоке.
				Это полезно для понимания последовательности сетевых событий по мере их возникновения.
				Это может помочь точно определить, когда было сгенерировано оповещение по отношению к другим пакетам, что может предоставить ценный контекст для расследования.

		Мы также можем использовать аналогичные команды для фильтрации других типов событий, таких как TLS и SSH.

		////////////////
		/// fast.log ///
		////////////////

		Это текстовый формат журнала, который записывает только оповещения и включен по умолчанию.
		Попробуйте проверить содержимое <smth>_fast.log, находящегося в /var/log/suricata, следующим образом.

			<user_name>@<host_name>$ cat /var/log/suricata/<smth>_fast.log

		/////////////////
		/// stats.log ///
		/////////////////

		Это журнал статистики, который может быть особенно полезен при отладке развертываний Suricata.
		Попробуйте проверить содержимое <smth>_stats.log, находящегося в /var/log/suricata, следующим образом.

			<user_name>@<host_name>$ cat /var/log/suricata/<smth>_stats.log

	***	Если Вы хотите или Вам нужна более целенаправленная стратегия вывода, есть возможность деактивировать всеобъемлющий вывод EVE и активировать вместо него отдельные выводы.
		Возьмем, к примеру, http-log.
		При активации этого, каждый раз, когда Suricata запускается и сталкивается с событиями HTTP, будет генерироваться новый файл http.log

			<user_name>@<host_name>$ ?????

=====================================================================
* Suricata Rule Development *
*****************************

По своей сути правило в Suricata служит директивой, предписывающей движку активно следить за определенными маркерами в сетевом трафике.
Когда такие маркеры появляются, мы получаем уведомление.

Более того, правила Suricata не сосредоточены исключительно на обнаружении злонамеренных действий или потенциально опасного трафика.
Во многих случаях правила могут быть разработаны для предоставления защитникам сети или членам синей команды критически важных сведений или контекстных данных относительно текущей сетевой активности.
Специфичность или общность правил находятся в наших руках.
Достижение баланса имеет первостепенное значение, например, для выявления вариаций определенного штамма вредоносного ПО, избегая ложных срабатываний.

Разработка этих правил часто использует важную информацию, предоставляемую сообществами информационной безопасности и разведкой угроз.
Однако стоит отметить, что каждое правило, которое мы развертываем, потребляет часть ресурсов ЦП и памяти хоста.
Поэтому Suricata предоставляет конкретные рекомендации по написанию эффективных правил

	+++++++++++++++++++++++++
	+ Suricata Rule Anatomy +
	+++++++++++++++++++++++++

	Давайте разберем типично правило Suricata, используя следующий пример

		action protocol from_ip port -> to_ip port (msg:"Known malicious behavior, possible X malware infection"; Rule Buffers; flow:to/from_where/who; dsize:>#####; content:"some thing"; Rule options; ref:xxxxx; sid:10000001; rev:1;)

	Каждое правило состоит из 3 частей:

		1)	HEADER (action protocol from_ip port -> to_ip port part)

		2)	RULE MESSAGE & CONTENT (msg:"Known malicious behavior, possible X malware infection"; Rule Buffers; flow:to/from_where/who; dsize:>#####; content:"some thing"; Rule options)

		3)	RULE METADATA (ref:xxxxx; sid:10000001; rev:1;)


		//////////////
		/// HEADER ///
		//////////////

		Заголовок (action protocol from_ip port -> to_ip port part)
		Раздел заголовка правила инкапсулирует предполагаемое действие (action) правила вместе с протоколом (protocol), где правило, как ожидается, будет применено.
		Кроме того, он включает IP-адреса, информацию о порте и стрелку, указывающую направление трафика (traffic directional).

		Остановимся на каждой части ЗАГОЛОВКА отдельно:

			-	action
				Указывает Suricata, какие шаги предпринять, если содержимое совпадает.
				Это может варьироваться от:
					
					i)		генерации оповещения (alert)
					ii)		регистрации трафика без оповещения (log)
					iii)		игнорирования пакета (pass)
					iv)		отбрасывания пакета в режиме IPS (drop)
					v)		отправки пакетов TCP RST (reject)

			-	protocol
				Отображает используемый протокол
				Которыйы может быть разным, включая tcp, udp, icmp, ip, http, tls, smb или dns.

			-	traffic directional
				Направленность трафика объявляется с помощью переменных хоста правила (таких как $HOME_NET, $EXTERNAL_NET и т. д., которые мы видели внутри suricata.yaml) и направления правила.
				Стрелка направления между двумя парами IP-порт информирует Suricata о потоке трафика.
				Примеры:
					
					Outbound:		$HOME_NET any		->	$EXTERNAL_NET 9090
					Inbound:		$EXTERNAL_NET any	->	$HOME_NET 8443
					Bidirectional:		$EXTERNAL_NET any	<>	$HOME_NET any

			-	Rule ports
				Правила портов определяют порты, на которых будет оцениваться трафик для этого правила.
				Примеры:

					alert tcp $HOME_NET any -> $EXTERNAL_NET [8443,8080,7001:7002,!8443]
					alert tcp $HOME_NET any -> $EXTERNAL_NET 9443
					alert tcp $HOME_NET any -> $EXTERNAL_NET $UNCOMMON_PORTS
						***	$UNCOMMON_PORTS can be defined inside suricata.yaml

		//////////////////////////////
		/// RULE MESSAGE & CONTENT ///
		//////////////////////////////
	
		(msg:"Known malicious behavior, possible X malware infection"; Rule Buffers; flow:to/from_where/who; dsize:>#####; content:"some thing"; Rule options)
		Раздел «RULE MESSAGE & CONTENT» содержит сообщение, которое мы хотим отображать аналитикам или нам самим при обнаружении активности, о которой мы хотим получать уведомления.
		CONTENT — это сегменты трафика, которые мы считаем необходимыми для таких обнаружений.

		Остановимся на каждой части RULE MESSAGE & CONTENT отдельно:

			-	Rule message (msg)
				Сообщение правила (msg) — это произвольный текст, отображаемый при срабатывании правила.
				В идеале сообщения правила, которые мы создаем, должны содержать сведения об архитектуре вредоносного ПО, семействе и действии.

			-	flow
				Определяет отправителя и ответчика.
				Всегда помните, что при создании правил необходимо, чтобы движок отслеживал «установленные» сеансы TCP.
				Примеры:
				
					alert tcp any any		->	192.168.1.0/24 22	(msg:"SSH connection attempt"; flow:to_server; sid:1001;)
					alert udp 10.0.0.0/24 any	->	any 53			(msg:"DNS query"; flow:from_client; sid:1002;)
					alert tcp $EXTERNAL_NET any	->	$HOME_NET 80		(msg:"Potential HTTP-based attack"; flow:established,to_server; sid:1003;)

			-	dsize
				Соответствует размеру полезной нагрузки пакета.
				Он опирается на длину сегмента TCP, а не на общую длину пакета.
				Пример:

					alert http any any -> any any (msg:"Large HTTP response"; dsize:>10000; content:"HTTP/1.1 200 OK"; sid:2003;)

			-	Rule content
				Содержимое правила содержит уникальные значения, которые помогают идентифицировать определенный сетевой трафик или действия.
				Suricata сопоставляет эти уникальные значения содержимого в пакетах для обнаружения.
				Пример:

					content:"User-Agent|3a 20|Go-http-client/1.1|0d 0a|Accept-Encoding|3a 20|gzip";

						|3a 20|:
						Это представляет шестнадцатеричное представление символов ":", за которыми следует пробел.
						Оно используется для сопоставления точной последовательности байтов в полезной нагрузке пакета.

						|0d 0a|:
						Это представляет шестнадцатеричное представление символов "\r\n", которые обозначают конец строки в заголовках HTTP.

			-	Rule Buffers
				Используя Rule Buffers, нам не нужно искать весь пакет для каждого совпадения содержимого.
				Это экономит время и ресурсы.
				Более подробную информацию можно найти здесь	-	https://suricata.readthedocs.io/en/latest/rules/http-keywords.html
				Пример:

					alert http any any -> any any (http.accept; content:"image/gif"; sid:1;)

						http.accept:
						Липкий буфер для сопоставления с заголовком HTTP Accept.
						Содержит только значение заголовка. 
						r\n после заголовка не являются частью буфера.

			-	Rule options
				Действуют как дополнительные модификаторы для помощи в обнаружении, помогая Suricata определять точное местоположение содержимого.

					nocase
					Гарантирует, что правила не будут обойдены посредством изменения регистра.
					Пример:
	
						alert tcp any any -> any any (msg:"Detect HTTP traffic with user agent Mozilla"; content:"User-Agent: Mozilla"; nocase; sid:8001;)

					offset
					Сообщает Suricata о начальной позиции внутри пакета для сопоставления.
					Пример:
				
						alert tcp any any -> any any (msg:"Detect specific protocol command"; content:"|01 02 03|"; offset:0; depth:5; sid:3003;)
						Это правило запускает оповещение, когда Suricata обнаруживает определенную команду протокола, представленную последовательностью байтов |01 02 03| в полезной нагрузке TCP.
						Ключевое слово offset:0 задает начало сопоставления содержимого с начала полезной нагрузки, а depth:5 указывает длину в пять байтов, которая будет учитываться для сопоставления.

					distance
					Сообщает Suricata, что нужно искать указанное содержимое в n байтах относительно предыдущего сопоставления.
					Пример:

						alert tcp any any -> any any (msg:"Detect suspect URL path"; content:"/admin"; offset:4; depth:10; distance:20; within:50; sid:3001;)
						Это правило запускает оповещение, когда Suricata обнаруживает строку /admin в полезной нагрузке TCP, начиная с пятого байта (offset:4) и учитывая длину в десять байтов (depth:10).
						Ключевое слово distance:20 указывает, что последующие совпадения /admin не должны встречаться в течение следующих 20 байтов после предыдущего совпадения.
						Ключевое слово within:50 гарантирует, что совпадение содержимого происходит в течение следующих 50 байтов после предыдущего совпадения.

		/////////////////////
		/// RULE METADATA ///
		/////////////////////

		(ref:xxxxx; sid:10000001; rev:1;)

		ref (reference)
		Ссылка дает нам наводку, тропу, которая возвращает нас к исходному источнику информации, вдохновившему на создание правила.

		sid (signature ID)
		Уникальное качество этого числового идентификатора делает его необходимым для автора правила, чтобы управлять и различать правила.

		rev (revision)
		Дает представление о версии правила.
		Он служит индикатором эволюции правила с течением времени, выделяя внесенные изменения и улучшения.

	++++++++++++++++++++++++++++++++++++++++++++++
	+ Pearl Compatible Regular Expression (PCRE) +
	++++++++++++++++++++++++++++++++++++++++++++++	

	Обсудив суть правил Suricata, пришло время пролить свет на мощный инструмент в разработке правил	-	PCRE или Pearl Compatible Regular Expression.
	Использование PCRE может кардинально изменить ситуацию при создании правил.
	
	Чтобы использовать PCRE, мы используем оператор pcre, за которым следует регулярное выражение.
	Помните, что PCRE следует заключать в начальные и конечные прямые слеши (forward slashes), а все флаги располагать после последнего слеша.

	Также обратите внимание, что якоря располагаются после и перед обрамляющими слешами, а некоторые символы требуют экранирования обратной косой чертой.
	*** Совет	-	держитесь подальше от создания правила, которое опирается исключительно на PCRE.

	Пример:

		alert http any any -> $HOME_NET any (msg: "ATTACK [PTsecurity] Apache Continuum <= v1.4.2 CMD Injection"; content: "POST"; http_method; content: "/continuum/saveInstallation.action"; offset: 0; depth: 34; http_uri; content: "installation.varValue="; nocase; http_client_body; pcre: !"/^\$?[\sa-z\\_0-9.-]*(\&|$)/iRP"; flow: to_server, installed;sid: 10000048; rev: 1;)

			1)	Во-первых, правило срабатывает на HTTP-трафике (alert http) из любого источника и назначения на любой порт в домашней сети (any any -> $HOME_NET any).
			2)	Поле msg дает понятное человеку описание того, для чего предназначено оповещение, а именно ATTACK [PTsecurity] Apache Continuum <= v1.4.2 CMD Injection.
			3)	Далее правило проверяет наличие строки POST в HTTP-методе с использованием ключевых слов content и http_method.
				Правило сработает, если используемый HTTP-метод — это запрос POST.
			4)	Затем ключевое слово content используется с http_uri для сопоставления URI "/continuum/saveInstallation.action", начиная со смещения 0 и до глубины 34 байта.
				Это указывает целевую конечную точку, которая в данном случае является действием saveInstallation приложения Apache Continuum.
			5)	После этого другое ключевое слово content ищет installation.varValue= в теле HTTP-клиента без учета регистра (nocase).
				Эта строка может быть частью полезной нагрузки инъекции команды, которую пытается доставить злоумышленник.
			6)	Далее мы видим ключевое слово pcre, которое используется для реализации регулярных выражений, совместимых с Perl.
					^			-	обозначает начало строки.
					\$?			-	проверяет наличие необязательного знака доллара в начале.
					[\sa-z\\_0-9.-]*	-	соответствует нулю или более (*) символов в наборе.
									Набор включает:
										\s	-	пробел
										a-z	-	любая строчная буква
										\\	-	обратная косая черта
										_	-	подчеркивание
										0-9	-	любая цифра
										.	-	точка
										-	-	дефис
					(\&|$)			-	проверяет наличие амперсанда или конца строки.
					/iRP			-	в конце указывает на инвертированное совпадение (то есть правило срабатывает, когда совпадение не происходит), нечувствительное к регистру (i) и относительно положения буфера (RP).
			7)	Наконец, ключевое слово flow используется для указания того, что правило срабатывает при установленном входящем трафике к серверу.

	Для тех, кто стремится расширить свое понимание правил Suricata и глубже погрузиться в разработку правил, следующий ресурс послужит исчерпывающим руководством	-	https://docs.suricata.io/en/latest/rules/index.html.

	+++++++++++++++++++++++++++++++++++++++
	+ IDS/IPS Rule Development Approaches +
	+++++++++++++++++++++++++++++++++++++++

	Когда дело доходит до создания правил для систем обнаружения вторжений (IDS) и систем предотвращения вторжений (IPS), за этим стоит и искусство, и наука.
	Это требует всестороннего понимания сетевых протоколов, поведения вредоносных программ, уязвимостей системы и ландшафта угроз в целом.

	Ключевая стратегия, которую мы используем при создании этих правил, включает обнаружение определенных элементов в сетевом трафике, которые являются уникальными для вредоносных программ.
	Это часто называют обнаружением на основе сигнатур, и это классический подход, на который опирается большинство IDS/IPS.
	Сигнатуры могут варьироваться от простых шаблонов в полезной нагрузке пакетов, таких как обнаружение определенной команды или отличительной строки, связанной с определенной вредоносной программой, до сложных шаблонов, которые соответствуют серии пакетов или характеристикам пакетов.
	Обнаружение на основе сигнатур очень эффективно при работе с известными угрозами, поскольку оно может идентифицировать эти угрозы с высокой точностью, однако оно испытывает трудности при обнаружении новых угроз, для которых еще не существует сигнатуры.

	Другой подход фокусируется на выявлении определенных поведений, характерных для вредоносных программ.
	Обычно это называется обнаружением на основе аномалий или поведения.
	Например, определенный размер ответа HTTP, постоянно появляющийся в пределах порогового значения, или определенный интервал маяка могут указывать на шаблон коммуникации вредоносного ПО.
	Другие типы поведения могут включать необычно большие объемы передачи данных и использование необычных портов.
	Преимущество этого подхода заключается в его способности потенциально идентифицировать атаки нулевого дня или новые угрозы, которые не будут обнаружены системами на основе сигнатур.
	Однако он также имеет тенденцию к более высоким показателям ложных срабатываний из-за динамической природы поведения сети.

	Третий подход, который мы используем при создании правил IDS/IPS, — это анализ протокола с сохранением состояния (stateful protocol analysis).
	Этот метод включает в себя понимание и отслеживание состояния сетевых протоколов и сравнение наблюдаемого поведения с ожидаемыми переходами состояний этих протоколов.
	Отслеживая состояние каждого соединения, мы можем выявлять отклонения от ожидаемого поведения, которые могут указывать на вредоносную активность.

	++++++++++++++++++++++++++++++++++++++++++
	+ Rule Development for Encrypted Traffic +
	++++++++++++++++++++++++++++++++++++++++++

	В постоянно меняющемся ландшафте сетевой безопасности мы часто сталкиваемся со значительной проблемой	-	зашифрованным трафиком.
	Зашифрованный трафик может создавать значительные препятствия, когда дело доходит до эффективного анализа трафика и разработки надежных правил системы обнаружения вторжений (IDS) и системы предотвращения вторжений (IPS).

	Существуют несколько аспектов, которые мы можем использовать для обнаружения потенциальных угроз безопасности относительно загифрованного трафика.
	В частности, мы можем обратить внимание на элементы в сертификатах SSL/TLS и отпечатке JA3.

		-	 SSL/TLS certificates
			Сертификаты SSL/TLS, которыми обмениваются во время первоначального рукопожатия соединения SSL/TLS, содержат множество данных, которые остаются незашифрованными.
			Эти данные могут включать эмитента, дату выпуска, дату истечения срока действия и субъекта (содержащего информацию о том, кому выдан сертификат, и доменное имя).
			Подозрительные или вредоносные домены могут использовать сертификаты SSL/TLS с аномальными или уникальными характеристиками.
			Распознавание этих аномалий в сертификатах SSL/TLS может стать ступенькой к созданию эффективных правил Suricata.

		-	JA3 fingerprint
			Кроме того, мы можем использовать хэш JA3 — метод снятия отпечатков пальцев, который обеспечивает уникальное представление для каждого клиента SSL/TLS.
			Хэш JA3 объединяет данные из пакета приветствия клиента во время рукопожатия SSL/TLS, создавая некий справочник, который может быть уникальным для определенных семейств вредоносных программ или подозрительного программного обеспечения.
			В связи с этим, эти хэши могут быть мощным инструментом в формулировании правил обнаружения для зашифрованного трафика.

=====================================================================
* Suricata Rule Development Examples *	
**************************************

	+++++++++++++++++++++++++++++++
	+ Detecting PowerShell Empire +
	+++++++++++++++++++++++++++++++

	Данное правило Suricata разработано для обнаружения возможной исходящей активности из PowerShell Empire (распространенного фреймворка пост-эксплуатации, используемого злоумышленниками).

	PowerShell Empire — это фреймворк Command and Control (C2) с открытым исходным кодом.
	Его агента можно изучить через следующий репозиторий	-	https://github.com/EmpireProject/Empire/blob/master/data/agent/agent.ps1#L78

	Давайте разберем важные части этого правила, чтобы понять его работу.

		alert http $HOME_NET any -> $EXTERNAL_NET any
			(msg:"ET MALWARE Possible PowerShell Empire Activity Outbound"; 
				flow:established,to_server; 
				content:"GET"; http_method; 
				content:"/"; http_uri; depth:1; 
				pcre:"/^(?:login\/process|admin\/get|news)\.php$/RU"; 
				content:"session="; http_cookie; 
				pcre:"/^(?:[A-Z0-9+/]{4})*(?:[A-Z0-9+/]{2}==|[A-Z0-9+/]{3}=|[A-Z0-9+/]{4})$/CRi"; 
				content:"Mozilla|2f|5.0|20 28|Windows|20|NT|20|6.1"; http_user_agent; http_start; 
				content:".php|20|HTTP|2f|1.1|0d 0a|Cookie|3a 20|session="; fast_pattern; http_header_names; 
				content:!"Referer"; content:!"Cache"; content:!"Accept"; 
			sid:2027512; rev:1;)

		-	alert
			Это действие правила, указывающее, что Suricata должна генерировать оповещение всякий раз, когда выполняются условия, указанные в параметрах правила.

		-	http
			Это протокол правила. Он указывает, что правило применяется к HTTP-трафику.

		-	$HOME_NET any -> $EXTERNAL_NET any
			Это спецификации исходного и конечного IP-адресов.
			Правило будет активировано, когда HTTP-трафик исходит из любого порта (любого) на хосте в $HOME_NET (внутренняя сеть) и направляется на любой порт (любой) на хосте в $EXTERNAL_NET (внешняя сеть).

		-	msg: "ET MALWARE Possible PowerShell Empire Activity Outbound"
			Это сообщение, которое будет включено в оповещение, чтобы описать, что ищет правило.
	
		-	flow: Established, to_server
			Это указывает направление трафика.
			Правило ищет установленные соединения, по которым данные передаются на сервер.

		-	content: "GET"; http_method;
			Это соответствует методу HTTP GET в HTTP-запросе.

		-	content:"/"; http_uri; depth:1;
			Это соответствует корневому каталогу ("/") в URI.

		-	pcre:"/^(?:login\/process|admin\/get|news)\.php$/RU";
			Это регулярное выражение, совместимое с Perl (PCRE), ищет URI, которые заканчиваются на login/process.php, admin/get.php или news.php.

		-	content:"session="; http_cookie;
			Это ищет строку "session=" в HTTP cookie.

		-	pcre:"/^(?:[A-Z0-9+/]{4})*(?:[A-Z0-9+/]{2}==|[A-Z0-9+/]{3}=|[A-Z0-9+/]{4})$/CRi";
			Еще одно регулярное выражение, совместимое с Perl (PCRE), которое проверяет наличие данных в кодировке base64 в Cookie.

			Существует множество статей, посвященных PowerShell Empire, в которых отмечается, что файлы cookie, используемые PowerShell Empire, соответствуют стандарту кодировки Base64.
			Вот одна из них	-	https://www.keysight.com/blogs/tech/nwvs/2021/06/16/empire-c2-networking-into-the-dark-side

		-	content:"Mozilla|2f|5.0|20 28|Windows|20|NT|20|6.1"; http_user_agent; http_start;
			Это соответствует определенной строке User-Agent, которая включает "Mozilla/5.0 (Windows NT 6.1".

			Подробно пожно почитать тут	-	https://github.com/EmpireProject/Empire/blob/master/data/agent/agent.ps1#L78

		-	content:".php|20|HTTP|2f|1.1|0d 0a|Cookie|3a 20|session="; fast_pattern; http_header_names;
			Это соответствует шаблону в заголовках HTTP, который начинается с ".php HTTP/1.1\r\nCookie: session=".

		-	content:!"Referer"; content:!"Cache"; content:!"Accept";
			Это отрицательные совпадения содержимого.
			Правило сработает только в том случае, если заголовки HTTP не содержат "Referer", "Cache" и "Accept".

	Если коротко, то это правило Suricata запускает оповещение, когда обнаруживает установленный HTTP-запрос GET из нашей сети во внешнюю сеть с определенным шаблоном в полях URI, cookie и user-agent, а также исключая определенные заголовки.

	++++++++++++++++++++++
	+ Detecting Covenant +
	++++++++++++++++++++++

	Данное правило Suricata разработано для обнаружения определенных вариаций Covenant (еще одной распространенной структуры пост-эксплуатации, используемой злоумышленниками).
	Covenant — это фреймворк Command and Control (C2) с открытым исходным кодом.
	Его основы можно изучить через следующий репозиторий	-	https://petruknisme.medium.com/getting-started-with-covenant-c2-for-red-teaming-8eeb94273b52
								-	https://github.com/cobbr/Covenant/blob/master/Covenant/Data/Profiles/DefaultHttpProfile.yaml#L35

	Для общего ознакомления с техникой обнаружения зловреда COVENANT посредством Suricata и Wireshark можно ознакомиться тут	-	chrome-extension://efaidnbmnnnibpcajpcglclefindmkaj/https://repositorio-aberto.up.pt/bitstream/10216/142718/2/572020.pdf

	К сожалению, данное правило уже устарело и не является эффективным в современных реалиях (2025)
	Тем не менее, давайте разберем важные части этого правила, чтобы понять его работу:

		alert tcp any any -> $HOME_NET any 
			(msg:"detected by body"; content:"<title>Hello World!</title>"; 
				detection_filter: track by_src, count 4 , seconds 10; 
			priority:1; sid:3000011;)

		-	alert:
			Когда условия в параметрах правила выполняются, Suricata сгенерирует оповещение.

		-	tcp:
			Правило применяется к трафику TCP.

		-	any any -> $HOME_NET any:
			Правило отслеживает трафик TCP, который исходит с любого IP-адреса и любого порта (any any) и предназначен для любого порта (any) на хосте в $HOME_NET (внутренняя сеть).
	
		-	content:"<title>Hello World!</title>";: 
			Это указывает Suricata искать строку <title>Hello World!</title> в полезной нагрузке TCP.

		-	detection_filter: track by_src, count 4, seconds 10;: 
			Это фильтр после обнаружения.
			Он указывает, что правило должно отслеживать исходный IP-адрес (by_src) и будет вызывать оповещение только в том случае, если это же обнаружение произойдет не менее 4 раз (count 4) в течение 10-секундного окна (seconds 10).

	Короче говоря	-	это правило Suricata предназначено для генерации высокоприоритетного оповещения, если оно обнаруживает не менее четырех экземпляров трафика TCP в течение десяти секунд, содержащих строку <title>Hello World!</title> в полезной нагрузке, исходящих из того же исходного IP-адреса и направленных на любой хост в нашей внутренней сети.

	+++++++++++++++6++++++++++++++++++++++++
	+ Detecting Covenant (Using Analytics) +
	++++++++++++++++++++++++++++++++++++++++

	Альтернативный способ обнаружения COVENANT

		alert tcp $HOME_NET any -> any any 
			(msg:"detected by size and counter"; 
				dsize:312; 
				detection_filter: track by_src, count 3 , seconds 10; 
			priority:1; sid:3000001;)

		-	dsize:312;:
			Это предписывает Suricata искать TCP-трафик с размером полезной нагрузки данных ровно 312 байт.

		-	detection_filter: track by_src, count 3 , seconds 10;: 
			Это фильтр после обнаружения.
			Он говорит, что правило должно отслеживать исходный IP-адрес (by_src), и оно вызовет оповещение только в том случае, если обнаружит одно и то же правило не менее 3 раз (count 3) в течение 10-секундного окна (seconds 10).

	Другими словами	-	это правило Suricata предназначено для генерации высокоприоритетного оповещения, если оно обнаружит не менее трех экземпляров TCP-трафика в течение десяти секунд, каждый из которых содержит полезную нагрузку данных ровно 312 байт, все из которых исходят из одного исходного IP-адреса в нашей сети и направлены куда угодно.

	+++++++++++++++++++++++++++++++++
	+ Detecting Sliver (variant #1) +
	+++++++++++++++++++++++++++++++++

	Это правило Suricata разработано для обнаружения определенных вариаций Sliver (еще одного распространенного постэксплуатационного фреймворка, используемого злоумышленниками).
	Sliver - это еще один вариант Command and Control (C2) фреймворка с открытым исходным кодом
	
	Подробно о Sliver можно ознакомиться тут	-	https://barrymalone.medium.com/sliver-an-awesome-c2-framework-c0257f2f52e4
							-	https://github.com/BishopFox/sliver
							-	https://github.com/BishopFox/sliver/blob/master/server/configs/http-c2.go#L294

	А для ознакомления с техникой обнаружения зловреда COVENANT посредством Suricata и Wireshark можно ознакомиться тут (только к сожалению на китайском)	-	https://www.bilibili.com/read/cv19510951/	
	
	Давайте разберем важные части этого правила, чтобы понять его работу.

		alert tcp any any -> any any 
			(msg:"Sliver C2 Implant Detected"; 
				content:"POST"; 
				pcre:"/\/(php|api|upload|actions|rest|v1|oauth2callback|authenticate|oauth2|oauth|auth|database|db|namespaces)(.*?)((login|signin|api|samples|rpc|index|admin|register|sign-up)\.php)\?[a-z_]{1,2}=[a-z0-9]{1,10}/i"; 
			sid:1000007; rev:1;)

		-	content:"POST";: 
			Эта опция указывает Suricata искать TCP-трафик, содержащий строку "POST".

		-	pcre:"/\/(php|api|upload|actions|rest|v1|oauth2callback|authenticate|oauth2|oauth|auth|database|db|namespaces)(.*?)((login|signin|api|samples|rpc|index|admin|register|sign-up)\.php)\?[a-z_]{1,2}=[a-z0-9]{1,10}/i";: 
			Это регулярное выражение используется для определения определенных шаблонов URI в трафике.
			Оно будет сопоставлять URI, которые содержат определенные имена каталогов, за которыми следуют имена файлов, заканчивающиеся расширением PHP.

	+++++++++++++++++++++++++++++++++
	+ Detecting Sliver (variant #2) +
	+++++++++++++++++++++++++++++++++

	Альтернативный способ обнаружения SLIVER

		alert tcp any any -> any any 
			(msg:"Sliver C2 Implant Detected - Cookie"; 
				content:"Set-Cookie"; 
				pcre:"/(PHPSESSID|SID|SSID|APISID|csrf-state|AWSALBCORS)\=[a-z0-9]{32}\;/"; 
			sid:1000003; rev:1;)

		-	content:"Set-Cookie";:
			Эта опция предписывает Suricata искать TCP-трафик, содержащий строку Set-Cookie.
		-	pcre:"/(PHPSESSID|SID|SSID|APISID|csrf-state|AWSALBCORS)\=[a-z0-9]{32}\;/";:
			Это регулярное выражение, используемое для определения определенных шаблонов настройки cookie в трафике.
			Оно сопоставляет заголовок Set-Cookie, когда он устанавливает определенные имена cookie (PHPSESSID, SID, SSID, APISID, csrf-state, AWSALBCORS) со значением, которое представляет собой 32-символьную буквенно-цифровую строку.

	++++++++++++++++++++++++++++++++++++
	+ Detecting Sliver (TLS Encrypted) +
	++++++++++++++++++++++++++++++++++++	
	
	Данное правило предназначено для обнаружения определенных вариаций Sliver всякий раз, когда оно идентифицирует соединение TLS с определенным хэшем JA3.
	В связи с этим, в правило добавляют значение хэша JA3

		alert tls any any -> any any
			(msg:"Sliver C2 SSL"; 
				ja3.hash; 
				content:"473cd7cb9faa642487833865d516e578"; 
			sid:1002; rev:1;)

		-	ja3.hash; 
			

		-	content:"473cd7cb9faa642487833865d516e578"; 

	Для определения хэша JA3 следуеь тспользоват следующую команду

		<user_name>@<host_name>$ ja3 -a --json /folder/where/pcap/file/stored/<file_name>.pcap

			[
				{
				        "destination_ip": "23.152.0.91",
				        "destination_port": 443,
				        "ja3": "771,49195-49199-49196-49200-52393-52392-49161-49171-49162-49172-156-157-47-53-49170-10-4865-4866-4867,0-5-10-11-13-65281-18-43-51,29-23-24-25,0",
				        "ja3_digest": "473cd7cb9faa642487833865d516e578",
				        "source_ip": "10.10.20.101",
				        "source_port": 53222,
				        "timestamp": 1634749464.600896
				},
				{
				        "destination_ip": "23.152.0.91",
				        "destination_port": 443,
				        "ja3": "771,49195-49199-49196-49200-52393-52392-49161-49171-49162-49172-156-157-47-53-49170-10-4865-4866-4867,0-5-10-11-13-65281-18-43-51,29-23-24-25,0",
				        "ja3_digest": "473cd7cb9faa642487833865d516e578",
				        "source_ip": "10.10.20.101",
				        "source_port": 53225,
				        "timestamp": 1634749465.069819
				},
			---SNIP---
	
	++++++++++++++++++++++++++++++++++++
	+ Detecting Dridex (TLS Encrypted) +
	++++++++++++++++++++++++++++++++++++

	Данное правило запускает оповещение при обнаружении сеанса TLS из внешней сети в домашнюю сеть, где полезная нагрузка сеанса содержит определенные шаблоны байтов и соответствует нескольким условиям.
	Эти шаблоны и условия соответствуют сертификатам SSL, которые были связаны с определенными вариациями трояна Dridex, на которые ссылается черный список SSL на abuse.ch.

	Для более детального ознакомления с информацией по сертификатам SSL Dridex, следует посетить сайт	-	https://unit42.paloaltonetworks.com/wireshark-tutorial-dridex-infection-traffic/
	Тут Вы сможете найти не только принцип работы зловреда, но и его IOC при разборе через Wireshark

	Не нужно понимать правило целиком, но давайте разберем его важные части:

		alert tls $EXTERNAL_NET any -> $HOME_NET any 
			(msg:"ET MALWARE ABUSE.CH SSL Blacklist Malicious SSL certificate detected (Dridex)"; 
				flow:established,from_server; 
				content:"|16|"; content:"|0b|"; within:8; byte_test:3,<,1200,0,relative; 
				content:"|03 02 01 02 02 09 00|"; fast_pattern; 
				content:"|30 09 06 03 55 04 06 13 02|"; distance:0; pcre:"/^[A-Z]{2}/R"; 
				content:"|55 04 07|"; distance:0; 
				content:"|55 04 0a|"; distance:0; 
				pcre:"/^.{2}[A-Z][a-z]{3,}\s(?:[A-Z][a-z]{3,}\s)?(?:[A-Z](?:[A-Za-z]{0,4}?[A-Z]|(?:\.[A-Za-z]){1,3})|[A-Z]?[a-z]+|[a-z](?:\.[A-Za-z]){1,3})\.?[01]/Rs"; 
				content:"|55 04 03|"; distance:0; byte_test:1,>,13,1,relative; 
				content:!"www."; distance:2; within:4; 
				pcre:"/^.{2}(?P<CN>(?:(?:\d?[A-Z]?|[A-Z]?\d?)(?:[a-z]{3,20}|[a-z]{3,6}[0-9_][a-z]{3,6})\.){0,2}?(?:\d?[A-Z]?|[A-Z]?\d?)[a-z]{3,}(?:[0-9_-][a-z]{3,})?\.(?!com|org|net|tv)[a-z]{2,9})[01].*?(?P=CN)[01]/Rs"; 
				content:!"|2a 86 48 86 f7 0d 01 09 01|"; 
				content:!"GoDaddy"; 
			sid:2023476; rev:5;)


			-	content:"|16|"; content:"|0b|"; within:8; byte_test:3,<,1200,0,relative; 
				Правило ищет шестнадцатеричные значения 16 и 0b в первых 8 байтах полезной нагрузки.
				Они представляют сообщение рукопожатия (0x16) и тип сертификата (0x0b) в записи TLS.

			-	content:"|03 02 01 02 02 09 00|"; fast_pattern;
				Правило ищет этот конкретный шаблон байтов в пакете, который может быть характерен для сертификатов, используемых Dridex.

			-	content:"|30 09 06 03 55 04 06 13 02|"; distance:0; pcre:"/^[A-Z]{2}/R";
				Это проверяет поле 'countryName' в теме сертификата.
				Соответствие содержимого здесь соответствует последовательности ASN.1, указывающей тип атрибута и значение для «countryName» (OID 2.5.4.6).
				PCRE проверяет, что значение для «countryName» начинается с двух заглавных букв, что является стандартным форматом для кодов стран.

			-	content:"|55 04 07|"; distance:0;
				Проверяет наличие поля «localityName» в теме сертификата (OID 2.5.4.7).

			-	content:"|55 04 0a|"; distance:0;
				Проверяет наличие поля organizationName в теме сертификата (OID 2.5.4.10).

			-	pcre:"/^.{2}[A-Z][a-z]{3,}\s(?:[A-Z][a-z]{3,}\s)?(?:[A-Z](?:[A-Za-z]{0,4}?[A-Z]|(?:\.[A-Za-z]){1,3})|[A-Z]?[a-z]+|[a-z](?:\.[A-Za-z]){1,3})\.?[01]/Rs"; 
				

			-	content:"|55 04 03|"; distance:0; byte_test:1,>,13,1,relative;
				Проверяет наличие поля commonName в теме сертификата (OID 2.5.4.3).
				Следующий byte_test проверяет, что длина поля commonName больше 13.

			-	content:!"www."; distance:2; within:4; 


			-	pcre:"/^.{2}(?P<CN>(?:(?:\d?[A-Z]?|[A-Z]?\d?)(?:[a-z]{3,20}|[a-z]{3,6}[0-9_][a-z]{3,6})\.){0,2}?(?:\d?[A-Z]?|[A-Z]?\d?)[a-z]{3,}(?:[0-9_-][a-z]{3,})?\.(?!com|org|net|tv)[a-z]{2,9})[01].*?(?P=CN)[01]/Rs"; 
				

			-	content:!"|2a 86 48 86 f7 0d 01 09 01|"; 
				

			-	content:!"GoDaddy"; 

	Упомянутые OID (идентификаторы объектов) являются частью стандарта X.509 для PKI и используются для уникальной идентификации типов полей, содержащихся в сертификатах.

