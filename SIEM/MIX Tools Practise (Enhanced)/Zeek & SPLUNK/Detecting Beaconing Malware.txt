=====================================================================
* Введение *
************

Как Вы уже наверное значете, Zeek   -   обычно используется для тщательного изучения каждого бита трафика в сети, глубокого поиска любых признаков подозрительной или вредоносной активности.
Проще говоря, это такой же инструмент для анализа сетевого трафика, НО с другим (более узкоспециализированным) функционалом

Для подробной информции об общих и/или отличительных чертах Zeek от Wireshark, можно спросить ChatGPT или Google

!!! НО, очень часто Zeek используют для анализа пакетов собранных Wireshark (*.pcap)
    Поэтому, представленный ниже сценарий будет базироваться на анализе Zeek-ом некоторого *.pcap файла

Помимо взаимодействия с Zeek и Wireshark, будет также рассмотрено использование утилиты SPLUNK
Которая в свою очередь будет анализировать *.log файлы (это выжимка из *.pcap файла посредством Zeek/tShark) для отображения нужных результатов черех используемые фильтры

!!! Так как SPLUNK не работает на прямую с файлами типа *.pcap, то я КРАЙНЕ НАСТОЯТЕЛЬНО рекомендую ознакомиться с инструкцией по загрузки *.log файлов (каталогов) в базу данных SPLUNK

В данной презентации *.pcap файл уже был распарсен Zeek и все сформированные файлы были загружены в базу данных SPLUNK
Связанные материалы:

    -   PCAP-file           cobaltstrike_beacon.pcap
    -   Splunk Index:       cobaltstrike_beacon
    -   Splunk Sourcetupe:  bro:http:json

Также перед оптимизацие фильтра, сперва рекомендую провести SPLUNK анализ без каких-либо уточняющих параметров
Это позволит увидеть вам название используемых полей-заголовков, которые мотом можно будет использовать для более тонкой настройки фильтрации

=====================================================================
* Detecting Beaconing Malware *
*******************************

Malware beaconing — это метод, с которым мы часто сталкиваемся в наших расследованиях кибербезопасности.
Он относится к периодическому общению, инициируемому зараженными вредоносным ПО системами с их соответствующими серверами управления и контроля (C2).
Маячки, как правило, небольшие пакеты данных, отправляются с регулярными интервалами, подобно тому, как маяк отправляет регулярный сигнал.

При анализе Malware beaconing мы часто наблюдаем несколько различных шаблонов.
Интервалы маячкового ПО могут быть:

    -   фиксированными
    -   колебательными (немного отличаться от фиксированного шаблона) или
    -   следовать более сложному графику, основанному на конкретных целях вредоносного ПО.

Вы можете столкнуться с вредоносным ПО, которое использует различные протоколы для маячкового ПО, включая HTTP/HTTPS, DNS и даже ICMP (ping).

В этом обзоре мы сосредоточимся на обнаружении поведения Malware beaconing, связанного с широко известной структурой управления и контроля (C2), известной как Cobalt Strike (в конфигурации по умолчанию).

Теперь давайте рассмотрим, как можно определить Beaconing Malware с помощью Splunk и Zeek logs

    index="cobaltstrike_beacon" sourcetype="bro:http:json" 
        | sort 0 _time
        | streamstats current=f last(_time) as prevtime by src, dest, dest_port
        | eval timedelta = _time - prevtime
        | eventstats avg(timedelta) as avg, count as total by src, dest, dest_port
        | eval upper=avg*1.1
        | eval lower=avg*0.9
        | where timedelta > lower AND timedelta < upper
        | stats count, values(avg) as TimeInterval by src, dest, dest_port, total
        | eval prcnt = (count/total)*100
        | where prcnt > 90 AND total > 10

Данный фильтр выполняет поведенческий анализ для выявления систематически и регулярно происходящих HTTP-запросов, что может быть признаком Cobalt Strike Beacon (или другого malware beaconing)
Общая цель фильтра  -   обнаружить подозрительно регулярные HTTP-запросы между хостами (src → dest:port), характерные для C2-коммуникаций (Command & Control), как у Cobalt Strike Beacon.

Дело в том, что Cobalt Strike Beacon или другие RAT'ы часто стучатся к C2-серверу строго периодически (например, каждые 60 секунд).
Поэтому, подобный фильтр позволяет выявить аномально стабильную периодичность, что крайне нехарактерно для обычного HTTP-трафика.

Вот расшифровка ключевых моментов фильтра:

    -   sort
        Сортирует события на основе выбранных полей
        В нашем случае упорядочивает трафик по времени основе их временной метки (_time) и без лимита (0)

    -   streamstats & eval
        Добавление временных дельт
        В нашем случае для каждого события (src, dest, dest_port) вычисляет временную метку предыдущего события (prevtime).
        А также вычисляется разница во времени (timedelta) между текущим и предыдущим событием.
        Это определяет, как часто одно соединение повторяется.

    -   eventstats 
        Подсчёт среднего и общего количества
        В нашем случае вычисляет среднюю разницу во времени avg(timedelta) и общее количество событий (total) для каждой комбинации src, dest и dest_port.

    -   eval upper &  eval lower
        Расчёт допусков
        В нашем случае устанавливает верхний и нижний пределы для разницы во времени путем добавления 10%-ной разницы к среднему значению.
        Это нужно, чтобы выявить регулярность (почти одинаковые интервалы).

    -   where timedelta
        Фильтрация внутри заданного интервала
        В нашем случае фильтрует события, где разница во времени попадает в заданные верхний и нижний пределы.
        Фактически ищет периодические соединения, характерные для beacon'ов.

    -   stats
        В нашем случае подсчитывает количество событий и извлекает средний временной интервал для каждой комбинации src, dest, dest_port и total.

    -   eval prcnt
        В нашем случае вычисляет процент (prcnt) событий в пределах заданного временного интервала.,

    -   where prcnt
        В нашем случае фильтрует результаты, включая только те, где более 90% событий попадают в заданные временные интервалы, и общее количество событий превышает 10.
        Таким образом происходит исключение случайных шумов.

