=====================================================================
* Введение *
************

Как Вы уже наверное значете, Zeek   -   обычно используется для тщательного изучения каждого бита трафика в сети, глубокого поиска любых признаков подозрительной или вредоносной активности.
Проще говоря, это такой же инструмент для анализа сетевого трафика, НО с другим (более узкоспециализированным) функционалом

Для подробной информции об общих и/или отличительных чертах Zeek от Wireshark, можно спросить ChatGPT или Google

!!! НО, очень часто Zeek используют для анализа пакетов собранных Wireshark (*.pcap)
    Поэтому, представленный ниже сценарий будет базироваться на анализе Zeek-ом некоторого *.pcap файла

Помимо взаимодействия с Zeek и Wireshark, будет также рассмотрено использование утилиты SPLUNK
Которая в свою очередь будет анализировать *.log файлы (это выжимка из *.pcap файла посредством Zeek/tShark) для отображения нужных результатов черех используемые фильтры

!!! Так как SPLUNK не работает на прямую с файлами типа *.pcap, то я КРАЙНЕ НАСТОЯТЕЛЬНО рекомендую ознакомиться с инструкцией по загрузки *.log файлов (каталогов) в базу данных SPLUNK

В данной презентации *.pcap файл уже был распарсен Zeek и все сформированные файлы были загружены в базу данных SPLUNK
Связанные материалы:

    -   PCAP-file           cobaltstrike_exfiltration_http.pcap // cobaltstrike_exfiltration_httpы.pcap
    -   Splunk Index:       cobaltstrike_exfiltration_http      //  cobaltstrike_exfiltration_http
    -   Splunk Sourcetupe:  bro:http:json                       //  bro:conn:json

Также перед оптимизацие фильтра, сперва рекомендую провести SPLUNK анализ без каких-либо уточняющих параметров
Это позволит увидеть вам название используемых полей-заголовков, которые мотом можно будет использовать для более тонкой настройки фильтрации

=====================================================================
* Detecting Exfiltration (HTTP) *
*********************************

Эксфильтрация данных из тела запроса "POST" — это метод, который злоумышленники используют для извлечения конфиденциальной информации из скомпрометированной системы, маскируя ее под легитимный веб-трафик.
Он включает передачу украденных данных из скомпрометированной системы на внешний сервер, контролируемый злоумышленником, с помощью HTTP-запросов POST.
Поскольку запросы POST обычно используются для легитимных целей, таких как отправка форм и загрузка файлов, этот метод эксфильтрации данных может быть трудно обнаружить.

Чтобы извлечь данные, злоумышленники отправляют их как тело HTTP-запроса POST на свой сервер управления и контроля (C2).
Они часто используют, казалось бы, безобидные URL-адреса и заголовки для дальнейшей маскировки вредоносного трафика.
Сервер C2 получает запрос POST, извлекает данные из тела и декодирует или расшифровывает их для дальнейшего анализа и эксплуатации.

Чтобы обнаружить эксфильтрацию данных через тело POST, мы можем использовать инструменты сетевого мониторинга и анализа для агрегации всех данных, отправленных на определенные IP-адреса и порты.
Анализируя агрегированные данные, мы можем выявить закономерности и аномалии, которые могут указывать на попытки эксфильтрации данных.

В этом разделе мы будем отслеживать объем исходящего трафика из нашей сети на определенные IP-адреса и порты.
Если мы наблюдаем необычно большие или частые передачи данных в определенное место назначения, это может указывать на утечку данных.

Теперь давайте рассмотрим, как можно определить Exfiltration (HTTP) с помощью Splunk и Zeek logs

    index="cobaltstrike_exfiltration_http" sourcetype="bro:http:json" method=POST
        | stats sum(request_body_len) as TotalBytes by src, dest, dest_port
        | eval TotalBytes = TotalBytes/1024/1024

Этот фильтр используется для анализа HTTP POST-запросов, чтобы выявить возможную эксфильтрацию данных (например, при использовании Cobalt Strike). 
С его помощью может выявить:

    -   выявить подозрительные объемы POST-трафика;
    -   определить потенциальные жертвы (src) и C2-серверы (dest);
    -   увидеть, кто, куда и сколько данных передал.

Вот расшифровка ключевых моментов фильтра:

    -   eval TotalBytes = TotalBytes/1024/1024
        Переводит количество переданных байтов в мегабайты (MB) для удобства чтения.

=====================================================================
* Detecting Exfiltration (HTTPS) *
**********************************

Для https трафика все будет точно также, но с небольшими изменениями
Так как, https - это зашифрованный трафик, то и искать мы должны среди соответсвующих портов и сервисов
Как правило для https используется порт = 443, а service = ssl

Чтож, давайте составим фильтр, для определения IP-адрес, который был использован для эксфильтрации данных здайте поиск Splunk для определения утечки через HTTPSUse the "cobaltstrike_exfiltration_https" index and the "bro:conn:json" sourcetype. Create a Splunk search to identify exfiltration through HTTPS. Enter the identified destination IP as your answer.

    index="cobaltstrike_exfiltration_https" sourcetype="bro:conn:json" id.resp_p=443
        | where orig_bytes > 1000
        | stats sum(orig_bytes) as TotalBytesSent, sum(resp_bytes) as TotalBytesReceived, sum(orig_pkts) as TotalPktsSent by id.resp_h
        | eval Ratio = TotalBytesSent / (TotalBytesReceived +1)
        | sort by TotalBytesSent

*** В рельном случае, названия полей могут отличаться
    Поэтому, ОЧЕНЬ рекомендую, сперва запустить базовый фильтр (index="cobaltstrike_exfiltration_https" sourcetype="bro:conn:json"), для опреедления названия используемых полей

Итак, давайте разберем ключевые моменты фильтра

    -   dest_port == 443
        Фильтруем только HTTPS-трафик.
    
    -   bytes_sent > #####
        Предполагается, что эксфильтрация данных сопровождается большим объемом исходящего трафика
        Поэтому, значение переданных данных можно изменять (постепенно повышать), чтобы точно понять, какой IP адрес нам нужен

    -   eval Ratio = TotalBytesSent / (TotalBytesReceived +1)
        Показывает соотношение исходящего к входящему (может помочь выявить эксфильтрацию).
            
            *   Если значение ~ 1, это означает, что трафик в обе стороны примерно равный (обычное взаимодействие, например, загрузка страницы)
            *   Если значение << 1 (например, 0.1), это означает, что кто-то присылает больше, чем получает (возможно, клиент что-то скачивает)
            *   Если значение >> 1 (например, 10, 50, 100), это означает, что кто-то отправляет значительно больше, чем получает (возможная эксфильтрация данных)

