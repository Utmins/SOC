Переадресация портов — это метод, позволяющий нам перенаправлять запрос на связь с одного порта на другой.
Переадресация портов использует TCP в качестве основного уровня связи для обеспечения интерактивной связи для перенаправленного порта.
Однако для инкапсуляции перенаправленного трафика могут использоваться различные протоколы прикладного уровня, такие как SSH или даже SOCKS (не прикладной уровень).
Это может быть эффективно для обхода брандмауэров и использования существующих служб на вашем скомпрометированном хосте для перехода в другие сети.

Примечание: каждая сетевая диаграмма, представленная в этом модуле, предназначена для иллюстрации концепций, обсуждаемых в соответствующем разделе.
IP-адресация, показанная на диаграммах, не всегда будет точно соответствовать лабораторным средам.
Обязательно сосредоточьтесь на понимании концепции, и вы обнаружите, что диаграммы окажутся очень полезными!
После прочтения этого раздела обязательно снова обратитесь к изображению выше, чтобы закрепить концепции.

У нас есть наш атакующий хост (xxx.xxx.xxx.xxx) и целевой сервер Ubuntu (xxx.xxx.xxx.xxx), который мы скомпрометировали.
Мы просканируем целевой сервер Ubuntu с помощью Nmap для поиска открытых портов.

	<attacking_user_name>@<attacking_host_name>$ nmap -sT -p22,3306 <target_ip_address>
	
		PORT     STATE  SERVICE
		22/tcp   open   ssh
		3306/tcp closed mysql

Вывод Nmap показывает, что порт SSH открыт.

Чтобы получить доступ к службе MySQL, мы можем:

	-	либо подключиться по SSH к серверу и получить доступ к MySQL изнутри сервера Ubuntu
	-	либо перенаправить его на наш локальный хост на порт 1234 и получить к нему локальный доступ.

Преимущество локального доступа заключается в том, что если мы хотим выполнить удаленный эксплойт на службе MySQL, мы не сможем сделать это без переадресации порта.
Это связано с тем, что MySQL размещен локально на сервере Ubuntu на порту 3306.
Поэтому мы воспользуемся следующей командой для перенаправления нашего локального порта (1234) через SSH на сервер Ubuntu

	<attacking_user_name>@<attacking_host_name>$ ssh -L 1234:localhost:3306 <target_username>@<target_ip_address>

  		System load:             0.0
  		Usage of /:              30.4% of 13.72GB
  		Memory usage:            31%
  		Swap usage:              0%
  		Processes:               180
  		Users logged in:         0
  		IPv4 address for ens192: 10.129.202.64
  		IPv6 address for ens192: dead:beef::250:56ff:feb0:f3ea
  		IPv4 address for ens224: 172.16.5.129

	<target_username>@<MySQL_servername>$

Команда -L сообщает клиенту SSH запросить сервер SSH переслать все данные, которые мы отправляем через порт 1234, на localhost:3306 на сервере Ubuntu.
Сделав это, мы должны иметь возможность получить доступ к службе MySQL локально на порту 1234.

Как мы можем заметить, после ввода данной команды, наш терминал изменил строку ввода, на имя пользователя@сервера к которому мы подключились
Т.е. мы в данный момент находимся в MySQL серевере жертвы

Мы можем использовать Netstat или Nmap для запроса нашего локального хоста на порту 1234, чтобы проверить, была ли перенаправлена ​​служба MySQL
Это необходимо сделать из нового окна терминала, на нашем атакующем хосте

	<attacking_user_name>@<attacking_host_name>$ netstat -antp | grep 1234

		(Not all processes could be identified, non-owned process info
 		will not be shown, you would have to be root to see it all.)
		tcp        0      0 127.0.0.1:1234          0.0.0.0:*               LISTEN      6324/ssh            
		tcp6       0      0 ::1:1234                :::*                    LISTEN      6324/ssh 

Для второго подтверждения мы можем использовать nmap

	<attacking_user_name>@<attacking_host_name>$ nmap -v -sV -p1234 localhost

		PORT     STATE SERVICE VERSION
		1234/tcp open  mysql   MySQL 8.0.28-0ubuntu0.20.04.3

Аналогично, если мы хотим перенаправить несколько портов с сервера Ubuntu на ваш локальный хост, вы можете сделать это, включив аргумент local port:server:port в вашу команду ssh.
Например, приведенная ниже команда перенаправляет порт 80 веб-сервера Apache на локальный порт вашего атакующего хоста 8080

	<attacking_user_name>@<attacking_host_name>$ ssh -L 1234:localhost:3306 -L 8080:localhost:80 ubuntu@10.129.202.64

*************************************

Теперь, если вы введете ifconfig на хосте Ubuntu, вы обнаружите, что этот сервер имеет несколько сетевых карт:

	-	Одна подключена к нашему атакующему хосту (ens192)
	
			ens192: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        		inet 10.129.202.64  netmask 255.255.0.0  broadcast 10.129.255.255
        		inet6 fe80::250:56ff:feb0:f3ea  prefixlen 64  scopeid 0x20<link>
        		inet6 dead:beef::250:56ff:feb0:f3ea  prefixlen 64  scopeid 0x0<global>
        		ether 00:50:56:b0:f3:ea  txqueuelen 1000  (Ethernet)
        		RX packets 6649  bytes 529405 (529.4 KB)
        		RX errors 0  dropped 0  overruns 0  frame 0
        		TX packets 1975  bytes 158101 (158.1 KB)
        		TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

	-	Одна, взаимодействующая с другими хостами в другой сети (ens224)

			ens224: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        		inet 172.16.5.129  netmask 255.255.254.0  broadcast 172.16.5.255
        		inet6 fe80::250:56ff:feb0:ea68  prefixlen 64  scopeid 0x20<link>
        		ether 00:50:56:b0:ea:68  txqueuelen 1000  (Ethernet)
        		RX packets 548  bytes 40524 (40.5 KB)
        		RX errors 0  dropped 14  overruns 0  frame 0
        		TX packets 577  bytes 40134 (40.1 KB)
        		TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

	-	Интерфейс обратной связи (lo)

			lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        		inet 127.0.0.1  netmask 255.0.0.0
        		inet6 ::1  prefixlen 128  scopeid 0x10<host>
        		loop  txqueuelen 1000  (Local Loopback)
        		RX packets 4913  bytes 385901 (385.9 KB)
        		RX errors 0  dropped 0  overruns 0  frame 0
        		TX packets 4913  bytes 385901 (385.9 KB)
        		TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

В отличие от предыдущего сценария, где мы знали, к какому порту обращаться, в нашем текущем сценарии мы не знаем, какие службы находятся на другой стороне сети.
Таким образом, мы можем сканировать меньшие диапазоны IP-адресов в сети (172.16.5.1-200) или во всей подсети (172.16.5.0/23).
К сожалению, мы не можем выполнить это сканирование напрямую с нашего атакующего хоста, поскольку у него нет маршрутов к сети 172.16.5.0/23.
Для этого нам придется выполнить динамическую переадресацию портов и перенаправить наши сетевые пакеты через сервер Ubuntu.
Мы можем сделать это, запустив прослушиватель SOCKS на нашем локальном хосте (персональный атакующий хост или Pwnbox), а затем настроить SSH для пересылки этого трафика через SSH в сеть (172.16.5.0/23) после подключения к целевому хосту.

Это называется туннелированием SSH через прокси-сервер SOCKS.
SOCKS означает Socket Secure, протокол, который помогает взаимодействовать с серверами, где у вас есть ограничения брандмауэра.

В отличие от большинства случаев, когда вы инициируете соединение для подключения к сервису, в случае SOCKS начальный трафик генерируется клиентом SOCKS, который подключается к серверу SOCKS, контролируемому пользователем, который хочет получить доступ к сервису на стороне клиента.
После установки соединения сетевой трафик может быть направлен через сервер SOCKS от имени подключенного клиента.

Этот метод часто используется для обхода ограничений, накладываемых брандмауэрами, и позволяет внешнему субъекту обойти брандмауэр и получить доступ к сервису в среде, защищенной брандмауэром.
Еще одним преимуществом использования прокси-сервера SOCKS для поворота и пересылки данных является то, что прокси-серверы SOCKS могут поворачиваться, создавая маршрут к внешнему серверу из сетей NAT.
В настоящее время прокси-серверы SOCKS бывают двух типов:

	-	SOCKS4 не обеспечивает никакой аутентификации и поддержки UDP
	-	SOCKS5 обеспечивает это.

Давайте рассмотрим пример с изображения ниже, где у нас есть сеть 172.16.5.0/23, преобразованная с помощью NAT, к которой мы не можем получить прямой доступ.

На изображении выше атакующий хост запускает SSH-клиент и запрашивает у SSH-сервера разрешение на отправку некоторых TCP-данных через сокет ssh.
SSH-сервер отвечает подтверждением, а затем SSH-клиент начинает прослушивание на localhost:9050.
Все данные, которые вы здесь отправите, будут транслироваться по всей сети (172.16.5.0/23) через SSH.
Мы можем использовать следующую команду для выполнения этой динамической переадресации портов


	<attacking_user_name>@<attacking_host_name>$ ssh -D 9050 ubuntu@10.129.202.64

		System load:             0.0
  		Usage of /:              30.4% of 13.72GB
  		Memory usage:            32%
  		Swap usage:              0%
  		Processes:               180
  		Users logged in:         1
  		IPv4 address for ens192: 10.129.202.64
  		IPv6 address for ens192: dead:beef::250:56ff:feb0:f3ea
  		IPv4 address for ens224: 172.16.5.129

	<target_username>@<MySQL_servername>$

Аргумент -D запрашивает у сервера SSH включение динамической переадресации портов.
После включения нам понадобится инструмент, который может маршрутизировать пакеты любого инструмента через порт 9050.
Мы можем сделать это с помощью инструмента proxychains, который способен перенаправлять TCP-соединения через прокси-серверы TOR, SOCKS и HTTP/HTTPS, а также позволяет нам объединять в цепочку несколько прокси-серверов.
Используя proxychains, мы также можем скрыть IP-адрес запрашивающего хоста, поскольку принимающий хост будет видеть только IP-адрес опорного хоста.
Proxychains часто используется для принудительного прохождения TCP-трафика приложения через размещенные прокси-серверы, такие как прокси-серверы SOCKS4/SOCKS5, TOR или HTTP/HTTPS.

Чтобы сообщить proxychains, что мы должны использовать порт 9050, мы должны изменить файл конфигурации proxychains, расположенный в /etc/proxychains.conf.
Мы можем добавить socks4 127.0.0.1 9050 в последнюю строку, если его там еще нет.

Теперь, когда вы запустите Nmap с proxychains, используя команду ниже, она направит все пакеты Nmap на локальный порт 9050, который прослушивает наш SSH-клиент, который будет пересылать все пакеты по SSH в сеть 172.16.5.0/23.
*** К сожалению тестовый стенд показывал, что все хосты отключены (Nmap scan report for 172.16.5.1 [host down]), так что любезно воспользуемся скрином из руководства
	
	<attacking_user_name>@<attacking_host_name>$ proxychains nmap -v -sn 172.16.5.1-200

		...SNIP...
		Scanning 200 hosts [4 ports/host]
		|S-chain|-<>-127.0.0.1:9050-<><>-172.16.5.2:80-<--timeout
		|S-chain|-<>-127.0.0.1:9050-<><>-172.16.5.5:80-<><>-OK
		|S-chain|-<>-127.0.0.1:9050-<><>-172.16.5.6:80-<--timeout
		...SNIP...

Эта часть упаковки всех ваших данных Nmap с помощью proxychains и пересылки их на удаленный сервер называется туннелированием SOCKS.
Еще одно важное замечание, которое следует здесь запомнить, заключается в том, что мы можем выполнять только полное сканирование TCP-подключения (-sT) через proxychains.
Причина этого в том, что proxychains не могут понимать частичные пакеты.
Если вы отправляете частичные пакеты, такие как сканирование половинного подключения, это вернет неверные результаты. 
Мы также должны убедиться, что мы знаем о том факте, что проверки активности хоста могут не работать против целей Windows, поскольку брандмауэр Защитника Windows по умолчанию блокирует запросы ICMP (традиционные пинги).

Полное сканирование TCP-подключений без пинга во всем диапазоне сети займет много времени.
Поэтому в этом тестовом задании мы в первую очередь сосредоточимся на сканировании отдельных хостов или меньших диапазонов хостов, которые, как мы знаем, активны, что в данном случае будет хостом Windows по адресу 172.16.5.19.

	<attacking_user_name>@<attacking_host_name>$ proxychains nmap -v -sn 172.16.5.1-200

		...SNIP...
		Scanning 200 hosts [4 ports/host]
		|S-chain|-<>-127.0.0.1:9050-<><>-172.16.5.19:110-<--timeout
		|S-chain|-<>-127.0.0.1:9050-<><>-172.16.5.19:21-<--timeout
		|S-chain|-<>-127.0.0.1:9050-<><>-172.16.5.19:445-<><>-OK
		|S-chain|-<>-127.0.0.1:9050-<><>-1172.16.5.19:25-<--timeout
		|S-chain|-<>-127.0.0.1:9050-<><>-172.16.5.19:5900-<--timeout
		|S-chain|-<>-127.0.0.1:9050-<><>-172.16.5.19:139-<><>-OK
		|S-chain|-<>-127.0.0.1:9050-<><>-172.16.5.19:143-<--timeout
		|S-chain|-<>-127.0.0.1:9050-<><>-172.16.5.19:135-<><>-OK
		|S-chain|-<>-127.0.0.1:9050-<><>-172.16.5.19:993-<--timeout
		|S-chain|-<>-127.0.0.1:9050-<><>-172.16.5.19:995-<--timeout
		|S-chain|-<>-127.0.0.1:9050-<><>-172.16.5.19:3389-<><>-OK
		Discovered open port 3389/tcp on 172.16.5.19
		...SNIP...

Сканирование Nmap показывает несколько открытых портов, один из которых — порт RDP (3389).

Подобно сканированию Nmap, мы также можем направить msfconsole через proxychains для выполнения уязвимых сканирований RDP с использованием вспомогательных модулей Metasploit.
Мы можем запустить msfconsole с proxychains со вспомогательным модулем rdp_scanner, чтобы проверить, прослушивает ли хост во внутренней сети порт 3389.

	<attacking_user_name>@<attacking_host_name>$ proxychains msfconsole

		msf6 > search rdp_scanner

		Matching Modules
		================
   		#  Name                               Disclosure Date  Rank    Check  Description
   		-  ----                               ---------------  ----    -----  -----------
   		0  auxiliary/scanner/rdp/rdp_scanner                   normal  No     Identify endpoints speaking the Remote Desktop Protocol (RDP)


		msf6 > use 0
		msf6 auxiliary(scanner/rdp/rdp_scanner) > set rhosts 172.16.5.19
		rhosts => 172.16.5.19
		msf6 auxiliary(scanner/rdp/rdp_scanner) > run
			|S-chain|-<>-127.0.0.1:9050-<><>-172.16.5.19:3389-<><>-OK
			|S-chain|-<>-127.0.0.1:9050-<><>-172.16.5.19:3389-<><>-OK
			|S-chain|-<>-127.0.0.1:9050-<><>-172.16.5.19:3389-<><>-OK

		[*] 172.16.5.19:3389      - Detected RDP on 172.16.5.19:3389      (name:DC01) (domain:DC01) (domain_fqdn:DC01) (server_fqdn:DC01) (os_version:10.0.17763) (Requires NLA: No)
		[*] 172.16.5.19:3389      - Scanned 1 of 1 hosts (100% complete)
		[*] Auxiliary module execution completed

В нижней части вывода выше мы видим порт RDP, открытый с версией ОС Windows (os_version:10.0.17763).

В зависимости от уровня доступа, который у нас есть к этому хосту во время оценки, мы можем попытаться запустить эксплойт или войти в систему, используя собранные учетные данные.
Для этого модуля мы войдем в систему на удаленном хосте Windows через туннель SOCKS.
Это можно сделать с помощью xfreerdp. В нашем случае пользователь — victor, а пароль — pass@123

	<attacking_user_name>@<attacking_host_name>$ proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123

Команда xfreerdp потребует принятия сертификата RDP перед успешным установлением сеанса.
После его принятия у нас должен быть сеанс RDP, проходящий через сервер Ubuntu.