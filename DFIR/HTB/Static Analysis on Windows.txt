=====================================================================
* Static Analysis on Windows *
******************************

В этом сегменте мы сосредоточимся на воспроизведении некоторых задач статического анализа, которые мы выполняли на машине Linux, но на этот раз мы будем использовать машину Windows.
К счастью структура методов и их последовательность остается аналогична Linux

В области анализа вредоносных программ мы применяем метод, называемый статическим анализом, для тщательного изучения вредоносных программ без необходимости их выполнения.
Это включает в себя тщательное исследование кода, данных и структурных компонентов вредоносных программ, что служит важным предшественником для дальнейшего, более подробного анализа.

С помощью статического анализа мы стремимся извлечь основную информацию, которая включает:

	-	Тип файла
	-	Хэш файла
	-	Строки данных
	-	Встроенные элементы
	-	Информация об упаковщике
	-	Функции Импорта
	-	Функции Экспорта
	-	Код сборки

Вот примерная последовательность статического изучения вредоносного файла

	1)	Input Malware Sample
		2)	File Type
			3)	Malware Fingerprinting
				4)	Packer Detection (HASH Analysis)
					5)	String Extraction/Analysis
						6)	PE Header Information
							7)	Classification
								8)	Detection Rules

	+++++++++++++++++++++++++++++
	+ Identifying The File Type +
	+++++++++++++++++++++++++++++

	Наш первый порт вызова на этом этапе — выяснить элементарную информацию об образце вредоносного ПО, чтобы заложить основу для нашего расследования.
	Учитывая, что расширения файлов можно манипулировать и изменять, наша задача — разработать метод для определения фактического типа файла, с которым мы сталкиваемся.
	Установление типа файла играет неотъемлемую роль в статическом анализе, гарантируя, что применяемые нами процедуры являются подходящими, а полученные результаты — точными.

	Давайте используем вредоносное ПО на базе Windows с именем Ransomware.wannacry.exe
	Мы можем использовать решение, такое как CFF Explorer, чтобы проверить тип файла этого вредоносного ПО следующим образом.

	CFF Explorer	-	это инструмент, входящий в состав Explorer Suite, который может использоваться в PE-структуре исполняемого файла и разработан для максимального упрощения редактирования PE без потери внутренней структуры переносимого исполняемого файла.
	Ресурсы по CFF Explorer		-	https://cff-explorer.com/
						https://ntcore.com/explorer-suite/
						https://www.heaventools.com/torrypexplorer.htm?r1=torry
						https://community.chocolatey.org/packages/explorersuite
						https://www.threatdown.com/blog/five-pe-analysis-tools-worth-looking-at/						
	
	В системе Windows наличие ASCII-строки MZ (в шестнадцатеричном формате: 4D 5A) в начале файла (известной как «магическое число») обозначает исполняемый файл.
	MZ означает Марка Збиковски, ключевого архитектора MS-DOS.
				
	++++++++++++++++++++++++++
	+ Malware Fingerprinting +
	++++++++++++++++++++++++++

	На этом этапе наша задача — создать уникальный идентификатор для образца вредоносного ПО.
	Обычно это криптографический хэш — MD5, SHA1 или SHA256.

	Отпечатки пальцев используются для множества целей, включая:

		-	Идентификацию и отслеживание образцов вредоносного ПО

		-	Сканирование всей системы на наличие идентичного вредоносного ПО

		-	Подтверждение предыдущих встреч и анализ того же вредоносного ПО

		-	Обмен с заинтересованными сторонами в качестве IoC (индикаторов компрометации) или как часть отчетов по разведке угроз

	В качестве иллюстрации, для проверки MD5-хэша файла вышеупомянутой вредоносной программы используем следующую комнаду

		PS C:\Users\<User_Name> Get-FileHash -Algorithm MD5 C:\folder\where\you\keep\your\malware_samples\for_analysis\Ransomware.wannacry.exe

		Algorithm       Hash                                                                   Path
		---------       ----                                                                   ----
		MD5             DB349B97C37D22F5EA1D1841E3C89EB4                                       C:\Samples\MalwareAnalysis\Ra...

	***	Для хеша типа SHA используется аналогичная команда - sha256sum

	++++++++++++++++++++
	+ File Hash Lookup +
	++++++++++++++++++++

	Следующий шаг включает проверку хеша файла, полученного на предыдущем шаге, с помощью онлайн-сканеров вредоносных программ и песочниц, таких как Cuckoo sandbox.
	Например, VirusTotal, онлайн-движок сканирования вредоносных программ, который сотрудничает с различными поставщиками антивирусов, позволяет нам искать хеш файла.
	Этот шаг помогает нам сравнивать наши результаты с имеющимися знаниями об образце вредоносного ПО.

	Несмотря на то, что хэш файла, такой как MD5, SHA1 или SHA256, полезен для идентификации идентичных образцов с разными именами, он не подходит для идентификации похожих образцов вредоносного ПО.
	Это в первую очередь связано с тем, что автор вредоносного ПО может изменить значение хэша файла, внеся незначительные изменения в код и перекомпилировав его.

	Тем не менее, существуют методы, которые могут помочь в идентификации похожих образцов:

		////////////////////////////////
		/// Import Hashing (IMPHASH) ///
		////////////////////////////////

		IMPHASH, сокращение от «Import Hash», представляет собой криптографический хеш, вычисляемый из функций импорта файла Windows Portable Executable (PE).
		Его алгоритм работает следующим образом:

			i.	сначала все импортированные имена функций преобразуются в нижний регистр
			ii.	после этого имена DLL и функции объединяются и располагаются в алфавитном порядке
			iii.	наконец, из полученной строки генерируется хеш MD5.

		Таким образом, два файла PE с идентичными функциями импорта в той же последовательности будут иметь общее значение IMPHASH.
		IMPHASH может быть найден на вкладке Details результатов VirusTotal.

		Мы также можем использовать модуль Python	-	pefile, для вычисления IMPHASH файла следующим образом.
		pefile	-	https://github.com/erocarrera/pefile
				https://pypi.org/project/pefile/
				https://pefile.readthedocs.io/en/latest/

		Вот как выглядит код

			import sys
			import pefile
			import peutils

			pe_file = sys.argv[1]
			pe = pefile.PE(pe_file)
			imphash = pe.get_imphash()

			print(imphash)

		Чтобы проверить IMPHASH вышеупомянутого вредоносного ПО WannaCry, команда будет следующей.
		***	Вы можете сохранить вышеуказанный код как 	-	imphash_calc.py и использовать его припроверке

			C:\Users\<User_Name> python imphash_calc.py C:\folder\where\you\keep\your\malware_samples\for_analysis\Ransomware.wannacry.exe

			9ecee117164e0b870a53dd187cdd7174

		//////////////////////////////
		/// Fuzzy Hashing (SSDEEP) ///
		//////////////////////////////
	
		"Неопределенное" (fuzzy) хеширование (SSDEEP), также называемое кусочно-контекстно-активируемым хешированием (context-triggered piecewise hashing - CTPH), представляет собой метод хеширования, предназначенный для вычисления значения хеш-функции, указывающего на схожесть содержимого двух файлов.
		Этот метод разделяет файл на более мелкие блоки фиксированного размера и вычисляет хеш-функцию для каждого блока.
		Полученные значения хеш-функции затем объединяются для создания окончательного "неопределнного" (fuzzy) хеша.

		Алгоритм SSDEEP выделяет больший вес более длинным последовательностям общих блоков, что делает его высокоэффективным при идентификации файлов, которые подверглись незначительным изменениям или похожи, но не идентичны, например, различные вариации вредоносного образца.

		Мы можем найти хеш SSDEEP вредоносной программы на вкладке «Details» результатов VirusTotal.

		Мы также можем использовать команду ssdeep для вычисления хеша SSDEEP файла.
		Чтобы проверить хеш SSDEEP вышеупомянутой вредоносной программы WannaCry, команда будет следующей
		*** Данную утилиту стоит запускать из папки, где она находится или указывать путь до нее, так как она не предустановленна и/или не забиндина с переменной

			C:\Users\<User_Name> ssdeep.exe C:\folder\where\you\keep\your\malware_samples\for_analysis\Ransomware.wannacry.exe

			ssdeep,1.1--blocksize:hash:hash,filename
			98304:wDqPoBhz1aRxcSUDk36SAEdhvxWa9P593R8yAVp2g3R:wDqPe1Cxcxk3ZAEUadzR8yc4gB,"C:\folder\where\you\keep\your\malware_samples\for_analysis\Ransomware.wannacry.exe"

		После получения результат, Вы можеет сравнить его с базой данных того же VirusTotal

		/////////////////////////////////////////////
		/// Section Hashing (Hashing PE Sections) ///
		/////////////////////////////////////////////

		Хэширование разделов (hashing PE sections) — это мощный метод, позволяющий аналитикам идентифицировать разделы файла Portable Executable (PE), которые были изменены.
		Это может быть особенно полезно для выявления незначительных изменений в образцах вредоносного ПО, что является распространенной тактикой, используемой злоумышленниками для уклонения от обнаружения.
		Это может помочь идентифицировать похожие образцы вредоносного ПО, даже если они были немного изменены, чтобы обойти традиционные методы обнаружения на основе сигнатур.

		Применяя хэширование разделов, аналитики безопасности могут идентифицировать части файла PE, которые были подделаны или изменены.
		Метод хэширования разделов работает путем вычисления криптографического хеша каждого из этих разделов.
		При сравнении двух файлов PE, если хэш соответствующих разделов в двух файлах совпадает, это говорит о том, что конкретный раздел не был изменен между двумя версиями файла.

		Такие инструменты, как pefile в Python, можно использовать для выполнения хэширования разделов.
		Например, в Python можно использовать модуль pefile и следующий код для доступа к данным в отдельных разделах PE-файла и их хеширования следующим образом.


			import sys
			import pefile
			import peutils

			pe_file = sys.argv[1]
			pe = pefile.PE(pe_file)
		
			imphash = pe.get_imphash()
			print(imphash)

			for section in pe.sections:
    				print (section.Name, "MD5 hash:", section.get_hash_md5())
    				print (section.Name, "SHA256 hash:", section.get_hash_sha256())

		Мы конечно можем сохранить данный код в отдельном файле (к примеру с именем	-	section_hashing.py)
		А можем вставить его в скрипт проверки ImpHash и тем самым проверять 2-в-1 (и именовать данный скрипт как	-	section_and_imphash.py)

			import sys
			import pefile
			import peutils

			pe_file = sys.argv[1]
			pe = pefile.PE(pe_file)

			imphash = pe.get_imphash()
			print ("ImpHash is\n",imphash)

			print ("\nSection HASHes:")

			pe_file = sys.argv[1]
			pe = pefile.PE(pe_file)
			for section in pe.sections:
    			print (section.Name, "MD5 hash:", section.get_hash_md5())
    			print (section.Name, "SHA256 hash:", section.get_hash_sha256())

		Помните, что хотя хеширование разделов является мощным методом, оно не является надежным.
		Авторы вредоносных программ могут использовать такие приемы, как запутывание имен разделов или динамическое создание имен разделов, чтобы попытаться обойти этот тип анализа.

	+++++++++++++++++++
	+ String Analysis +
	+++++++++++++++++++

	На этом этапе наша цель — извлечь строки (ASCII и Unicode) из двоичного файла.
	Строки могут предоставить подсказки и ценную информацию о функциональности вредоносного ПО.
	Иногда мы можем обнаружить уникальные встроенные строки в образце вредоносного ПО, такие как:

		-	Встроенные имена файлов (например, перенесенные файлы)
		-	IP-адреса или доменные имена
		-	Пути или ключи реестра
		-	Функции API Windows
		-	Аргументы командной строки
		-	Уникальная информация, которая может указывать на конкретного субъекта угрозы

	Команда Linux strings может быть развернута для отображения строк, содержащихся во вредоносном ПО.
	Используем данную команду для отображения информации по другому вредоносному файлу (программа-вымогатель)	-	dharma_sample.exe
	***	Данная утилита явялется частью набора Sysinternals и будет доступна без прямого ображения к ней, если Sysinternal был установден до этого
		
		C:\Users\<User_Name> strings C:\folder\where\you\keep\your\malware_samples\for_analysis\dharma_sample.exe

		Strings v2.54 - Search for ANSI and Unicode strings in binary images.
		Copyright (C) 1999-2021 Mark Russinovich
		Sysinternals - www.sysinternals.com

		!This program cannot be run in DOS mode.
		gaT
		Rich
		.text
		`.rdata
		@.data
		HQh
		9A s
		9A$v
		---SNIP---
		GetProcAddress
		LoadLibraryA
		WaitForSingleObject
		InitializeCriticalSectionAndSpinCount
		LeaveCriticalSection
		GetLastError
		EnterCriticalSection
		ReleaseMutex
		CloseHandle
		KERNEL32.dll
		RSDS%~m
		#ka
		C:\crysis\Release\PDB\payload.pdb
		---SNIP---

	Иногда анализ строк может облегчить привязку образца вредоносного ПО к определенной группе угроз, если выявлены существенные сходства.
	Например, в предоставленной ссылке строка, содержащая путь PDB, использовалась для привязки образца вредоносного ПО к семейству программ-вымогателей Dharma/Crysis.

	Следует отметить, что существует еще одно решение для анализа строк, называемое FLOSS.
	FLOSS, сокращение от "FireEye Labs Obfuscated String Solver", — это инструмент, разработанный командой FireEye FLARE для автоматической деобфускации строк во вредоносных программах.
	Он разработан в дополнение к использованию традиционных инструментов для работы со строками, таких как команда strings в системах на базе Unix, которая может пропускать обфусцированные строки, которые обычно используются вредоносными программами для обхода обнаружения.
	***	Данная утилита может быть уже встроена в Вашу ОС
		Тем не менее не лишним будет сперва проверить ее наличие и установить при неоходимости

		C:\Users\<User_Name> floss C:\folder\where\you\keep\your\malware_samples\for_analysis\dharma_sample.exe

		INFO: floss: extracting static strings...
		finding decoding function features: 100%|█████████████████| 238/238 [00:00<00:00, 982.94 functions/s, skipped 5 library functions (2%)]
		INFO: floss.stackstrings: extracting stackstrings from 223 functions
		INFO: floss.results: %sh(                                                                                                                                                                     
		extracting stackstrings: 100%|█████████████████████████████| 223/223 [00:01<00:00, 137.22 functions/s]
		INFO: floss.tightstrings: extracting tightstrings from 10 functions...
		extracting tightstrings from function 0x4065e0: 100%|███████████████████| 10/10 [00:01<00:00,  7.20 functions/s]
		INFO: floss.string_decoder: decoding strings
		INFO: floss.results: EEED                                                                                                                                                                     
		INFO: floss.results: EEEDnnn                                                                                                                                                                  
		INFO: floss.results: uOKm                                                                                                                                                                     
		INFO: floss.results: %sh(                                                                                                                                                                     
		INFO: floss.results: uBIA                                                                                                                                                                     
		INFO: floss.results: uBIA                                                                                                                                                                     
		INFO: floss.results: \t\t\t\t\t\t\t\t                                                                                                                                                         
		emulating function 0x405840 (call 4/9): 100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████| 25/25 [00:12<00:00,  2.05 functions/s]
		INFO: floss: finished execution after 23.81 seconds

		FLARE FLOSS RESULTS (version v2.0.0-0-gdd9bea8)
	
		+------------------------+------------------------------------------------------------------------------------+
		| file path              | /home/htb-student/Samples/MalwareAnalysis/dharma_sample.exe                        |
		| extracted strings      |                                                                                    |
		|  static strings        | 720                                                                                |
		|  stack strings         | 1                                                                                  |
		|  tight strings         | 0                                                                                  |
		|  decoded strings       | 7                                                                                  |
		+------------------------+------------------------------------------------------------------------------------+

		------------------------------
		| FLOSS STATIC STRINGS (720) |
		------------------------------
		-----------------------------
		| FLOSS ASCII STRINGS (716) |
		-----------------------------
		!This program cannot be run in DOS mode.
		Rich
		.text
		`.rdata
		@.data
		9A s
		9A$v
		...SNIP...
		+o*7
		0123456789ABCDEF

		------------------------------
		| FLOSS UTF-16LE STRINGS (4) |
		------------------------------
		jjjj
		%sh(
		ssbss
		0123456789ABCDEF

		---------------------------
		| FLOSS STACK STRINGS (1) |
		---------------------------
		%sh(

		---------------------------
		| FLOSS TIGHT STRINGS (0) |
		---------------------------

		-----------------------------
		| FLOSS DECODED STRINGS (7) |
		-----------------------------
		EEED
		EEEDnnn
		uOKm
		%sh(
		uBIA
		uBIA
		\t\t\t\t\t\t\t\t

	***	Ваш вывод может отличаться

	++++++++++++++++++++++++++++++++
	+ Unpacking UPX-packed Malware +
	++++++++++++++++++++++++++++++++

	В нашем статическом анализе мы можем наткнуться на образец вредоносного ПО, который был сжат или обфусцирован с помощью техники, называемой упаковкой.
	Упаковка служит нескольким целям:

		-	Она запутывает код, что затрудняет распознавание его структуры или функциональности.

		-	Она уменьшает размер исполняемого файла, что ускоряет его передачу или делает его менее заметным.

		-	Она сбивает с толку исследователей безопасности, затрудняя традиционные попытки обратного проектирования.

	Это может ухудшить анализ строк, поскольку ссылки на строки обычно скрываются или устраняются.
	Она также заменяет или маскирует обычные разделы PE компактной заглушкой загрузчика, которая извлекает исходный код из сжатого раздела данных.
	В результате файл вредоносного ПО становится меньше и его сложнее анализировать, поскольку исходный код не виден напрямую.

	Популярным упаковщиком, используемым во многих вариантах вредоносного ПО, является Ultimate Packer for Executables (UPX).
	Ultimate Packer for Executables (UPX)	-	https://upx.github.io/
							https://github.com/upx/upx							

	Давайте сначала посмотрим, что произойдет, если мы запустим команду strings для упакованного с помощью UPX образца вредоносного ПО с именем credential_stealer.exe

		C:\Users\<User_Name> string C:\folder\where\you\keep\your\packed_malware_samples\for_analysis\credential_stealer.exe
		
		Strings v2.54 - Search for ANSI and Unicode strings in binary images.
		Copyright (C) 1999-2021 Mark Russinovich
		Sysinternals - www.sysinternals.com
		
		!This program cannot be run in DOS mode.
		UPX0
		UPX1
		UPX2
		3.96
		UPX!
		8MZu
		HcP<H
		VDgxt
		$ /uX
		OAUATUWVSH
		%0rv
		o?H9
		c`fG
		[^_]A\A]
		> -P
			fo{Wnl
		c9"^$!=
		v/7>
		07ZC
		_L$AAl
		mug.%(
		#8%,X
		e]'^

	А вот что покажет утилои strings для обычного (не упаковоннаго) вредоносного файла

		C:\Users\<User_Name> string C:\folder\where\you\keep\your\unpacked_malware_samples\for_analysis\credential_stealer.exe
		!This program cannot be run in DOS mode.
		.text
		P`.data
		.rdata
		`@.pdata
		0@.xdata
		0@.bss
		.idata
		.CRT
		.tls
		8MZu
		HcP<H
		D$ H
		AUATUWVSH
		D$ L
		[^_]A\A]
		[^_]A\A]
		ATUWVSH
		0[^_]A\
		L$(A
		H3t$(
		0[^_]A\
		UVSH

	Как можно заметить - заголовки разделов разительно отличаются (UPX# vs .<header>)

	Обратите внимание на строки, включающие UPX, и обратите внимание, что остальная часть вывода не дает никакой ценной информации о функциональности вредоносного ПО.
	Мы можем распаковать вредоносное ПО с помощью инструмента UPX с помощью следующей команды (можно находиться там, где хранятся упакованные образцы вредоносного ПО, или указать путь к данному каталогу

		<user_name>@<host_name>$ upx -d -o unpacked_<malware_filename>.exe <malware_filename>.exe

	        	               Ultimate Packer for eXecutables
        	        	          Copyright (C) 1996 - 2020
		UPX 3.96        Markus Oberhumer, Laszlo Molnar & John Reiser   Jan 23rd 2020

		        File size         Ratio      Format      Name
		   --------------------   ------   -----------   -----------
		     16896 <-      8704   51.52%    win64/pe     unpacked_credential_stealer.exe
	
		Unpacked 1 file.
		