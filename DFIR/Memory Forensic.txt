=====================================================================
* Введение *
************

В кибербезопасности криминалистика памяти — это подмножество компьютерной криминалистики, которая анализирует энергозависимую память, обычно на скомпрометированной машине
В ОС Windows она соответствует оперативной памяти (ОЗУ), и ее содержимое сбрасывается при каждой перезагрузке или выключении, что делает ее одной из обычных начальных задач, выполняемых во время инцидента.
Процесс отличается от анализа криминалистики диска, поскольку он не только предоставляет информацию о том, что находится на целевом компьютере
Но и предоставляет нам информацию о процессах или приложениях, которые были запущены в определенное время
А также подробную информацию о потоке выполнения в системе, которая может отсутствовать в обычных единицах хранения или журналах приложений.

Этот анализ памяти может помочь нам с немедленным снимком приложения или временной меткой действий злоумышленника.
Это имеет решающее значение, поскольку доказательства, собранные с помощью криминалистики памяти, могут стать бесценными при создании хронологии событий.

Мы можем разделить задачи в задаче криминалистического анализа памяти на два основных этапа:

    1)  Memory Acquisition (сбор памяти)
    2)  Memory Analysis (анализ памяти)

    ++++++++++++++++++++++
    + Memory Acquisition +
    ++++++++++++++++++++++

    На этапе сбора памяти мы копируем активную память в файл, обычно называемый дампом,
    Это делается для того, чтобы выполнить анализ без риска потери данных из-за непреднамеренной перезагрузки скомпрометированной системы и получить доказательства анализа, в том числе по мере необходимости.

    Есть несколько инструментов, которые могут нам помочь в получении дампа памяти с целевой машины, но какой из них использовать, будет зависеть от личных предпочтений и ОС, задействованной в задаче создания образа.
    Вот некоторые из этих инструментов:

        Windows     FTK imager, WinPmem
        Linux       LIME
        macOS       osxpmem
    
    Мы остановимся на использовании FTK image
    А для анализа дампа мы будем использовать Volatility 3

    Чтобы посмотреть какие модули для анализа дампа посредством Volatility будут нам доступны, необходимо ввести следующую команду
    А так как дам был собран с машины по управлением Windows, то и указывать мы должны Windos, независимо от того в какой среде работаем

        ~$: vol windows --help
    
    Плагины чрезвычайно полезны во время анализа при использовании Volatility3
    Поскольку они быстро анализируют дамп памяти для определенных типов данных и сортируют данные в соответствии с выбранным плагином.
    Ниже предлставленна сводка некоторых наиболее релевантных плагинов:

        Windows.cmdline             Список аргументов командной строки процесса
        windows.drivermodule        Определяет, были ли скрыты загруженные драйверы руткитом
        Windows.filescan            Сканирует на наличие файловых объектов, присутствующих в определенном образе памяти Windows
        Windows.getsids             Печать идентификаторов безопасности, владеющих каждым процессом
        Windows.handles             Список открытых дескрипторов процесса
        Windows.info                Показывает сведения об ОС и ядре анализируемого образца памяти
        Windows.netscan             Сканирует на наличие сетевых объектов, присутствующих в определенном образе памяти Windows
        Widnows.netstat             Проходит по структурам отслеживания сети, присутствующим в определенном образе памяти Windows.
        Windows.mftscan             Сканирует на наличие альтернативного потока данных
        Windows.pslist              Список процессов, присутствующих в определенном образе памяти Windows
        Windows.pstree              Список процессов в дереве на основе идентификатора родительского процесса

    +++++++++++++++++++
    + Memory Analysis +
    +++++++++++++++++++
    
    Получение информации о цели имеет решающее значение для расследования, поскольку это гарантирует, что мы анализируем правильный контекст и среду доказательств.
    Этот шаг помогает нам понять конкретную архитектуру и операционные системы, гарантируя точность, релевантность и легитимность наших выводов.

    Мы можем получить информацию о цели, используя ключ -f, чтобы указать файл для анализа <filename.mem> (в нашем случае memdump.mem), за которым следует плагин windows.info, используемый для получения общей информации

        ~$: vol -f memdump.mem windows.info
                Volatility 3 Framework 2.5.2
                Progress:  100.00PDB scanning finished                        
                VariableValue

                Kernel Base  0xf9066161c000
                DTB   0x1ac000
                Symbolsfile:    ///home/analyst/volatility3-2.5.2/volatility3/symbols/windows/ntkrnlmp.pdb/4DBE144182FF4156845CD3BD8B65
                4E56-1.json.xz
                Is64Bit   False
                IsPAE   False
                layer_name   0 WindowsIntel32e
                memory_layer   1 FileLayer
                KdVersionBlock   0xf8066222a400
                Major/Minor   15.19041
                MachineType   34404
                KeNumberProcessors   2
                SystemTime   2024-02-24 22:52:52
                NtSystemRoot   C:\Windows
                NtProductType   NtProductWinNt
                NtMajorVersion   7
                NtMinorVersion   0
                PE MajorOperatingSystemVersion   10
                PE MinorOperatingSystemVersion   0
                PE Machine   34404
                PE TimeDateStamp   Sat Jan 13 03:45:32 2085
    
    Вывод показывает соответствующую информацию для идентификации машины, над которой мы работаем, такую ​​как архитектура, количество процессоров и версия.
    Все это может помочь нам сопоставить информацию и данные с другими анализами, выполненными на отдельном оборудовании скомпрометированной машины или самой сети
    При этом имея доказательства того, что это именно та машина, которая была скомпрометирована.

=====================================================================
* Searching for Suspicious Activity *
*************************************

После того, как мы выяснили первоначально-необходимыую информацию о цели, можно попробоватьидентифицировать любую подозрительную активность в дампе памяти.

Подозрительная активность относится к техническим аномалиям, которые могут присутствовать в системе, таким как неожиданные процессы, необычные сетевые подключения или изменения реестра.
Эти действия часто сигнализируют о потенциальных угрозах безопасности, таких как атаки вредоносного ПО или утечки данных.

Начать поиск можно с любо1 оласти дампа
Мы же начнем с наблюдения за любой потенциальной сетевой активностью.
Для этого мы используем плагин windows.netstat, чтобы увидеть, есть ли интересное или необычное подключение.
На этом этапе следует искать подключения удаленного доступа или доступ к подозрительным сайтам.
Как правило такие соединения имеют статус   -   ESTABLISHED (но не факт, так что проверять сетевые адреса тоже может понадобиться)

    ~$: vol -f memdump.mem windows.netstat
            Volatility 3 Framework 2.5.2
            Progress:  100.00PDB scanning finished                        
            
            Offset          Proto   LocalAddr           LocalPort       ForeignAddr         ForeignPort     State           PID     Owner               Created

            0xe50ed9170ac0  TCPv4   192.168.182.139     49723           192.16.49.85        80              CLOSE_WAIT      4780    SearchApp.exe       2024-02-24 22:48:49.000000 
            0xe50ed8a4ca20  TCPv4   192.168.182.139     49814           52.142.223.178      443             SYN_SENT        368     svchost.exe         2024-02-24 22:52:43.000000 
            0xe50ed9275a20  TCPv4   192.168.182.139     3389            192.168.182.150     49253           ESTABLISHED     744     svchost.exe         2024-02-24 22:47:52.000000 
            0xe50ed9df3a20  TCPv4   192.168.182.139     49745           13.107.213.254      443             CLOSE_WAIT      4780    SearchApp.exe       2024-02-24 22:50:42.000000 
            0xe50ed8c52a20  TCPv4   192.168.182.139     49719           23.222.237.202      443             CLOSE_WAIT      4780    SearchApp.exe       2024-02-24 22:48:47.000000 
            0xe50ed9427a20  TCPv4   192.168.182.139     49694           20.7.1.246          443             ESTABLISHED     368     svchost.exe         2024-02-24 22:47:54.000000 
            0xe50ed83ea4d0  TCPv4   192.168.182.139     49743           23.222.237.203      443             CLOSE_WAIT      4780    SearchApp.exe       2024-02-24 22:50:39.000000 
            0xe50edac57a20  TCPv4   192.168.182.139     49712           152.199.55.200      443             CLOSE_WAIT      4780    SearchApp.exe       2024-02-24 22:48:06.000000 
            0xe50ed9508a20  TCPv4   192.168.182.139     49744           23.222.237.203      443             CLOSE_WAIT      4780    SearchApp.exe       2024-02-24 22:50:39.000000 

Как мы можем наблюдать установленное соединение на порту 3389 с IP 192.168.182.139 с временной меткой 2024-02-24 22:47:52.00
Это может указывать на первоначальный доступ злоумышленника.

Теперь, когда у нас есть информация о сети, давайте рассмотрим процессы.
Плагин для изменчивости, который мы можем использовать, — это windows.pstree, который отобразит дерево процесса, запущенного в ОС.

    ~$: vol -f memdump.mem windows.pstree
            Volatility 3 Framework 2.5.2
            Progress:  100.00PDB scanning finished                        
            
            PID         PPID    ImageFileName       Offset(V)           Threads         Handles     SessionId   Wow64       CreateTime                      ExitTime

            4           0       System              0xe50ed3687040      150             -           N/A         False       2024-02-24 22:47:35.000000      N/A
            * 312       4       smss.exe            0xe50ed68b0040      2               -           N/A         False       2024-02-24 22:47:35.000000      N/A
            * 600       4       MemCompression      0xe50ed379e280      50              -           N/A         False       2024-02-24 22:47:36.000000      N/A
            * 92        4       Registry            0xe50ed36ed080      4               -           N/A         False       2024-02-24 22:47:31.000000      N/A
            424         400     csrss.exe           0xe50ed67d7140      9               -           0           False       2024-02-24 22:47:35.000000      N/A
            500         400     wininit.exe         0xe50ed7366080      2               -           0           False       2024-02-24 22:47:35.000000      N/A
            * 664       500     lsass.exe           0xe50ed7360080      8               -           0           False       2024-02-24 22:47:35.000000      N/A
            * 776       500     fontdrvhost.ex      0xe50ed7c69140      6               -           0           False       2024-02-24 22:47:35.000000      N/A
            * 636       500     services.exe        0xe50ed73d3080      6               -           0           False       2024-02-24 22:47:35.000000      N/A
            ** 896      636     svchost.exe         0xe50ed7d112c0      9               -           0           False       2024-02-24 22:47:36.000000      N/A
            ** 1924     636     svchost.exe         0xe50ed73ab2c0      5               -           0           False       2024-02-24 22:47:36.000000      N/A
            ** 3464     636     svchost.exe         0xe50ed88e3080      7               -           1           False       2024-02-24 22:47:39.000000      N/A
            ** 7312     636     SecurityHealth      0xe50ed9af1280      10              -           0           False       2024-02-24 22:47:56.000000      N/A
            ** 2964     636     dllhost.exe         0xe50ed858d280      14              -           0           False       2024-02-24 22:47:37.000000      N/A
            ** 3348     636     svchost.exe         0xe50ed8b722c0      6               -           0           False       2024-02-24 22:47:39.000000      N/A
            ** 7060     636     WUDFHost.exe        0xe50ed9ad41c0      9               -           0           False       2024-02-24 22:47:53.000000      N/A
            ** 792      636     svchost.exe         0xe50ed7c85240      13              -           0           False       2024-02-24 22:47:35.000000      N/A
            **** 1648   7960    critical_updat      0xe50ed94c1080      5               -           1           False       2024-02-24 22:51:50.000000      N/A
            ***** 1612  1648    updater.exe         0xe50edab53080      6               -           1           False       2024-02-24 22:51:50.000000      N/A

Как мы можем видеть из вышеприведенного вывода, команда предоставляет нам информацию о процессах, иерархически запущенных в системе, указывая нам процесс и соответствующий ему родительский процесс.
В этом случае Services.exe является родительским процессом dllhost.exe

Но как мы можем идентифицировать подозрительный процесс?
Один из наиболее распространенных способов — проверить имя процесса
Cубъекты угроз обычно используют имена, чтобы попытаться замаскировать выполнение.
Один из способов сделать это — проверить, что этот процесс обычно не присутствует (гугл в помощь)

Учитывая вышеизложенное и снова взглянув на вывод, мы можем наблюдать процесс с усеченным именем critical_updat.
Этот процесс не выглядит как часть системы, и при детальном рассмотрении он является родительским процессом updater.exe, который также не указан как часть процесса ОС Windows.
Отлично. Мы идентифицируем возможный вредоносный процесс и должны отметить информацию, такую ​​как временная метка, PID, PPID и смещение памяти.

Используя собранную нами информацию, мы можем исследовать процесс critical_updat, который мы идентифицировали и у которого есть дочерний процесс, называемый updater.
Давайте более подробно рассмотрим дочерний процесс.

Начнем с того, что посмотрим, где на диске он был сохранен
Для этого мы можем использовать плагин windows.filescan, который позволит нам изучить файлы, к которым был получен доступ и которые хранятся в дампе памяти.
Этот вывод довольно большой, поэтому для лучшего доступа к данным мы будем использовать символ > в bash, чтобы перенаправить вывод в файл, в данном случае filescan_out.

    ~$: vol -f memdump.mem windows.filescan > filescan_out

После выполнения команды мы можем проверить данные с помощью cat и отфильтровать с помощью команды grep, как показано ниже.

    ~$: cat filescan_out | grep updater
            0xe50ed736e8a0\Users\user01\Documents\updater.exe216
            0xe50ed846fc60\Program Files (x86)\Microsoft\EdgeUpdate\1.3.185.17\msedgeupdateres_en.dll216
            0xe50ed8482d10\Program Files (x86)\Microsoft\EdgeUpdate\1.3.185.17\msedgeupdateres_en.dll216

Выше мы можем заметить, что файлы были сохранены в каталоге \Users\user01\Documents\updater.exe или C:\Users\user01\Documents\updater.exe

Если мы хотим получить более подробную информацию, например, когда файл был доступен или изменен, мы можем использовать плагин windows.mftscan.
MFTScan, вывод которого также довольно большой, поэтому мы перенаправим вывод в файл mftscan_out, как показано ниже.

    ~$: vol -f memdump.mem windows.mftscan.MFTScan > mftscan_out

Затем мы можем снова использовать команду grep, чтобы проанализировать файл на наличие updater.exe.

    ~$: cat mftscan_out | grep updater
            * 0xd389c63ce528FILE1114172FileArchiveFILE_NAME2024-02-24 22:51:50.000000 2024-02-24 22:51:50.000000 2024-02-24 22:51:50.000000 2024-02-24 22:51:50.000000 updater[1].exe

Из результата мы видим, что последние четыре временные метки соответствуют временным меткам Created, Modified, Updated и Accessed.

Идем дальше....
Давайте получим информацию о процессе.
На этот раз мы выгрузим область памяти, соответствующую updater.exe , и проверим ее.

Для выполнения вышеизложенного мы воспользуемся плагином windows.memmap.
Но укажем выходной каталог с помощью переключателя -o.
В этом случае мы будем использовать тот же каталог, обозначенный символом " . ", и опцию --dump, за которой следует опция --pid и PID процесса, который соответсвуте updater.exe.

    ~$: vol -f memdump.mem -o . windows.memmap --dump --pid 1612

После завершения команды выше у нас будет файл с расширением .dmp в Вашем рабочем каталоге.

Просмотр файла с помощью команды cat не принесет желаемых результатов, так как файл содержит непечатаемые символы
Поэтому мы воспользуемся командой strings для лучшего анализа вывода.
Поскольку у нас теперь есть строки файлов, мы можем искать ключевые шаблоны, такие как HTTP или key, или любой шаблон, который может быстро привести нас к артефакту.
*** Количество сопадений может быть огромным1

Другой способ прокрутки терминала — использовать команду strings, переданную по конвейеру less, чтобы перемещаться по выходным данным, как показано ниже.

    ~$: strings pid.1612.dmp |less

Как мы можем заметить, мы сразу же определили возможный ключ и домен из URL, к которому мог получить доступ процесс.
Кроме того, прокрутив страницу вниз, мы обнаружили больше указаний на то, что это вредоносный процесс, поскольку мы можем найти имя файла important_document.pdf, указывающее на взаимодействие с файлом.

Отлично, мы можем сделать вывод, что процесс updater.exe получил доступ к документу important_document.pdf и получил доступ к "ключу" в какой-то момент URL http://key.critical-update.com/encKEY.txt .
Если мы используем команду grep для поиска HTTP-запроса, который может храниться в памяти,
Мы можем сделать это с помощью -B и -A, чтобы найти 10 строк выше и ниже нашего совпадения, чтобы посмотреть, сможем ли мы обнаружить что-то еще.

    ~$: strings pid.1612.dmp |grep -B 10 -A 10 "http://key.critical-update.com/encKEY.txt"
            ...SNIP...
            @s1/0/_dk_http://critical-update.com http://critical-update.com http://key.critical-update.com/encKEY.txt
            HTTP/1.0 200 OK
            Server: SimpleHTTP/0.6 Python/3.10.4
            Date: Sat, 24 Feb 2024 22:52:40 GMT
            Content-type: text/plain
            Content-Length: 9
            Last-Modified: Fri, 23 Feb 2024 22:56:51 GMT
            192.168.182.128
            cafebabe
            ul1/0/_dk_https://microsoft.com https://microsoft.com https://edge.microsoft.com/entityextractiontemplates/api/v1/assets/find-assets?name=product_category_en&version=1.*.*&channel=stable&key
            =d414dd4f9db345fa8003e32adc81b362
            1/0/_dk_https://critical-update.com https://critical-update.com https://key.critical-update.com/encKEY.txt/
            ...SNIP...

Прокручивая вверх, мы можем наблюдать HTTP-запрос, как он отображается

Из вышесказанного мы можем наблюдать в конце HTTP-запроса содержимое файла encKey.txt, и в том же запросе мы можем наблюдать данные со значением cafebabe.
Это может быть ключом к шифрованию PDF, используемого злоумышленником, который не был загружен на диск.
Отлично. Мы собрали ценную информацию из дампа памяти, включая возможный ключ, использованный для шифрования документов.