
Когда дело доходит до анализа собранной информации, использованием правильных инструментов имеет важное значение для тщательного изучения и анализа.

Далее мы познакомиммся с наиболее часто используемыми (ну кроме тех, которые нам уже встречались)

	-	Active@ Disk Editor
	-	Eric Zimmerman Tools Set
			*	MFT Explorer / MFTECmd
			*	Timeline Explorer
			*	Windows Event Log (EvtxECmd)
			*	Registry Explorer
			*	PECmd (Prefetch)
			**	ShimCache
			*	AmcacheParser (AmCahce)
	-	Windows BAM (Background Activity Moderator)
	-	EQL
	-	RegRipper
	-	API Monitor
	-	PowerShell Activity

=====================================================================
* Active@ Disk Editor *
***********************

Большинство примеров данного разбора будет продемострированно с использованием Eric Zimmerman Tools Set
Однако, логичнее всего будет начать со знакомства с Active@ Disk Editor
Так как данная утилита наглядно продемонстрирует и поможет понять некоторые нюансы (такие как блоки $MFT файла), используемые при работе с утилитами из Eric Zimmerman Tools Set

Active@ Disk Editor	-	это мощный и бесплатный инструмент, который не используется не только для редактирования дисков, но и облегчает просмотр, а также изменение необработанных данных диска, включая главную таблицу файлов системы NTFS (MFT).
И хотя те же сведения можно почерпнуть из других инструментов анализа MFT (таких как MFT Explorer)
Но Active@ Disk Editor мы имеем доступ к необработанным данным записей MFT.
Это включает шестнадцатеричное представление записи MFT, с детальным отображением ее заголовков и атрибутов

С его помощью удобнее находить значение параметров того или иного атрибута, которое затем можно использовать в таргетированном поиске через MFTECmd
Другими словами, как только мы выяснили ID of the record посредством Active@ Disk Editor, то в следущий разм му уже может использовать это значение в MFTECmd для отображения всей информации по испокой записи 

Интерент ресурсы:

	https://www.disk-editor.org/index.html
	https://apps.microsoft.com/detail/xpfcxs0qvthdc9?hl=en-US&gl=US
	https://www.disk-editor.org/manual/#authoring/overview.html

Для того, чтобы более наглядно рассмотреть структуру инетерсующего нас $MFT файла, его сперва надо открыть в Active@ Disk Editor, а затем нажав Inspect File Record.
В результате мы получим детальное отображаение (с подкраской) каждой части/атрибута $MFT-файла

=====================================================================
* Eric Zimmerman Tools *
************************

Эрик Циммерман создал набор незаменимых инструментов, специально предназначенных для анализа информации.
Эти инструменты тщательно разработаны, чтобы помочь судебным экспертам в их стремлении извлечь важную информацию из цифровых устройств и артефактов.

Полный список этих инструментов см. на сайте	-	https://ericzimmerman.github.io/#!index.md

***	Чтобы ускорить процесс загрузки, мы можем зайти на официальный сайт и выбрать ссылку .net 4 или .net 6.
	Это действие инициирует загрузку всех инструментов в сжатом формате.

Мы также можем использовать предоставленный скрипт PowerShell, для загрузки всех инструментов.

	PS C:\Users\folder\where\you\want\to\save\the\tools> .\Get-ZimmermanTools.ps1

Как уже было сказано - Eric Zimmerman Tools Set состоит из множества отдельных утилит, где каждый инструмент заточен под определенный анализ
Мы рассмотрим только некоторые из них

	++++++++++++++++++++++++++
	+ MFT Explorer / MFTECmd +
	++++++++++++++++++++++++++

	Вся информация о файле, включая его размер, значения времени и даты, разрешения и содержимое данных, хранится либо в записях $MFT, либо в пространстве за пределами $MFT, которое описывается записями $MFT

	Справедливости ради, MFT Explorer и MFTECmd — это два разных инструмента, но они одинаковы в том смысле, что являются набором инструментов для анализа MFT Эрика Циммермана.
	Они делают одно и то же, но один (MFT Explorer) представлен с графическим интерфейсом, а другой (MFTECmd) — инструментом командной строки.

	Интурнет ресурсы:

		https://aboutdfir.com/toolsandartifacts/windows/mft-explorer-mftecmd/
		https://www.eyehatemalwares.com/incident-response/eztools/mftexplorer/#:~:text=MFTExplorer%20is%20bundled%20with%20EZTools,is%20described%20by%20%24MFT%20entries.
		https://stumblesec.medium.com/letsdefend-ntfs-forensics-challenge-walkthrough-1d1a2ce5a3da
		https://fanky.org/MFTExplorer/
		https://github.com/EricZimmerman/MFTECmd

	Однако, перед тем, как мы более тесно познакомимся с MFTExplorer/MFTECmd, нам следует проснить несколько момнетов

		////////////////////////////
		/// MAC(b) Times in NTFS ///
		////////////////////////////

		Термин MAC(b) Times обозначает ряд временных меток, связанных с файлами или объектами.
		Эти временные метки имеют решающее значение, поскольку они проливают свет на хронологию событий или действий в файловой системе.
		Аббревиатура MAC(b) является аббревиатурой от Modified, Accessed, Changed и (b) Birth times.
		Включение b означает временную метку Birth, которая не является универсальной для всех файловых систем или легкодоступной через стандартные функции Windows API.
		Давайте углубимся в нюансы временных меток MACB.

			-	Modified Time (M)
				Эта временная метка фиксирует последний случай, когда содержимое файла подверглось изменениям.
				Любые изменения данных файла, такие как редактирование содержимого, запускают обновление этой временной метки.

			-	Accessed Time (A)
				Эта временная метка отражает последний случай, когда файл был доступен или прочитан, обновляясь при каждом открытии файла или ином использовании.

			-	Changed [Change in MFT Record ] (C)
				Эта временная метка обозначает изменения в записи MFT.
				Она фиксирует момент, когда файл был изначально создан.
				Однако стоит отметить, что некоторые файловые системы, такие как NTFS, могут обновлять эту временную метку, если файл подвергается перемещению или копированию.

			-	Birth Time (b)
				Часто называемая временной меткой рождения или рождения, она представляет собой точный момент, когда файл или объект был создан в файловой системе.
				Ее значение в криминалистических расследованиях невозможно переоценить, особенно при определении первоначального времени создания файла.

		Интернет ресурсы:

			https://www.linkedin.com/pulse/understanding-macb-times-modern-operating-systems-fabio-fernandes-ksx8f#:~:text=MACB%20Times%20in%20Windows&text=Windows%20file%20systems%2C%20especially%20NTFS,file%20was%20opened%20or%20read.
			https://cscclabs.medium.com/mac-b-timestamps-86b40d7e7144

		////////////////////////////////////////////////////////////////////
		/// General Rules for Timestamps in the Windows NTFS File System ///
		////////////////////////////////////////////////////////////////////

		В таблице ниже приведены общие правила, регулирующие влияние различных файловых операций на временные метки в файловой системе Windows NTFS (New Technology File System).

			Operation		Modified		Accessed	Birth (Created)
		
			File Create		Yes				Yes			Yes
			File Modify		Yes				No			No
			File Copy		No (Inherited)	Yes			Yes
			File Access		No				No*			No

			1)	File Create:

					Modified Timestamp (M)		-	Временная метка изменена обновляется, чтобы отразить время создания файла.
					Accessed Timestamp (A)		-	Временная метка доступа обновляется, чтобы отразить, что к файлу был осуществлен доступ во время его создания.
					Birth (Created) Timestamp (b)	-	Временная метка рождения устанавливается на время создания файла.

			2)	File Modify:

					Modified Timestamp (M)		-	Временная метка изменена обновляется, чтобы отразить время последнего изменения содержимого или атрибутов файла.
					Accessed Timestamp (A)		-	Временная метка доступа не обновляется при изменении файла.
					Birth (Created) Timestamp (b)	-	Временная метка рождения не обновляется при изменении файла.

			3)	File Copy:

					Modified Timestamp (M)		-	Временная метка изменена обычно не обновляется при копировании файла, так как обычно она наследует временную метку от исходного файла.
					Accessed Timestamp (A)		-	Отметка времени доступа обновляется, чтобы отразить, что файл был доступен во время копирования.
					Birth (Created) Timestamp (b)	-	Отметка времени рождения обновляется на время копирования, указывая, когда была создана копия.

			4)	File Access:

					Modified Timestamp (M)		-	Отметка времени изменения не обновляется при доступе к файлу.
					Accessed Timestamp (A)		-	Отметка времени доступа обновляется, чтобы отразить время доступа.
					Birth (Created) Timestamp (b)	-	Отметка времени рождения не обновляется при доступе к файлу.

		Все эти временные метки находятся в файле $MFT (расположенном в корне системного диска), в двух различных атрибутах:

			-	$STANDARD_INFORMATION
			-	$FILE_NAME

		***	Временные метки, видимые в проводнике файлов Windows, получены из атрибута $STANDARD_INFORMATION.

		Интеренет ресурсы:

			https://andreafortuna.org/2017/10/06/macb-times-in-windows-forensic-analysis/
			https://medium.com/@cyberengage.org/understanding-ntfs-timestamps-timeline-analysis-0f90c10c19a7
			https://blog.joshlemon.com.au/file-timestamps-for-ntfs-on-macos-using-mountly-9e5cbaa15414
			
		////////////////
		/// MFT File ///
		////////////////

			Файл $MFT, обычно называемый главной таблицей файлов, является неотъемлемой частью NTFS (New Technology File System), используемой современными операционными системами Windows.
			Этот файл играет важную роль в организации и каталогизации файлов и каталогов на томе NTFS.
			Каждый файл и каталог на таком томе имеет соответствующую запись в главной таблице файлов.
			Представьте себе MFT как всеобъемлющую базу данных, тщательно документирующую метаданные и структурные детали о каждом файле и каталоге.

			Для тех, кто работает в сфере цифровой криминалистики, $MFT — это кладезь информации.
			Он предлагает подробную запись действий файлов и каталогов в системе, охватывающую такие действия, как создание, изменение, удаление и доступ к файлам.
			Используя $MFT, криминалисты могут составить подробную временную шкалу системных событий и взаимодействий пользователей.
			Выдающейся особенностью MFT является его способность сохранять метаданные о файлах и каталогах, даже публиковать их удаление из файловой системы.
			Эта черта повышает значимость MFT в криминалистическом анализе и восстановлении данных.

			MFT стратегически расположен в корне системного диска.
			Стоит отметить, что записи MFT, будучи однажды созданными, не удаляются.
			Вместо этого, по мере появления новых файлов и каталогов, в MFT добавляются новые записи. Записи, соответствующие удаленным файлам, помечаются как «свободные» и готовы к повторному использованию.	

			Для анализа MFT файла чаще всего используют MFT Explorer или MFTECmd.
			Этот инструмент, один из шедевров Эрика Циммермана, позволяет нам проверять и анализировать метаданные, размещенные в MFT.
			Он охватывает огромное количество информации о файлах и каталогах, от имен файлов и временных меток (создание, изменение, доступ) до размеров файлов, разрешений и атрибутов.
			Отличительной особенностью MFT Explorer является его интуитивно понятный интерфейс, представляющий записи файлов в графической иерархии, напоминающей знакомый проводник Windows.

		////////////////////////////////////
		/// Structure of MFT File Record ///
		////////////////////////////////////

		Каждый файл или каталог на томе NTFS символизируется записью в MFT.
		Эти записи придерживаются структурированного формата, переполненного атрибутами и подробностями о связанном файле или каталоге.
		Понимание структуры MFT имеет решающее значение для таких задач, как криминалистический анализ, управление системой и восстановление данных в экосистемах Windows.
		Это позволяет экспертам-криминалистам точно определить, какие атрибуты переполнены интригующими идеями.

		Вот примерная структура MFT-записи (размером 1024 bytes)

			-----------------------------------------
			| 	    File Record Header				|
			-----------------------------------------
			|	      ATTRIBUTE $10					|
			| 	($STANDARD_INFORMATION)				|
			-----------------------------------------
			| 	      ATTRIBUTE $30					|
			|	       ($FILE_NAME)					|
			-----------------------------------------
			| 	      ATTRIBUTE $80					|
			|	         ($DATA)					|
			|  File Data (Resident or Non-Resident)	|
			-----------------------------------------
			| 	   ADDITIONAL ATTRIBUTES			|
			| 		........						|
			-----------------------------------------

		И краткий обзор упомянутых компонентов:

			-	File Record Header
				Содержит метаданные о самой записи файла.
				Включает такие поля, как подпись, порядковый номер и другие административные данные.

			-	Standard Information Attribute Header ($STANDARD_INFORMATION)
				Хранит стандартные метаданные файла, такие как временные метки, атрибуты файла и идентификаторы безопасности.

			-	File Name Attribute Header ($FILE_NAME)
				Содержит информацию об имени файла, включая его длину, пространство имен и символы Unicode.

			-	Data Attribute Header ($DATA)
				Описывает атрибут данных файла, который может быть как резидентным (храниться в записи MFT), так и нерезидентным (храниться во внешних кластерах).

			-	File Data (File content)
				Этот раздел содержит фактические данные файла, которые могут быть содержимым файла или ссылками на нерезидентные кластеры данных.
				Для небольших файлов (менее 512 байт) данные могут храниться в записи MFT (резидентные).
				Для больших файлов он ссылается на нерезидентные кластеры данных на диске.

			-	Additional Attributes (optional)
				NTFS поддерживает различные дополнительные атрибуты, такие как:

					*	дескрипторы безопасности (SD)
					*	идентификаторы объектов (OID)
					*	имя тома (VOLNAME)
					*	информация об индексе и многое другое.

		Эти атрибуты могут различаться в зависимости от характеристик файла.
		Выше был представлен только общий тип информации, которая хранится внутри этих заголовков и атрибутов.

		Вот списко каждого атрибута, который может встретиться с его описанием

			Type		Attribute					Description
			
			0x10 (16)	$STANDARD_INFORMATION		General information - flags, MAC times, owner, and security id.
			0x20 (32)	$ATTRIBUTE_LIST				Pointers to other attributes and a list of nonresident attributes.
			0x30 (48)	$FILE_NAME					File name - (Unicode) and outdated MAC times
			0x40 (64)	$VOLUME_VERSION				Volume information - NTFS v1.2 only and Windows NT, no longer used
			0x40 (64)	$OBJECT_ID					16B unique identifier - for file or directory (NTFS 3.0+; Windows 2000+)
			0x50 (80)	$SECURITY_DESCRIPTOR		File's access control list and security properties
			0x60 (96)	$VOLUME_NAME				Volume name
			0x70 (112)	$VOLUME_INFORMATION			File system version and other information
			0x80 (128)	$DATA						File contents
			0x90 (144)	$INDEX_ROOT					Root node of an index tree
			0xA0 (160)	$INDEX_ALLOCATION			Nodes of an index tree - with a root in $INDEX_ROOT
			0xB0 (176)	$BITMAP						Bitmap - for the $MFT file and for indexes (directories)
			0xC0 (192)	$SYMBOLIC_LINK				Soft link information - (NTFS v1.2 only and Windows NT)
			0xC0 (192)	$REPARSE_POINT				Data about a reparse point - used for a soft link (NTFS 3.0+; Windows 2000+)
			0xD0 (208)	$EA_INFORMATION				Used for backward compatibility with OS/2 applications (HPFS)
			0xE0 (224)	$EA							Used for backward compatibility with OS/2 applications (HPFS)
			0x100 (256)	$LOGGED_UTILITY_STREAM		Keys and other information about encrypted attributes (NTFS 3.0+; Windows 2000+)

		//////////////////////////
		/// File Record HEADER ///
		//////////////////////////		

		Запись каждого файла начинается с заголовка, который содержит метаданные о самой записи файла.
		Этот заголовок обычно включает следующую информацию:

			-	Signature
				Четырехбайтовая подпись, обычно «FILE» или «BAAD», указывающая, используется ли запись или была освобождена.

			-	Offset to Update Sequence Array, a.k.a. USA (Смещение к массиву последовательности обновления)
				Смещение к массиву последовательности обновления, которое помогает поддерживать целостность записи во время обновлений.

			-	Update sequence size in words (Размер массива последовательности обновления)
				Размер массива последовательности обновления в словах.

			-	$LogFile Sequence Number, a.k.a. LSN (Порядковый номер файла журнала)
				Число, идентифицирующее последнее обновление записи файла.

			-	Sequence Number
				Число, идентифицирующее запись файла.
				Записи MFT нумеруются последовательно, начиная с 0.

			-	Hard Link Count (Счетчик жестких ссылок)
				Указывает, сколько записей каталога указывают на эту запись файла.

			-	Offset to First Attribute (Смещение к первому атрибуту)
				Смещение к первому атрибуту в записи файла.

		Данную информацию можно обнаружить, если когда мы будем просматривать файл MFT с помощью MFTExplorer.

		Но если мы хотим более быстрого и более специфического анализа $MFT файла, то мы также можем использовать MFTECmd
		Для этого можно использовать следующую команду
		К примеру, мы знаем ID номер файла (допустим ID номер испокоо файла был определен при помощи Active@ Disk Editor), который потенциально содержит интересный данные
		*** Однако, мы должны четко знать значение искомого артефакта, так как это напрямую зависит на полученный результат
		
			PS C:\Users\folder\where\MFTECmd.exe\tool\is\located> .\MFTECmd.exe -f 'C:\folder\where\$MFT\is\located\$MFT' --de <file ID# (a.k.a. "ID of this record")>		
		
		////////////////////////////////////
		/// Resident / Non-Resident FLAG ///
		////////////////////////////////////

		Это довольно такие своеобразный флаг, который не нак простообъяснить в двух словах
		Однако, если совсем просто, то он показывает как много информации содержится в исследуемом файле
			
		"Виртуально" фал забит на блоки, размером 512-байт каждый
		Так вот, если содержание информации в файле превышает 512-байт, то файл будет иметь флаг	- Resident: False
		А если, вся инфорамция помещается в 512-байтовый блок, то флан будет указан как			- Resident: True

		Для наглядной демонстрации воспользуемся MFTECmd с ключом (27142 - user.txt; 90472 - update.exe)
		*** 	Весь вывод отображаться не будет, так как он очень большой.
			Так, что только основные части

			PS C:\Users\folder\where\MFTECmd.exe\tool\is\located> .\MFTECmd.exe -f 'C:\folder\where\$MFT\is\located\$MFT' --de 27142
			MFTECmd version 1.2.2.1
			Author: Eric Zimmerman (saericzimmerman@gmail.com)
			https://github.com/EricZimmerman/MFTECmd

			...SNIP...
			File type: Mft
			...SNIP...

			**** STANDARD INFO ****
			Attribute #: 0x0, Size: 0x60, Content size: 0x48, Name size: 0x0, ContentOffset 0x18. Resident: True
			Flags: Archive, Max Version: 0x0, Flags 2: None, Class Id: 0x0, Owner Id: 0x0, Security Id: 0x557, Quota charged: 0x0, Update sequence #: 0x8B8778
			Created On:         2023-09-07 08:30:26.8316176
			Modified On:        2023-09-07 08:30:26.9097759
			Record Modified On: 2023-09-07 08:30:26.9097759
			Last Accessed On:   2023-09-07 08:30:26.9097759

			**** FILE NAME ****
			Attribute #: 0x2, Size: 0x70, Content size: 0x54, Name size: 0x0, ContentOffset 0x18. Resident: True
			File name: users.txt
			Flags: Archive, Name Type: DosWindows, Reparse Value: 0x0, Physical Size: 0x0, Logical Size: 0x0
			Parent Entry-seq #: 0x16947-0x2
			Created On:         2023-09-07 08:30:26.8316176
			Modified On:        2023-09-07 08:30:26.8316176
			Record Modified On: 2023-09-07 08:30:26.8316176
			Last Accessed On:   2023-09-07 08:30:26.8316176

			**** DATA ****
			Attribute #: 0x1, Size: 0x150, Content size: 0x133, Name size: 0x0, ContentOffset 0x18. Resident: True
			Resident Data
			...SNIP...
			ASCII:
			User accounts for \\HTBVM01
			-------------------------------------------------------------------------------
			Administrator            backgroundTask           DefaultAccount
			Guest                    John Doe                 WDAGUtilityAccount
			The command completed successfully.
			...SNIP...

		Беглый анализ покажет нам следующую информацию:

			-	**** FILE NAME ****
				File name: user.txt

			-	**** DATA ****
				Conent size: 0x133 (0x133 - это 16-ый формат, который соответвует 307 байт в десятичном)
				Residnet: True

			-	ASCII:
				Тут можно увидеть сожержание файла

			PS C:\Users\folder\where\MFTECmd.exe\tool\is\located> .\MFTECmd.exe -f 'C:\folder\where\$MFT\is\located\$MFT' --de 90472
			MFTECmd version 1.2.2.1
			Author: Eric Zimmerman (saericzimmerman@gmail.com)
			https://github.com/EricZimmerman/MFTECmd

			...SNIP...
			File type: Mft
			...SNIP...

			**** STANDARD INFO ****
			Attribute #: 0x0, Size: 0x60, Content size: 0x48, Name size: 0x0, ContentOffset 0x18. Resident: True
			Flags: Archive, Max Version: 0x0, Flags 2: None, Class Id: 0x0, Owner Id: 0x0, Security Id: 0x46C, Quota charged: 0x0, Update sequence #: 0x8B40F0
			Created On:         2023-09-07 08:30:07.1126851
			Modified On:        2023-09-07 08:30:07.1126851
			Record Modified On: 2023-09-07 08:30:07.1126851
			Last Accessed On:   2023-09-07 08:30:09.0816157

			**** FILE NAME ****
			Attribute #: 0x2, Size: 0x70, Content size: 0x56, Name size: 0x0, ContentOffset 0x18. Resident: True
			File name: update.exe
			Flags: Archive, Name Type: DosWindows, Reparse Value: 0x0, Physical Size: 0x6000, Logical Size: 0x0
			Parent Entry-seq #: 0x1091-0x1
			Created On:         2023-09-07 08:30:07.1126851
			Modified On:        2023-09-07 08:30:07.1126851
			Record Modified On: 2023-09-07 08:30:07.1126851
			Last Accessed On:   2023-09-07 08:30:07.1126851

			**** DATA ****
			Attribute #: 0x1, Size: 0x48, Content size: 0x0, Name size: 0x0, ContentOffset 0x0. Resident: False
			Non-Resident Data
			Starting Virtual Cluster #: 0x0, Ending Virtual Cluster #: 0x5, Allocated Size: 0x6000, Actual Size: 0x6000, Initialized Size: 0x6000
			...SNIP...

		Анализ данного клюбча (90472) покажет нам следующую информацию:

			-	**** FILE NAME ****
				File name: update.exe

			-	**** DATA ****
				Residnet: False
				Non-Resident Data
				Satrting Virtual Cluster #: 0x0, Ending Virtual Cluster #: 0x5
				Actual Size: 0x6000 (0x6000 - это 16-ый формат, который соответвует 24576 байтfv bkb 24.0 KB в десятичном)

		///////////////////////////////////////////////
		/// Zone.Identifier data in MFT File Record ///
		///////////////////////////////////////////////

		Zone.Identifier — это специализированный атрибут метаданных файла в ОС Windows, обозначающий зону безопасности, из которой был получен файл.
		Он является неотъемлемой частью службы выполнения вложений Windows (AES) и играет важную роль в определении того, как Windows обрабатывает файлы, полученные из Интернета или других потенциально ненадежных источников.

		Когда файл извлекается из Интернета, Windows назначает ему идентификатор зоны (ZoneId).
		Этот ZoneId, встроенный в метаданные файла, обозначает источник или зону безопасности источника файла.
		Файлы из Интернета обычно имеют ZoneId 3, обозначающий зону Интернета.

		Например, мы загрузили из интернета несколько файлов в каталог C:\Users\<user_name>\Downloads.
		После загрузки им был назначен ZoneID, дополненный Zone.Identifier (т. е. исходным URL-адресом)
		Чтобы посмотреть каким загруженным файлам был назанчен ZoneID, используем следуюущую команду

			PS C:\Users\<user_name>\Downloads> Get-Item * -Stream Zone.Identifier -ErrorAction SilentlyContinue

		А чтобы узнать какой именно Zone.Identifier был назаначен каждому файлу, а также русурс, откуда файл был скачен, используем данную комнду

			PS C:\Users\<user_name>\Downloads> Get-Content * -Stream Zone.Identifier -ErrorAction SilentlyContinue

		Один из механизмов безопасности, известный как Mark of the Web (MotW), основан на Zone Identifier.
		Маркер MotW отличает файлы, полученные из Интернета или других потенциально сомнительных источников, от файлов, полученных из доверенных или локальных контекстов.
		Он часто используется для повышения безопасности таких приложений, как Microsoft Word.
		Когда приложение, скажем, Microsoft Word, открывает файл с MotW, оно может установить определенные меры безопасности на основе наличия MotW.
		Например, документ Word с MotW может быть запущен в защищенном режиме просмотра, ограниченном режиме, который изолирует документ от более широкой системы, снижая потенциальные угрозы безопасности.

		Также данную информацию можно обнаружить при анализе файла через MFTECmd
		Для демонстрации используем другой ключ, который привет нас к другому файлу

			PS C:\Users\folder\where\MFTECmd.exe\tool\is\located> .\MFTECmd.exe -f 'C:\folder\where\$MFT\is\located\$MFT' --de 0x69F1
			MFTECmd version 1.2.2.1
			Author: Eric Zimmerman (saericzimmerman@gmail.com)
			https://github.com/EricZimmerman/MFTECmd

			...SNIP...
			File type: Mft
			...SNIP...
			Dumping details for file record with key 000069F1-0000000C
			Entry-seq #: 0x69F1-0xC, Offset: 0x1A7C400, Flags: InUse, Log seq #: 0xCC9EB3E, Base Record entry-seq: 0x0-0x0
			Reference count: 0x1, FixUp Data Expected: 04-00, FixUp Data Actual: 0D-0A | 00-00 (FixUp OK: True)

			**** STANDARD INFO ****
			Attribute #: 0x0, Size: 0x60, Content size: 0x48, Name size: 0x0, ContentOffset 0x18. Resident: True
			Flags: Archive, Max Version: 0x0, Flags 2: None, Class Id: 0x0, Owner Id: 0x0, Security Id: 0x555, Quota charged: 0x0, Update sequence #: 0x8A2518
			Created On:         2023-09-07 08:28:52.8586497
			Modified On:        2023-09-07 08:28:57.4169173
			Record Modified On: 2023-09-07 08:29:33.8137195
			Last Accessed On:   2023-09-07 08:29:34.4386419

			**** FILE NAME ****
			Attribute #: 0x9, Size: 0x70, Content size: 0x52, Name size: 0x0, ContentOffset 0x18. Resident: True
			File name: pass.exe
			Flags: Archive, Name Type: DosWindows, Reparse Value: 0x0, Physical Size: 0x14B000, Logical Size: 0x14AE00
			Parent Entry-seq #: 0x16947-0x2
			Created On:         2023-09-07 08:28:52.8586497
			Modified On:        2023-09-07 08:28:57.4169173
			Record Modified On: 2023-09-07 08:28:57.4169173
			Last Accessed On:   2023-09-07 08:28:57.4169173

			**** DATA ****
			Attribute #: 0x4, Size: 0x58, Content size: 0x0, Name size: 0x0, ContentOffset 0x0. Resident: False
			Non-Resident Data
			Starting Virtual Cluster #: 0x0, Ending Virtual Cluster #: 0x14A, Allocated Size: 0x14B000, Actual Size: 0x14AE00, Initialized Size: 0x14AE00
			DataRuns Entries (Cluster offset -> # of clusters)
			0x3F4F0                          ->      0x70
			0xFFFFFFFFFFFFEABE               ->      0x1B
			0xFFFFFFFFFFFD8ACB               ->      0xAA
			0x1FB909                         ->      0x16

			**** DATA ****
			Attribute #: 0x8, Size: 0xA0, Content size: 0x68, Name size: 0xF, ContentOffset 0x38. Resident: True
			Name: Zone.Identifier
			...SNIP...
			ASCII:   [ZoneTransfer]
			ZoneId=3
			ReferrerUrl=http://10.10.10.10:443/
			HostUrl=http://10.10.10.10:443/pass.exe
			...SNIP...
		
		При анализе данного ключа (0x69F1) нас стоит обратить внимание на последний блок отображаемого вывода

			-	ASCII: [ZoneTransfer]
				ZoneId=3
				ReferrerUrl=http://10.10.10.10:443/
				HostUrl=http://10.10.10.10:443/pass.exe			

		///////////////////
		/// USN Journal ///
		///////////////////

		USN (Update Sequence Number) является важным компонентом файловой системы NTFS в Windows.
		Журнал USN по сути является функцией журнала изменений, которая тщательно регистрирует изменения файлов и каталогов на томе NTFS.

		Для тех, кто занимается цифровой криминалистикой, журнал USN — это золотая жила.
		Он позволяет нам отслеживать такие операции, как создание файлов, переименование, удаление и перезапись данных.

		В среде Windows файл журнала USN обозначается как $J.
		Каталог вывода KAPE содержит собранный журнал USN в следующем каталоге: <KAPE_output_folder>\<Drive>\$Extend\$J
		В реальном мире это может выглядеть так	-	C:\Users\johndoe\Desktop\forensic_data\kape_output\D\$Extend\$J

		Ранее мы использовали MFTECmd, для анализа файла MFT.
		И хотя его основная цель	-	MFT файлы, но он также может быть полезен для анализа журнала USN.
		Это связано с тем, что записи в журнале USN часто ссылаются на изменения в файлах и каталогах, которые задокументированы в MFT.
		Поэтому мы воспользуемся этим инструментом для транформации журнала USN в CSV-файл, который можно будет использовать для последующего анализа в Timeline Explorer.

		Для этого можно выполнить следующую команду:

			PS C:\Users\folder\where\MFTECmd.exe\tool\is\located> .\MFTECmd.exe -f 'C:\folder\where\$Extend\$J\is\located\' --csv C:\Users\folder\where\you\want\save\csv\file\ --- csvf <file_name>.csv
		
		После создания csv-файла, нам надо перетащить его в Timeline Explorer для последующего анализа
		***	Примечание: снимите фильтр с Entry Number, чтобы увидеть полную картину.

		При осмотре мы можем различить хронологически упорядоченную временную шкалу событий.
		Вам следует обращать внимание на различные артифакты
		К примеру, расширение файла .crdownload указывает на частично загруженный файл.
		Этот тип файла обычно создается при загрузке контента через такие браузеры, как Microsoft Edge, Google Chrome или Chromium. 
		Если файл был загружен через браузер, вполне вероятно, что Zone.Identifier может раскрыть исходный IP/домен его происхождения.
	
		Чтобы исследовать это предположение, нам следует создать csv-файл, но уже из $MFT файла
		Затем прогнать его через Timeline, но уже с применением Entry Number фильтра, который будет соответсвовать такому же номеру, что и в csv-файле $J-журнала

		//////////////////////////////////
		/// Timestomping Investigation ///
		//////////////////////////////////

		Выявление случаев манипуляции временными метками, обычно называемых timestamp (T1070.006), представляет собой сложную задачу в цифровой криминалистике.
		Timestomping подразумевает изменение временных меток файлов для сокрытия последовательности действий с файлами.
		Эта тактика часто используется различными инструментами, как показано в методе timestomp MITRE ATT&CK

		Когда злоумышленники манипулируют временем создания файлов или используют инструменты для таких целей, временная метка, отображаемая в файловом проводнике, подвергается изменению.

		Например, после загрузки исследуемого $MFT в MFT Explorer, мы можем заметим, что время создания файла <file_name>.<ext> было изменено, и в проводнике отображается время, которое отличается от фактического времени создания.
		Однако, учитывая наши знания о том, что временные метки в файловом проводнике берут начало из атрибута $STANDARD_INFORMATION, мы можем перекрестно проверить эти данные с временными метками из атрибута $FILE_NAME через MFTEcmd следующим образом.

			PS C:\Users\folder\where\MFTECmd.exe\tool\is\located> .\MFTECmd.exe -f 'C:\folder\where\$MFT\is\located\$MFT' --de <HEX Value>

				<HEX Value>	-	HEX значение, которое соответсвует значению колонки "SI_Created On" из MFT Explorer для исследуемого файла
								При этом, значение Possible Timestomped, в разделе Properties, дожно быть check-marked
			
		В стандартных файловых системах Windows, таких как NTFS, обычные пользователи обычно не имеют прав на прямое изменение временных меток имен файлов в $FILE_NAME.
		Такие изменения находятся исключительно в компетенции ядра системы.

		Чтобы начать наше исследование, давайте сначала познакомимся с артефактами на основе файловой системы.
		Начнем с файла $MFT, расположенного в корневом каталоге вывода KAPE.
		
	+++++++++++++++++++++
	+ Timeline Explorer +
	+++++++++++++++++++++

	Timeline Explorer — еще один цифровой криминалистический инструмент, разработанный Эриком Циммерманом, который используется для помощи криминалистам и следователям в создании и анализе артефактов временной шкалы из различных источников.
	Артефакты временной шкалы обеспечивают хронологическое представление системных событий и действий, что упрощает восстановление последовательности событий во время расследования.
	Мы можем фильтровать данные временной шкалы на основе определенных критериев, таких как диапазоны дат и времени, типы событий, ключевые слова и многое другое.
	Эта функция помогает сосредоточить расследование на соответствующей информации.

	Расположение различных событий, следующих друг за другом во времени, действительно полезно для создания истории или временной шкалы о том, что произошло до и после определенных событий.
	Такая последовательность событий помогает установить временную шкалу действий в системе.

	Timeline Explorer предназначен для работы с данными временной шкалы, включая CSV-файлы, которые содержат события или действия с метками времени.
	Чтобы загрузить файл csv с данными о событиях в Timeline Explorer, мы можем запустить Timeline Explorer и просто перетащить его из его местоположения (например, из каталога анализа KAPE) в окно Timeline Explorer.

	После загрузки Timeline Explorer обработает и отобразит данные (продолжительность этого процесса зависит от размера файла).
	На экране мы увидим временную шкалу, заполненную событиями из CSV-файла в хронологическом порядке.
	Теперь, когда данные временной шкалы загружены, мы можем исследовать и анализировать события, используя различные функции, предоставляемые Timeline Explorer.
	Мы можем увеличивать масштаб определенных временных диапазонов, фильтровать события, искать ключевые слова и сопоставлять связанные действия.

	Есть только одна проблема	-	мы не можем импортировать $MFT файл в Timeline Explorer.
	Поэтому, нам сначало нужно использовать другую утилиту (также созданную Эриком Циммерманом), под названием MFTECmd.
	Она позволит нам трансформировать файлы $MFT из файловых систем NTFS в формат CSV, который примет Timeline Explorer.
	Для этого используют следующу команду:

		PS C:\Users\folder\where\MFTECmd.exe\tool\is\located> .\MFTECmd.exe -f 'C:\folder\where\$MFT\is\located\$MFT' --csv <file_name>.csv

	Как Вы могли уже догадатьсяб Timeline Explorer - это GUI приложение
	Поэтому, для наглядного ознакомления с данной утилитой, рекомендую посетить просторы интерента
	Вот некоторые из них:

		https://ericzimmerman.github.io/#!index.md
		https://aboutdfir.com/toolsandartifacts/windows/timeline-explorer/
		https://www.socinvestigation.com/timeline-explorer-tool-for-incident-responders-and-malware-analyst/
		https://www.securityblue.team/blog/posts/using-timeline-explorer-to-expose-insider-threats
		https://github.com/EricZimmerman/TLEFilePlugins

	+++++++++++++++++++++++++++++++++++++++++++++++
	+ Windows Event Logs Investigation (EvtxECmd) +
	+++++++++++++++++++++++++++++++++++++++++++++++
		
	Исследование журналов событий Windows имеет первостепенное значение в цифровой криминалистике и реагировании на инциденты.
	Эти журналы являются хранилищами бесценных данных, фиксируя системные действия, поведение пользователей и инциденты безопасности на компьютере Windows.
	При запуске KAPE он дублирует исходные журналы событий, гарантируя сохранение их первозданного состояния в качестве доказательства.
	Каталог вывода KAPE размещает эти журналы событий в следующем каталоге: <KAPE_output_folder>\Windows\System32\winevt\logs

	Этот каталог заполнен файлами .evtx, инкапсулирующими множество журналов событий Windows, включая, помимо прочего, Security, Application, System и Sysmon (если активировано).

	Наша миссия — просеивать эти журналы событий в поисках любых аномалий, шаблонов или индикаторов компрометации (IOC).
	Мы должны обращать внимание на идентификаторы событий, временные метки, исходные IP-адреса, имена пользователей и другие соответствующие детали журнала.
	Множество судебных утилит и скриптов, таких как инструменты анализа журналов и системы SIEM, могут усилить наш анализ.
	Крайне важно определить тактику, методы и процедуры (TTP), очевидные в любой сомнительной активности.
	Это может повлечь за собой изучение известных шаблонов атак и сигнатур вредоносных программ.

	Другим важным шагом является корреляция событий из различных источников журналов, создавая полную временную шкалу событий.
	Этот целостный взгляд помогает собрать воедино последовательность событий.

	EvtxECmd	-	еще одно детище Эрика Циммермана, адаптированное для файлов журнала событий Windows (файлы EVTX).
	Имея в своем распоряжении этот инструмент, мы можем извлекать определенные журналы событий или ряд событий из файла EVTX, преобразуя их в более удобные форматы, такие как JSON, XML или CSV.
	Чтобы ознакомиться с различными опциями EvtxECmd, нужно использовать следующую комнаду

		PS C:\Users\folder\where\EvtxECmd.exe\tool\is\located> .\EvtxECmd.exe -h

		////////////////////////
		/// Maps in EvtxECmd ///
		////////////////////////

		Карты в EvtxECmd играют ключевую роль.
		Они преобразуют настроенные данные в стандартизированные поля в данных CSV (и JSON).
		Эта детализация и точность незаменимы в криминалистических расследованиях, позволяя аналитикам с изяществом интерпретировать и извлекать важную информацию из журналов событий Windows.

		Стандартизированные поля в картах:

			-	UserName
				Содержит информацию о пользователе и/или домене, найденную в различных журналах событий

			-	ExecutableInfo
				Содержит информацию о командной строке процесса, запланированных задачах и т. д.

			-	PayloadData1,2,3,4,5,6
				Дополнительные поля для извлечения и размещения контекстных данных из журналов событий

			-	RemoteHost
				Содержит информацию об IP-адресе

		EvtxECmd играет важную роль в:

			-	Преобразовании уникальной части события, известной как EventData, в более стандартизированный и понятный человеку формат.
			-	Обеспечение того, чтобы файлы карт были адаптированы к определенным журналам событий, таким как журналы безопасности, приложений или пользовательские журналы, для обработки различий в структурах событий и данных.
			-	Использование уникального идентификатора, элемента Channel, для указания, для какого журнала событий предназначен конкретный файл карты, что предотвращает путаницу при повторном использовании идентификаторов событий в разных журналах.
		
		Чтобы убедиться, что самые последние карты находятся на месте перед преобразованием файлов EVTX в CSV/JSON, используйте следующую команду:
		Это своего рода обновление баз данных EvtxECmd

			PS C:\Users\folder\where\EvtxECmd.exe\tool\is\located> .\EvtxECmd.exe --sync

		Благодаря обновлению карт мы можем вводить контекстную информацию в отдельные поля, оптимизируя процесс анализа журналов.
		Теперь пришло время преобразовать журналы в более удобный формат.
		Чтобы сделать файлы EVTX более доступными, мы можем использовать EvtxECmd для бесшовного преобразования файлов журналов событий в удобные для пользователя форматы, такие как JSON или CSV.

			PS C:\Users\folder\where\EvtxECmd.exe\tool\is\located> .\EvtxECmd.exe -f "C:\Location\of\EVTX-file\that\need\to\be\converted\into\csv\<file_name>.evtx" --csv "C:\Folde\where\you\want\to\save\converted\file\" --csvf <file_name>.csv
			
		После преобразовани файла, мы может открыть его csv-версию в Timaline Explorer

	+++++++++++++++++++++
	+ Registry Explorer +
	+++++++++++++++++++++

	Глубокое погружение в кусты реестра может предоставить нам бесценную информацию, такую ​​как имя компьютера, версия Windows, имя владельца и конфигурация сети.

	Файлы, связанные с реестром, собранные из KAPE, обычно размещаются в <KAPE_output_folder>\Windows\System32\config
	Кроме того, существуют пользовательские кусты реестра, расположенные в отдельных пользовательских каталогах (к примеру - NTUSER.DAT или UsrClass.dat)

	Для комплексного анализа мы можем использовать Registry Explorer	-	инструмент на основе графического интерфейса, разработанный Эриком Циммерманом.
	Этот инструмент предлагает оптимизированный интерфейс для навигации и анализа содержимого кустов реестра Windows.
	Просто перетащив эти файлы в Registry Explorer, инструмент обрабатывает данные, представляя их в своем графическом интерфейсе.
	Левая панель отображает кусты реестра, а правая панель показывает их соответствующие значения.

	Registry Explorer может похвастаться набором функций, включая анализ кустов, возможности поиска, параметры фильтрации, просмотр временных меток и закладки.
	Утилита закладок особенно удобна, позволяя пользователям отмечать основные местоположения или ключи для последующего использования.

	++++++++++++++++++++
	+ PECmd (Prefetch) +
	++++++++++++++++++++

	Когда мы говорим об артефактах выполнения в цифровой криминалистике, мы имеем в виду следы и улики, оставленные на компьютерной системе или устройстве при запуске программы.
	Эти небольшие фрагменты информации могут подсказать нам действия и поведение программного обеспечения, пользователей и даже тех, кто имеет злонамеренные намерения.
	Если мы хотим собрать воедино то, что произошло на компьютере, погружение в эти артефакты выполнения является обязательным.

	Один из известных артефактов выполнения в этих компонентах Windows	-	PREFETCH

	Prefetch — это функция операционной системы Windows, которая помогает оптимизировать загрузку приложений путем предварительной загрузки определенных компонентов и данных.
	Файлы Prefetch создаются для каждой программы, которая выполняется в системе Windows, и это включает как установленные приложения, так и автономные исполняемые файлы.
	Соглашение об именовании файлов Prefetch основано на исходном имени исполняемого файла, за которым следует шестнадцатеричное значение пути, где находится исполняемый файл, и заканчивается расширением файла .pf

	В цифровой криминалистике папка Prefetch и связанные с ней файлы могут предоставить ценную информацию о приложениях, которые были выполнены в системе Windows.
	Криминалисты могут исследовать файлы Prefetch, чтобы определить, какие приложения были запущены, как часто они были запущены и когда они были запущены в последний раз.
	Как правило, файлы prefetch хранятся в каталоге C:\Windows\Prefetch\

	При анализе образа диска, файлы, связанные с предварительной выборкой, собранные из KAPE, обычно размещаются в папке <KAPE_output_folder>\Windows\prefetch

	Эрик Циммерман предоставляет инструмент для предварительной выборки файлов	-	PECmd

	Интернет ресурсы:

		https://github.com/EricZimmerman/PECmd
		https://insertidhere.medium.com/forensic-value-of-prefetch-f59730ae6e84
		https://www.thedfirspot.com/post/artifacts-of-execution-i-know-what-you-did-last-incident
		https://bromiley.medium.com/tooling-thursday-pecmd-83d1d6d6346b
		https://darkcybe.github.io/posts/DFIR_Tools_Execution_PeCmd/
		https://staging.thesecmaster.com/tools/pecmd
		https://blog.secopsgarage.com/pecmd-a-powerful-tool-for-dfir-and-incident-response/

	Вот пример того, как запустить меню справки PECmd
		
		PS C:\Users\folder\where\PECmd.exe\tool\is\located> .\PECmd.exe -h

	Из вывода меню-справки можно понять, что PECmd обладает некоторым схожим функционала с другими утилитами из набоар Эрика Циммермана
	А именно способность преобразовывать результат в csv-файлы для последующего анализа через Timeline Explorer

 	Как уже было сказано, PECmd проанализирует файл prefetch (.pf) и отобразит различную информацию о выполнении приложения.
	Обычно это включает в себя такие сведения, как:

		-	Метки времени первого и последнего выполнения.
		-	Количество раз, когда приложение было запущено.
		-	Информация о томе и каталоге.
		-	Имя приложения и путь.
		-	Информация о файле, такая как размер файла и значения хэша

	Вывод может быть очень огромным (в зависимости от частоты и интенсивности использования того или иного приложения/файла)
	Поэтому прокручивая вывод вниз, мы увидим каталоги и/или файлы, на которые ссылается исследуемый файл.
	
	Мы также должны рассмотреть каталог, из которого было запущен исследуемый файл/приложение.
	Если оно было запущено из необычного или неожиданного места, это может быть подозрительно.

	Для более простого анализа мы можем преобразовать данные предварительной выборки в CSV следующим образом.

		PS C:\Users\folder\where\PECmd.exe\tool\is\located> .\PECmd.exe -d C:\Folder\with\prefetch\files --csv C:\Folder\where\you\want\to\save\results

	Если вы решили обработать целый каталог, то в результате Вы получите каталог с одноименными файлами, но в csv-формате

	+++++++++++++
	+ ShimCache +
	+++++++++++++

	ShimCache (также известный как AppCompatCache) — это механизм Windows, используемый операционными системами Windows для выявления проблем совместимости приложений.
	Эта база данных записывает информацию о выполненных приложениях и хранится в реестре Windows.
	Эта информация может использоваться разработчиками для отслеживания проблем совместимости с выполненными программами.

	В записях кэша AppCompatCache мы можем увидеть такую ​​информацию, как:

		-	Полные пути к файлам
		-	Временные метки
				*	Время последнего изменения ($Standard_Information)
				*	Время последнего обновления (Shimcache)
		-	Флаг выполнения процесса
		-	Позиция записи кэша

	Следователи-криминалисты могут использовать эту информацию для обнаружения выполнения потенциально вредоносных файлов.

	Ключ AppCompatCache находится в разделе реестра HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\ControlSet001\Control\Session Manager\AppCompatCache.

	Допустим, мы зотим загрузить куст реестра SYSTEM в Registry Explorer и посмотреть, какую информацию он содержит.
	Мы можем сделать это, открыв Registry Explorer и перетащив в него файлы куста реестра.
	Затем нам нужно будет перейти в закладки и выбрать AppCompatCache.
	В правом нижнем углу мы должны увидеть доказательства выполнения приложения

	++++++++++++
	+ AmChache +
	++++++++++++

	AmCache относится к файлу реестра Windows, который используется для хранения доказательств, связанных с выполнением программы.
	Он служит ценным ресурсом для цифровой криминалистики и расследований безопасности, помогая аналитикам понять историю выполнения приложения и обнаружить признаки любого подозрительного выполнения.

	Информация, которую он содержит, включает:

		-	путь выполнения
		-	время первого выполнения
		-	время удаления
		-	и первую установку.
	
	Он также предоставляет хэш файла для исполняемых файлов.

	В ОС Windows куст AmCache находится по адресу C:\Windows\AppCompat\Programs\AmCache.hve
	И имеет расширение .hve

	Файлы, связанные с AmCache, собранные из KAPE, обычно размещаются в <KAPE_output_folder>\Windows\AppCompat\Programs.

	Одной из утилит, используемой для просмотра информации, которую сдержит образ файла AmCache.hve является	-	Registry Explorer
	
	Однако, в наборе Эрика Циммермана существует, с помощью которой можно распарсить .hve файл (в csv файл) для последующего использования в Timeline Explorer
	Это	-	AmcacheParser
	Команда, используемая для анализ и конфертации .hve файла в csv-файл, аналогична другим утилитам Эрика Циммермана

=====================================================================
* Windows BAM *
***************

Background Activity Moderator (BAM) — это компонент операционной системы Windows, который отслеживает и регистрирует выполнение определенных типов фоновых или запланированных задач.
BAM на самом деле является драйвером устройства ядра
Чтобы это увидеть, необходимо запустить следубщую команду

	PS C:\Users\user_name> C:\Windows\System32\sc.exe qc bam

	[SC] QueryServiceConfig SUCCESS

	SERVICE_NAME: bam
        	TYPE               : 1  KERNEL_DRIVER
        	START_TYPE         : 1   SYSTEM_START
        	ERROR_CONTROL      : 1   NORMAL
        	BINARY_PATH_NAME   : system32\drivers\bam.sys
        	LOAD_ORDER_GROUP   :
        	TAG                : 0
        	DISPLAY_NAME       : Background Activity Moderator Driver
        	DEPENDENCIES       :
        	SERVICE_START_NAME :

Он в первую очередь отвечает за контроль активности фоновых приложений, но может помочь нам в предоставлении доказательств выполнения программы, которые он перечисляет в кусте реестра bam.
Ключ BAM находится в следующем месте реестра	-	HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\bam\State\UserSettings\{USER-SID}

Используя Registry Explorer, мы можем просмотреть его внутри куста SYSTEM, чтобы увидеть имена исполняемых файлов.
***	В Registry Explorer уже есть закладка для bam.

Мы также можем использовать RegRipper для получения аналогичной информации через его плагин bam.

=====================================================================
* Investigating Windows Event Logs with EQL *
*********************************************

Язык запросов событий Endgame (EQL - Endgame's Event Query Language)	-	незаменимый инструмент для просеивания журналов событий, выявления потенциальных угроз безопасности и обнаружения подозрительных действий в системах Windows.
EQL предлагает структурированный язык, который упрощает запросы и сопоставление событий в нескольких источниках журналов, включая журналы событий Windows.

В настоящее время модуль EQL совместим с версиями Python 2.7 и 3.5+.
Поэтому, для установки EQL, вы сперва должны быть уверенны, что у вас установлена ​​поддерживаемая версия Python
Если оно так, то для непорслественной установки EQL выполните следующую команду.

	C:\Users\<user_name>> pip install eql

После того, как установили EQL необходимо подтвердить факт установки, а также уточнить - какая версия была утановленна

	C:\Users\<user_name>> ql --version	

Если Вам надо просмотреть репозиторий EQL, то после установки он находится в дефолном месте

	C:\Users\user_name\Desktop\eqllib-master

Помимо основных компонентов, там находится модуль PowerShell, полный основных функций, предназначенных для анализа событий Sysmon из журналов событий Windows.
Этот модуль находится в каталоге utils eqllib и называется scrape-events.ps1
Чтобы импортировать этот модуль в Вашу базу данных модулей PowerShell используйте следующую команду

	PS C:\Users\user_name\Desktop\eqllib-master\utils> import-module .\scrape-events.ps1

Таким образом Вы фактивируете функцию Get-EventProps, которая играет важную роль в разборе свойств событий из журналов Sysmon.
Например, чтобы преобразовать C:\Users\user_name\Desktop\forensic_data\kape_output\D\Windows\System32\winevt\logs\Microsoft-Windows-Sysmon%4Operational.evtx в формат JSON, подходящий для запросов EQL, выполните следующую команду.

	PS C:\Users\user_name\Desktop\eqllib-master\utils> Get-WinEvent -Path C:\Users\user_name\Desktop\forensic_data\kape_output\D\Windows\System32\winevt\logs\Microsoft-Windows-Sysmon%4Operational.evtx -Oldest | Get-EventProps | ConvertTo-Json | Out-File -Encoding ASCII -FilePath C:\Users\user_name\Desktop\forensic_data\event_logs\eql_format_json\eql-sysmon-data-kape.json

Это действие даст файл JSON, подготовленный для запросов EQL.

Чтобы, просмотреть получившийся файл и найти в нем необходимую информацию, Вы также можете использовать eql, но уже с другим ключом - "query"

	PS C:\Users\user_name> eql query -f C:\Users\user_name\Desktop\forensic_data\event_logs\eql_format_json\eql-sysmon-data-kape.json "EventId=1 and (Image='*net.exe' and (wildcard(CommandLine, '* user*', '*localgroup *', '*group *')))"

В результате, на экране мы увидим только те события, которые содержат в себе следующие элементы:

	-	Критерия "EventID" должен равняться 1
	-	Критерий "Image" должен содержать в себе net.exe
	-	Критерий "CommandLine" дожен срдержать в сбе одно из следующих ключевых слов " user", 'localgroup", "group "

Для более детального ознакомления с EQL можете ознакомиться со следующими интренет ресурсами:

	https://github.com/endgameinc/eql
	https://github.com/endgameinc/eqllib
	https://eql.readthedocs.io/en/latest/
	https://www.elastic.co/blog/introducing-event-query-language
	https://www.elastic.co/docs/explore-analyze/query-filter/languages/eql
	https://eql.readthedocs.io/_/downloads/en/stable/pdf/
	https://www.varonis.com/blog/guide-no-hassle-eql-threat-hunting
	
=====================================================================
* RegRipper *
*************

Еще один мощный инструмент в нашем арсенале — RegRipper
Это утилита командной строки, которая умеет быстро извлекать информацию из реестра.

Интернет ресурсы

	https://www.kali.org/tools/regripper/
	https://github.com/keydet89/RegRipper3.0
	https://github.com/keydet89/RegRipper4.0
	https://www.forensicfocus.com/articles/a-guide-to-regripper-and-the-art-of-timeline-building/
	https://www.infosecinstitute.com/resources/digital-forensics/registry-forensics-regripper-command-line-linux/
	https://windowsir.blogspot.com/2020/05/tips-on-using-regripper-v30.html
	https://binsec.wiki/en/security/howto/forensic-training/use-regripper-to-analyse-windows-registry/
	https://forensics.wiki/regripper/

Чтобы ознакомиться с функциональными возможностями RegRipper, давайте вызовем раздел справки

	PS C:\Users\folder\where\RegRipper3.0-master\tool\is\located> .\rip.exe -h

Для бесперебойной работы с RegRipper важно ознакомиться с его плагинами.
Чтобы перечислить все доступные плагины и каталогизировать их в CSV-файле (например, rip_plugins.csv), используйте команду ниже.

	PS C:\Users\folder\where\RegRipper3.0-master\tool\is\located> .\rip.exe -l -c > rip_plugins.csv

Это действие составляет полный список плагинов, подробно описывая связанные кусты, и сохраняет его как CSV-файл.
К примеру, давайте выполним команду "compname" в кусте SYSTEM (расположенном по адресу C:\Users\user_name\kape_output\D\Windows\System32\config), которая извлекает имя компьютера.

	PS C:\Users\folder\where\RegRipper3.0-master\tool\is\located> .\rip.exe -r "C:\Users\user_name\kape_output\D\Windows\System32\config\SYSTEM" -p compname

	Launching compname v.20090727
	compname v.20090727
	(System) Gets ComputerName and Hostname values from System hive

	ComputerName    = HTBVM01
	TCP/IP Hostname = HTBVM01

Эту же команду, можно использовать для извлечения другой информации из образа реестра, меняя только последний атрибуд на необходимый
Вот некоторые атрибуты:

	-	timezone
		PS C:\Users\folder\where\RegRipper3.0-master\tool\is\located> .\rip.exe -r "C:\Users\user_name\kape_output\D\Windows\System32\config\SYSTEM" -p timezone

	-	network information
		PS C:\Users\folder\where\RegRipper3.0-master\tool\is\located> .\rip.exe -r "C:\Users\user_name\kape_output\D\Windows\System32\config\SYSTEM" -p <interface name>

	-	Installer Execution
		PS C:\Users\folder\where\RegRipper3.0-master\tool\is\located> .\rip.exe -r "C:\Users\user_name\kape_output\D\Windows\System32\config\SOFTWARE" -p installer

	-	Recently Accessed Folders/Docs
		PS C:\Users\folder\where\RegRipper3.0-master\tool\is\located> .\rip.exe -r "C:\Users\user_name\kape_output\D\Users\<user_name>\NTUSER.DAT" -p recentdocs

	-	Autostart - Run Key Entries
		PS C:\Users\folder\where\RegRipper3.0-master\tool\is\located> .\rip.exe -r "C:\Users\user_name\kape_output\D\Users\<user_name>\NTUSER.DAT" -p recentdocs

=====================================================================
*  API Monitor *
****************

API Monitor — это программное обеспечение, которое захватывает и отображает вызовы API, инициированные приложениями и службами.
Хотя его основная функция — отладка и мониторинг, его способность захватывать данные вызовов API делает его удобным для обнаружения артефактов судебной экспертизы.

Расширение файлов, которые генерирует API Monitor	-	.apmx64
Эти файлы можно открывать и анализировать в самом инструменте. 

Интернет ресурсы:

	http://www.rohitab.com/apimonitor
	https://github.com/jozefizso/apimonitor
	https://www.splunk.com/en_us/blog/learn/api-monitoring.html
	https://betterstack.com/community/guides/monitoring/what-is-api-monitoring/
	https://www.uptrends.com/support/kb/synthetic-monitoring/api-monitoring/api-monitoring-overview

Схема работа с .apmx64 файлом следующая:

	1)	Откроем приложение API Monitor, перейдем в меню Файл и выберем Открыть.

	2)	Оттуда перейдем к местоположению файла .apmx64 и выберем его.

	3)	После открытия файла будет отображен список записанных вызовов API, выполненных контролируемым приложением.
		Обычно этот список содержит такие данные, как имя функции API, параметры, возвращаемые значения и временные метки.

	4)	Нажатие на контролируемые процессы слева отобразит записанные данные вызовов API для выбранного процесса в сводном представлении справа.
		
API Monitor может похвастаться множеством возможностей фильтрации и поиска.
Это позволяет нам сосредоточиться на определенных вызовах API на основе функций или временных интервалов.
Просматривая сводку или используя функции фильтрации и поиска, мы можем обнаружить интригующие подробности, такие как вызовы API, касающиеся:

	-	изменений реестра (Registry ALterations/Persistence)
	-	создания процессов (Process Creation/Injection)
	-	создания файлов/скриптов (File/Scipts Creation)
	-	и многого другого.

	+++++++++++++++++++++++++++++++++++++
	+ Registry Persistence via Run Keys +
	+++++++++++++++++++++++++++++++++++++

	Часто используемая злоумышленниками стратегия для сохранения несанкционированного доступа к скомпрометированной системе		-	вставка записи в ключи запуска в реестре Windows.
	Давайте выясним, есть ли какая-либо ссылка на функцию RegOpenKeyExA, которая обращается к указанному ключу реестра.
	Чтобы выполнить этот поиск, просто введите RegOpenKey в поле поиска, которое обычно расположено над окном API Monitor, и нажмите Enter.

	Из отображаемых результатов видно, что раздел реестра SOFTWARE\Microsoft\Windows\CurrentVersion\Run соответствует разделу реестра Run, который запускает указанную программу при каждом входе пользователя в систему.
	Вредоносные сущности часто используют этот раздел для внедрения записей, указывающих на их бэкдор, задача, выполнимая с помощью функции API реестра RegSetValueExA.

	Для дальнейшего изучения давайте поищем любое упоминание функции RegSetValueExA, которая определяет данные и тип для указанного значения в разделе реестра.
	Задействуйте поле поиска, введите RegSet и нажмите Enter
	Примечательным наблюдением является вызов RegSetValueExA.
	Прежде чем углубляться, давайте ознакомимся с документацией этой функции.

		LSTATUS RegSetValueExA(
  			[in]		HKEY       	hKey,
  			[in, optional]	LPCSTR     	lpValueName,
                			DWORD		Reserved,
  			[in]           	DWORD      	dwType,
  			[in]           	const BYTE 	*lpData,
  			[in]           	DWORD      	cbData
		);

			hKey 
			Это дескриптор раздела реестра, в котором вы хотите установить значение реестра.

			lpValueName
			Это указатель на строку с нулевым окончанием, которая указывает имя значения реестра, которое вы хотите установить.
			Оно может содержать наименование исследуемого пройесса/приложения (к примеру DiscordUpdate)

			Reserved
			Этот параметр зарезервирован и должен быть равен нулю.

			dwType
			Он указывает тип данных значения реестра.
			Скорее всего, это целочисленная константа, представляющая тип данных (например, REG_SZ для строкового значения).

			(BYTE*)lpData
			Это приведение типа, которое преобразует переменную _lpData_ в указатель на байт (BYTE*).
			Это делается для того, чтобы гарантировать, что данные, на которые указывает _lpData_, обрабатываются как массив байтов, что является ожидаемым форматом для двоичных данных в реестре Windows.
			К примеру это может отображаться в представлении буфера как C:\Windows\Tasks\update.exe.

			cbData
			Это целое число, которое указывает размер в байтах данных, на которые указывает _lpData_.

	Важнейшим выводом из этого вызова API является параметр lpData, который может раскрывать местоположение бэкдора
			
	+++++++++++++++++++++
	+ Process Injection +
	+++++++++++++++++++++

	Чтобы изучить создание процесса, давайте найдем функцию CreateProcessA.
	Давайте введем CreateProcess в поле поиска и нажмем Enter.

	Ниже представлен синтаксис функции Windows API CreateProcessA.

		BOOL CreateProcessA(
  			[in, optional]      LPCSTR                lpApplicationName,
  			[in, out, optional] LPSTR                 lpCommandLine,
  			[in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,
  			[in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,
  			[in]                BOOL                  bInheritHandles,
  			[in]                DWORD                 dwCreationFlags,
  			[in, optional]      LPVOID                lpEnvironment,
  			[in, optional]      LPCSTR                lpCurrentDirectory,
  			[in]                LPSTARTUPINFOA        lpStartupInfo,
  			[out]               LPPROCESS_INFORMATION lpProcessInformation
		);

	Интригующим элементом в этом API является параметр lpCommandLine.
	Он раскрывает выполненную командную строку.
	Примечательно, что lpCommandLine можно указать без указания полного пути к исполняемому файлу в значении lpApplicationName.

	Еще один важный параметр, на который стоит обратить внимание, — это dwCreationFlags, установленный в CREATE_SUSPENDED.
	Это указывает на то, что основной поток нового процесса запускается в приостановленном состоянии и остается неактивным до тех пор, пока не будет вызвана функция ResumeThread.

	Параметр lpCommandLine может пролить свет на инициированный дочерний процесс

	Копнув глубже, мы можем заметить, что подозрительный процесс/приложени (к примеру - discord.exe) использует функции, связанные с внедрением процесса.
	Это может являеться весомым показателем внедрения процесса.

=====================================================================
* PowerShell Activity *
***********************

Транскрипты PowerShell тщательно регистрируют как выданные команды, так и их соответствующие выходные данные во время сеанса PowerShell.
Иногда в каталоге документов пользователя мы можем наткнуться на файлы Транскрипты PowerShell.
Эти файлы предоставляют нам окно в записанные действия PowerShell в системе.
Они могут быть размещенные в каталоге документов пользователя.

Подробный обзор активности PowerShell может быть полезен во время расследований.
Вот несколько рекомендуемых рекомендаций по работе с данными PowerShell.

	-	Необычные команды
		Ищите команды PowerShell, которые нетипичны для вашей среды или обычно связаны с вредоносными действиями.
		Например:
			*	команды для загрузки файлов из Интернета (Invoke-WebRequest или wget)
			*	команды, которые манипулируют реестром
			*	или команды, которые включают создание запланированных задач.

	-	Выполнение скрипта
		Проверяйте выполнение скриптов PowerShell, особенно если они не подписаны или получены из ненадежных источников.
		Скрипты могут использоваться для автоматизации вредоносных действий.

	-	Закодированные команды
		Злоумышленники часто используют закодированные или запутанные команды PowerShell, чтобы избежать обнаружения.
		Ищите признаки закодированных команд в расшифровках.

	-	Повышение привилегий
		Команды, которые пытаются повысить привилегии, изменить разрешения пользователя или выполнить действия, обычно доступные только администраторам, могут быть подозрительными.

	-	Файловые операции
		Проверьте наличие команд PowerShell, которые включают создание, перемещение или удаление файлов, особенно в уязвимых системных расположениях.

	-	Сетевая активность
		Ищите команды, связанные с сетевой активностью, такие как выполнение HTTP-запросов или инициирование сетевых подключений.
		Они могут указывать на коммуникации команд и управления (C2).

	-	Манипуляции с реестром
		Ищите команды, которые включают изменение реестра Windows, так как это может быть распространенной тактикой для сохранения вредоносного ПО.

	-	Использование необычных модулей
		Если сценарий или команда PowerShell использует необычные или нестандартные модули, это может быть признаком подозрительной активности.

	-	Активность учетных записей пользователей 
		Ищите изменения в учетных записях пользователей, включая создание, изменение или удаление.
		Злоумышленники могут попытаться создать или изменить учетные записи пользователей для сохранения.

	-	Запланированные задачи
		Иследуйте создание или изменение запланированных задач с помощью PowerShell
		Это может быть распространенным методом сохранения.

	-	Повторяющиеся или необычные шаблоны
		Проанализируйте шаблоны команд PowerShell.
		Повторяющиеся, идентичные команды или необычные последовательности команд могут указывать на автоматизацию или вредоносное поведение.

	-	Выполнение неподписанных скриптов
		Выполнение неподписанных скриптов может быть признаком подозрительной активности, особенно если политики выполнения скриптов ограничивают это.