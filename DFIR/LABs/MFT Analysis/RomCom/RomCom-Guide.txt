=====================================================================
* Легенда сценария *
********************

Сьюзен работает в исследовательской лаборатории в Международной больнице Форела.
С её компьютера пришло предупреждение Microsoft Defender, и она также упомянула, что при извлечении документа из полученного файла она столкнулась с множеством ошибок, но документ открылся без проблем.
Согласно последним данным разведки об угрозах, WinRAR широко используется для получения первоначального доступа к сетям, и WinRAR — одна из программ, используемых сотрудниками.
Вам предоставили упрощенный образ для начала расследования, пока команда SOC просматривает окружение в поисках других индикаторов атак.

В данном сценарии Вам предстоит проанализировать систему, которая стала целью эксплойта в приложении Winrar и подверглась атакам таких группировок, как RomCom и Paper WereWolf, в 2025 году.

В процессе исследования Вы познакомитесь с методологиями, используемыми в криминалистике MFT (главной файловой таблицей).
А также с известными инструментами применяемыми при анализе артефактов MFT для выявления вредоносной активности.
А именно:

    -   MFTECmd
        Используется для анализа MFT-файла

    -   TimeLine Explorer
        Применяется для открытия и анализа результатов анализа MFT, предварительно сохраненных в формате CSV

=====================================================================
* Задания *
***********

Как и всегда, разбор заданий будет идти по порядку, НО полученные сведения могут перекликаться между заданиями.
Более того, для подтверждения найденной "улики" в одном отчете, необходимо сравнить с данными из другого отчета 
Поэтому НАСТОЯТЕЛЬНО рекомендуется делать записи/пометки

    +++++++++
    + Linux +
    +++++++++

    Если Вы предпочитаете проводить криминалистику MFT файло в среде Linux, то для разбора данного сценария Вам сперва потребуется смонтировать дополнительный образ диска
    Дело в том, что MFT файлы для анализа были предоставленые в качестве Microsoft Disk Image eXtended (.vhdx)
    И если в среде Windows достаточно просто 2 раза кликнуть на файл и он сам смонтируется
    То в среде Linux необходимо провести ряд ручных манипуляций, выполнив следующие команды.

        1)  Сначала необходимо подключить VHDX-файл к сетевому блочному устройству с помощью qemu-nbd.
            Это позволит взаимодействовать с образом диска так же, как с физическим диском.

                <user_name>㉿<host_name> - sudo qemu-nbd --connect=/dev/nbd0 <image_file_name>.vhdx
        
        2)  Затем с помощью fdisk выведите список разделов на подключенном сетевом блочном устройстве.
            Это поможет вам определить, какой раздел нужно смонтировать.

                <user_name>㉿<host_name> - sudo fdisk -l /dev/nbd0
            
            Эта команда отобразит таблицу разделов образа диска.
            Найдите раздел, который хотите смонтировать. В моей системе это устройство /dev/nbd0p1.
        
        3)  Перед монтированием раздела создайте каталог, который будет точкой монтирования.

                <user_name>㉿<host_name> - sudo mkdir -p /mnt/romcom

        4)  Затем мы можем смонтировать найденный раздел в созданный каталог.
            *** Параметр -o ro монтирует раздел в режиме только для чтения, что полезно, если вы хотите гарантировать неизменность его содержимого.

                sudo mount -o ro /dev/nbd0p1 /mnt/romcom

            Наконец, взглянув на монтирование, мы видим два основных объекта: $MFT и $Extend.

    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    + Задание 1 -  Определить название архивного файла в папке «Document <user_name>», который активирует уязвимость при открытии архивного файлая +
    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    Итак, у нас есть MFT образ диска "С"
    Напомню, MFT (Master File Table) - это "основная таблица файлов", которая является важнейшим компонентом NTFS, и в которой хранятся метаданные для всех файлов и каталогов на томе.

    Для анализа файла $MFT мы воспользуемся одиним из инструментов Эрика Циммермана, используемым для исследования файлов MFT - MFT Explorer (MFTECmd.exe)
    MFTECmd анализирует данные из различных файлов, созданных файловой системой NTFS, таких как $MFT, $Boot и т. д.

    Для использования данной утилиты в командной строке нам необходимо ввести следующую команду:

        PS C:\Users\<user_name>> MFTECmd.exe -f <path-to-$MFT-file> --csv <path-to-save-results-in-csv>
    
    Для просмотра результатов обработки MFTECmd файла MFT можно воспользоваться различными инструментами по анализу CSV-файлов
    Я предпочитаю "TimelineExplorer"

    Так как нам известно, что архивный файл находился в папке «Document <user_name>», то спрва отфильтруем столбец "Parent Path" используя  данную информацию 
    В результате у нас должны быть только результаты по фильтру -   \Users\<user_name>\Documents
    
    Если список результатов будет большой, то добавляем фильтр по столбцу "Extensions"
    В который включаем все имеющиеся в этом столбце разширения, связанные с архивами

    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    + Задание 2 - Определить, когда был создан архив с вредоносными файлами на диске? И когда открыт? +
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    Информацию о том, когда был данный файл создан на диске можно подчерпнуть из стоблца "Created0x10"
    А когда создан из столбца "Last Record Change0x10"

    Но так как помимо $MFT у нас есть еще каталог $Extend, в котором находиться USN-журнал обновлений и изменений ($J)
    Что это за журнал я описывать не буду, но рекомендую прочитать о нем в интеренете

    В связи с этим нам надо сконвертировать данный чернал в CSV файл посредством MFTECmd.exe (как мы это делали для $MFT)
    И потом загрузить его в TimelineExplorer для анализа

    Загрузив его в TimelineExplorer, фильтруем все события по столбцу "Name", где указываем название найденного нами файла
    В полученных результатах нас будут интересовать 2 следующих стобца:

        -   Update timestamp
            Указывает на время записи в журнали по тому или иному событию
        
        -   Update Reason
            Непосредственно событие/действие, которое было произведенно с этим файлом (как пользователем, так и системой)
    
    В стобца "Update Reason" нам будут важны следуюущие события, которые характерны для нашего случая:

        -   FileCreate
            Указывает неа событие создания файла на диске
        
        -   ObjectIdChange.
            Указывает на какие-либо события, связанные с изменением атрибутов файла, в том числе и просто открытие файла
    
    Мы конечно может использовать данные из стоблцов файла $MFT
    Но для дополнительного подтверждения лучше использовать данные (в том числе) из файла $J
    
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    + Задание 3 - Определить называние документа, извлеченного из архивного файла, который выглядит как настоящий и отвлекает внимание пользователя +
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    Чтобы найти файлы, которые были извлечены из архива, придется немного постараться

    Дело в том, что извлечь файла можно в два разных места:

        -   В текущую папку (или "Here")
            Т.е. все содержание архива будет извлечено в туже самую папку/каталог, где данный архив расположением
        
        -   В определенное место 
            Т.е. туда, куда вы укажете
    
    Но в том и в другом случае связь с архивом будет сохранена
    Т.е. если Вы отфильтруете в файле $MFT все записи, указав в столбце "File Name" название архива
    То результат Вам выдаст все связи с этим файлом, где особый интерес будет преддоставлять столбец "Parent Path"
    И даже если Вы извлекли содержание архива в другое место, а в архиве был зловред, который в свою очередь создал дополнительные файлы
    То через связь с архивом Вам будут указаны файлы, которые могут находиться в обсалютно непредсказуемых местах

    А чтобы выявить дополнительную связь, нам придется обратиться к стобцу "Created0x10" файла $MFT
    Где мы будем должны отфильтровать события, которые шли после создания (а еще лучше открытия) данного архива
    *** Напомню, что временную метку открытия архива мы смогли выявить из файла $J

    Для дополнительно подтверждения Вы можете "поиграться" с фильтрами в различных столбцах файла $J
    Как правило, зловред сразу же начинает создавать файлы после распаковки архива или обращения к зловреду
    Так, что перечень подохрительных файлов будет следовать один за другим или с небольшим интервалом друг от друга
    *** Но в файле $J вы скорее всего увидите не файлы с архивным расширением, а с расширением .lnk
        Так что используйте не только столбец "Extensions", но и столбец "File Attributes"

    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    + Задание 4 - Определить имя и путь к исполняемому файлу бэкдора, загружаемому архивным файлом +
    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    Тут нам надо найти исполняемый файл.
    Как правило это расширение *.exe, так что быдет искать любые файлы с данным расширением, которые связаны с основным или дополнительным (который мы нашли в предыдущем вопросе) архивом
    *** Конечно, исполняемый файл может иметь и другое расширение, например *.bat или скрипта *.ps1
        Так, что их тоде лучше включить (если они представлены) в фильтр
    И не забываем про временной диапозон    -   оттакливаемся от времени создания самого первого, найденного нами, архива
    А также сверяем наши обнаружения между журналами $MFT и $J

    Как правило, помимо искомого файла, в результатах будут представлены и другие исполнительные файлы
    Почти все они будут легитимными.
    Так что нам стоит обращать внимание на:
        -   необычность в имени
        -   временную метку
        -   общее расположение

    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    + Задание 5 - Определить имя и путь файлу, который создает эксплойт, обеспечивающий сохранение и выполнение бэкдора +
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    Как я говорил ранее, архив со зловредом может содержать множество сюрпризов
    Да и сам зловред парой содежит так называемый "Alternative Stream"  -   это когда помимо основного процесса, в него вшит дополнительный (скрытый) процесс
    Как правило этот процесс устанавливает на диск различные инструменты/файлы.

    Результат такого "Alternative Stream" был обнаружен в предыдущем вопросе в виде исполнительного файла
    Сейчас нам надо обнаружить еще один результат этого "Alternative Stream"
    *** Однако, если Вы будете искать по прямой взаимосвязи между ними (т.е. через основной файл/архив), ты вы врядли что найдете
        Лучше всего искать, через временные метки
    
        1)  Сперва отвфильтуем в основном файле ($MFT) все события произошедшие после даты создания первого архива
            Тоже самое сделаем и в файле $J
        
        2)  Затем оставим только файлы с расширениями, которые мы уже обнаружили
            А также с теме, которые могут быть использованы потенциальными зловредами
            В нашем случае это были: *.rar / *.zip / *.exe / *.lnk / *.ps1 / *.bat / *.pdf
    
        3)  Начинаем изучать последовательность в создании файлов на диске
            И убирать те, которые бы уже обнаружили
            Чаще всего зловреды маскируются в файлах, которые носят вполне безобидные и часто распространенные названия
            Но их расположение не свойственно для таких файлов
            Либо само их наличие выглядит подозрительным

    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    + Задание 6 - Определить когда пользователь открыл файл, указанный в вопросе 3, посчитав его безобидным +
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    Тут все достаточно просто, смотрим:
    
        -   столбец "Last Record Changed0x10" в файле $MFT, и 
        -   столбец "Update Reason", но с фильтром "ObjectIdChange"
    
    И сверям их значения по временным меткам
    
