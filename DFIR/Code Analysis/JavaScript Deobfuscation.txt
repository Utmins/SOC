=====================================================================
* General *
***********

Деобфускация (Deobfuscation) кода — важный навык, который необзодим в области анализа кода и reverse engineering.
Во время анализа кода мы можем сталкнутся с запутанным кодом, который может скрывать определенные функции, например, вредоносное ПО, которое использует запутанный код JavaScript для извлечения своей основной полезной нагрузки.
Не понимая, что делает этот код, мы можем определить, к чему это может привести и, следовательно, не сможем найти решение проблемы

Практически ЛЮБАЯ веб страница состоит из 3 основных элементов:

	HTML		-	используется для определения основных полей и параметров веб-сайта

	CSS			-	используется для определения его дизайна
					Код CSS либо определяется внутри того же HTML-файла между элементами <style>, либо определяется снаружи в отдельном .css-файле и ссылается на него в HTML-коде.

	JavaScript	-	используется для выполнения любых функций, необходимых для запуска веб-сайта
					Он может быть внутренне записан между элементами <script> или записан в отдельный файл .js и ссылаться на него в коде HTML.
                    		
Несмотря на то, что весь этот исходный код доступен на стороне клиента, он отображается нашими браузерами.
Это происходит в фоновом режиме, и мы видим только красивый интерфейс веб-сайта и взаимодействуем с ним.
Поэтому, если мы хотим понять клиентские функции определенной страницы, мы обычно начинаем с рассмотрения исходного кода страницы [CTRL + U].

=====================================================================
* Code Obfusaction *
********************

!!!	Прежде чем начать изучать деобфускацию, мы должны сначала узнать об обфускации кода.
	Не понимая, как обфусцируется код, мы не сможем успешно деобфусцировать код, особенно если он был обфусцирован с помощью пользовательского обфускатора.

Обфускация (Obfuscation)	-	это метод, используемый для того, чтобы сделать скрипт более трудным для чтения людьми, но позволяющий ему функционировать так же с технической точки зрения, хотя производительность может быть ниже.
Обычно это достигается автоматически с помощью инструмента обфускации, который принимает код в качестве входных данных и пытается переписать код таким образом, чтобы его было гораздо труднее читать, в зависимости от его конструкции.
Один из вариантов обфускации кода	-	трансформация кода в словарь всех слов и символов, используемых в коде, для последующего восстановления его в исходный код во время выполнения, ссылаясь на каждое слово и символ из словаря.

Для демонстрации Вы можете воспользовать следующим онлайн ресурсом и обфусцировать вот эту фразу "console.log('HTB JavaScript Deobfuscation Module')"
Он-лайн ресурс	-	http://beautifytools.com/javascript-obfuscator.php
Результат:

	eval(function(p,a,c,k,e,d){e=function(c){return c};if(!''.replace(/^/,String)){while(c--){d[c]=k[c]||c}k=[function(e){return d[e]}];e=function(){return'\\w+'};c=1};while(c--){if(k[c]){p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c])}}return p}('1.0(\'2 3 4 5\')',6,6,'log|console|HTB|JavaScript|Deobfuscation|Module'.split('|'),0,{}))

Коды, написанные на многих языках, публикуются и выполняются без компиляции в интерпретируемых языках, таких как Python, PHP и JavaScript.
В то время как Python и PHP обычно находятся на стороне сервера и, следовательно, скрыты от конечных пользователей, JavaScript обычно используется в браузерах на стороне клиента, а код отправляется пользователю и выполняется в открытом виде.
Вот почему обфускация очень часто используется с JavaScript.

Существует множество причин, по которым разработчики используют обфускацию своего кода.

	i)	Одна из распространенных причин — скрыть исходный код и его функции, чтобы предотвратить его повторное использование или копирование без разрешения разработчика
		Это что затрудняет обратную разработку исходной функциональности кода.

	ii)	Другая причина — обеспечить уровень безопасности при работе с аутентификацией или шифрованием, чтобы предотвратить атаки на уязвимости, которые могут быть обнаружены в коде.
		Следует отметить, что выполнение аутентификации или шифрования на стороне клиента не рекомендуется, поскольку код в этом случае более подвержен атакам.

Однако наиболее распространенное использование обфускации — для вредоносных действий.
Злоумышленники и злоумышленники часто обфускируют свои вредоносные скрипты, чтобы системы обнаружения и предотвращения вторжений не обнаружили их скрипты.

	+++++++++++++++++++++
	+ Basic Obfuscation +
	+++++++++++++++++++++

	Обфускация кода обычно не выполняется вручную, поскольку существует множество инструментов для различных языков, которые выполняют автоматическую обфускацию кода.
	Тем не менее многие злоумышленники и профессиональные разработчики разрабатывают собственные инструменты обфускации, чтобы сделать деобфускацию более сложной.

		///////////////////////////////
		/// Running JavaScript code ///
		///////////////////////////////

		Давайте используем тот же самый пример, что мы использовали ранее (console.log('HTB JavaScript Deobfuscation Module')) попытаемся ее запутать
		Однако сперва давайте протестируем запуск этого кода в открытом тексте, чтобы увидеть, как он работает в действии.
		Мы можем перейти в JSConsole, вставить код и нажать Enter, и увидеть его вывод
		JSConsole	-	https://jsconsole.com/
		В результате мы увидим, что эта строка кода выводит модуль деобфускации JavaScript HTB, что выполняется с помощью функции console.log()

		/////////////////////////////////
		/// Minifying JavaScript code ///
		/////////////////////////////////

		Распространенным способом снижения читабельности фрагмента кода JavaScript при сохранении его полной функциональности является минификация JavaScript Minification.
		Минификация (minification) кода означает, что весь код будет находится в одной (часто очень длинной) строке.
		***	Минификация кода более полезна для объемного длинного кода в несколько строк, так как если бы наш код состоял только из одной строки, он не выглядел бы сильно по-другому после минификации.

		Многие инструменты могут помочь нам минифицировать код JavaScript, например javascript-minifier.
		javascript-minifier	-	https://www.toptal.com/developers/javascript-minifier
		Мы просто копируем наш код и нажимаем Minify, и получаем минифицированный вывод справа
		***	Для наглядной демонстрации, мы добавим что-то в начало нашего кода и разделим его на две строки
			Ну или можете разделить наш код на 2 строки

			i)	Новый код
				
					functionlog(){
						console.log('HTB JavaScript Deobfuscation Module');
					}

			ii)	Наш код

					console.log
 						('HTB JavaScript Deobfuscation Module')

		///////////////////////////////
		/// Packing JavaScript code ///
		///////////////////////////////

		Демонстрируемый ниже тип обфускации известен как packing (упаковка), которая обычно узнаваема по шести аргументам функции, используемым в исходной функции «function(p,a,c,k,e,d)».		

		Теперь давайте запутаем нашу строку кода, чтобы сделать ее более непонятной и трудной для чтения.
		Сначала мы попробуем BeautifyTools, чтобы запутать наш код:
		BeautifyTools	-	https://beautifytools.com/javascript-obfuscator.php
		Для демонстрации используем полученный ранее обфусцированный код	-	eval(function(p,a,c,k,e,d){e=function(c){return c};if(!''.replace(/^/,String)){while(c--){d[c]=k[c]||c}k=[function(e){return d[e]}];e=function(){return'\\w+'};c=1};while(c--){if(k[c]){p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c])}}return p}('1.0(\'2 3 4 5\')',6,6,'log|console|HTB|JavaScript|Deobfuscation|Module'.split('|'),0,{}))

			eval(function(p,a,c,k,e,d){e=function(c){return c.toString(36)};if(!''.replace(/^/,String)){while(c--){d[c.toString(a)]=k[c]||c.toString(a)}k=[function(e){return d[e]}];e=function(){return'\\w+'};c=1};while(c--){if(k[c]){p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c])}}return p}('v(7(p,a,c,k,e,d){e=7(c){8 c};f(!\'\'.h(/^/,o)){9(c--){d[c]=k[c]||c}k=[7(e){8 d[e]}];e=7(){8\'\\\\i+\'};c=1};9(c--){f(k[c]){p=p.h(l j(\'\\\\b\'+e(c)+\'\\\\b\',\'g\'),k[c])}}8 p}(\'1.0(\\\'2 3 4 5\\\')\',6,6,\'u|t|q|r|s|m\'.n(\'|\'),0,{}))',32,32,'|||||||function|return|while||||||if||replace|w|RegExp||new|Module|split|String||HTB|JavaScript|Deobfuscation|console|log|eval'.split('|'),0,{}))

		Мы видим, что наш код стал гораздо более запутанным и трудным для чтения.
		Мы можем скопировать этот код в https://jsconsole.com, чтобы убедиться, что он по-прежнему выполняет свою основную функцию

		Инструмент обфускации "упаковка" обычно пытается преобразовать все слова и символы кода в список или словарь, а затем ссылаться на них с помощью функции (p,a,c,k,e,d) для повторной сборки исходного кода во время выполнения.
		Функция (p,a,c,k,e,d) может отличаться от одного упаковщика к другому.
		Однако она обычно содержит определенный порядок, в котором были упакованы слова и символы исходного кода, чтобы знать, как упорядочить их во время выполнения.

		Хотя упаковщик отлично справляется с уменьшением читаемости кода, мы все равно можем видеть его основные строки, записанные в открытом тексте, что может раскрыть часть его функциональности.
		Вот почему мы можем захотеть поискать лучшие способы обфускации нашего кода.

	++++++++++++++++++++++++
	+ Advanced Obfuscation +
	++++++++++++++++++++++++

	До сих пор нам удавалось сделать наш код обфусцированным и более трудным для чтения.
	Однако код все еще содержит строки в открытом тексте, которые могут раскрыть его изначальную функциональность.
	В этом разделе мы попробуем пару инструментов, которые должны полностью обфусцировать код и скрыть любые остатки его изначальной функциональности.

	Давайте посетим		-	https://obfuscator.io
	
	Перед тем, как нажать кнопку обфускации, мы изменим кодировку массива строк (String Array Encoding) на Base64
	После чего мы можем вставить наш код (console.log('HTB JavaScript Deobfuscation Module');) и нажать «Обфусцировать»
	Если все сделали правильно, то мы получим следующий код:

		var _0x2d4876=_0x58a4;function _0x58a4(_0xb016b8,_0x2ef8a3){var _0x359356=_0x3593();return _0x58a4=function(_0x58a4da,_0x1ac89d){_0x58a4da=_0x58a4da-0x14b;var _0x32fa8d=_0x359356[_0x58a4da];if(_0x58a4['mcaOET']===undefined){var _0x323f06=function(_0x258004){var _0x59d348='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=';var _0x587f04='',_0x193bee='';for(var _0x5b15b6=0x0,_0x2d6385,_0x34a181,_0x3867f1=0x0;_0x34a181=_0x258004['charAt'](_0x3867f1++);~_0x34a181&&(_0x2d6385=_0x5b15b6%0x4?_0x2d6385*0x40+_0x34a181:_0x34a181,_0x5b15b6++%0x4)?_0x587f04+=String['fromCharCode'](0xff&_0x2d6385>>(-0x2*_0x5b15b6&0x6)):0x0){_0x34a181=_0x59d348['indexOf'](_0x34a181);}for(var _0x1364dc=0x0,_0x1c7a13=_0x587f04['length'];_0x1364dc<_0x1c7a13;_0x1364dc++){_0x193bee+='%'+('00'+_0x587f04['charCodeAt'](_0x1364dc)['toString'](0x10))['slice'](-0x2);}return decodeURIComponent(_0x193bee);};_0x58a4['zfCDmD']=_0x323f06,_0xb016b8=arguments,_0x58a4['mcaOET']=!![];}var _0x14bfe6=_0x359356[0x0],_0x4feaba=_0x58a4da+_0x14bfe6,_0x2c01bb=_0xb016b8[_0x4feaba];return!_0x2c01bb?(_0x32fa8d=_0x58a4['zfCDmD'](_0x32fa8d),_0xb016b8[_0x4feaba]=_0x32fa8d):_0x32fa8d=_0x2c01bb,_0x32fa8d;},_0x58a4(_0xb016b8,_0x2ef8a3);}function _0x3593(){var _0x25c14d=['mZmWndyWnhvitKzUtG','mti4mJqXnKr5y2DkuG','odbrD2zAue4','nLDztunRzq','odaWotG1DMLWA25U','nta5nJmWA3bODu1w','mtu1mZC0mgTjuNjIsa','Bg9N','mtCXqxLutLLe','ntKXnJy4EKTUq3r6','sfrciePHDMfty3jPChqGrgvVyMz1C2nHDgLVBIbnB2r1Bgu','mJe4ota1DwvsD3Pl'];_0x3593=function(){return _0x25c14d;};return _0x3593();}(function(_0x3fbaff,_0x3375d7){var _0x54b9c3=_0x58a4,_0x495e4c=_0x3fbaff();while(!![]){try{var _0x41d3e0=-parseInt(_0x54b9c3(0x14f))/0x1+parseInt(_0x54b9c3(0x151))/0x2+-parseInt(_0x54b9c3(0x14c))/0x3+parseInt(_0x54b9c3(0x14b))/0x4+parseInt(_0x54b9c3(0x156))/0x5*(-parseInt(_0x54b9c3(0x14e))/0x6)+-parseInt(_0x54b9c3(0x154))/0x7*(parseInt(_0x54b9c3(0x14d))/0x8)+-parseInt(_0x54b9c3(0x153))/0x9*(-parseInt(_0x54b9c3(0x150))/0xa);if(_0x41d3e0===_0x3375d7)break;else _0x495e4c['push'](_0x495e4c['shift']());}catch(_0x5c1d21){_0x495e4c['push'](_0x495e4c['shift']());}}}(_0x3593,0x6ecd0),console[_0x2d4876(0x152)](_0x2d4876(0x155)));

	Этот код, очевидно, более запутан, и мы не видим никаких остатков нашего исходного кода.
	Теперь мы можем попробовать запустить его в https://jsconsole.com, чтобы убедиться, что он по-прежнему выполняет свою исходную функцию.
	Попробуйте поиграть с настройками запутывания в https://obfuscator.io, чтобы сгенерировать еще более запутанный код, а затем попробуйте повторно запустить его в https://jsconsole.com, чтобы убедиться, что он по-прежнему выполняет свою исходную функцию.

	Теперь мы должны иметь четкое представление о том, как работает обфускация кода.
	Существует еще много вариаций инструментов обфускации кода, каждый из которых обфусцирует код по-разному.

	Мы можем попробовать обфусцировать все тотже код (console.log('HTB JavaScript Deobfuscation Module');) с помощью инструмента в JSF, а затем расшифровать его через JSCONSOLE
	JSF	-	https://jsfuck.com/
	Мы заметим, что выполнение кода может занять некоторое время, что показывает, как обфускация кода может повлиять на производительность, как упоминалось ранее.

	Существует много других обфускаторов JavaScript, таких как JJ Encode или AA Encode.
	Однако такие обфускаторы обычно сильно замедляют выполнение/компиляцию кода, поэтому их не рекомендуется использовать, если только нет очевидной причины, например, обхода веб-фильтров или ограничений.
	JJ Encode	-	https://utf-8.jp/public/jjencode.html
	AA Encode	-	https://utf-8.jp/public/aaencode.html

=====================================================================
* Code Deobfuscation *
**********************

Теперь, когда мы понимаем, как работает обфускация кода, давайте начнем знакомство с деобфускацией.
Так же, как существуют инструменты для автоматического обфускации кода, существуют инструменты для украшения и деобфускации кода автоматически.

Иногда бывает, что интересная (для атакующей стороны) информация может находиться либо в теле самого кода, либо скрыта в скрипте.
Поэтому, визуальный анализ кода - это очень первоочередной этап в процессе поимка какой-либо "зацепки", которая поможет нам осуществить взлом и проникновение.
Если код не содежит какой-либо информации (т.е. был проинспектирован перед деплоингом), то стоит обратить внимание на наличие используемых скриптов.
Как правило это Javacripts.

JavaScript может быть представлен в виде кода
    
	console.log('<BLA-BLA-BLA-BLA>');

Либо в виде ссылки на исполняемый файл, который содежит код и имеет расширение *.js
    
	<script src="<script_name>.js"></script>

	++++++++++++
	+ Beautify +
	++++++++++++

	Мы видим, что весь текущий код, который мы использовали ранее, написан в одну строку.
	Это известно как Minified JavaScript code.
	Чтобы правильно отформатировать код, нам нужно Beautify наш код.
	Самый простой способ сделать это — через наши Browser Dev Tools.

	Например, если бы мы использовали Firefox, мы могли бы открыть отладчик браузера с помощью [ CTRL+SHIFT+Z ], а затем щелкнуть по нашему скрипту <obfuscator_script_file_name>.js
	***	Веб-сайт который бы инспектируете должен иметь JavaScript-файл, содержащий алгоритм шифровния
	Это покажет скрипт в его исходном форматировании
	Но мы можем щелкнуть по кнопке '{ }' (которая находится внизу) и вместо одной строки, код транформируется в многострочное отображение

	Кроме того, мы можем использовать множество онлайн-инструментов или плагинов редактора кода, таких как Prettier или Beautifier.
	Prettier	-	https://prettier.io/playground/
	Beautifier	-	https://beautifier.io/
	Вы можете скопировать код Вашего скрипта в один из этих он-лайн ресурсов для практики

	Однако код все еще не очень легко читать.
	Это потому, что код, с которым мы имеем дело, был не только минифицирован, но и обфусцирован.
	Поэтому простого форматирования или украшения кода будет недостаточно.
	Для этого нам понадобятся инструменты для деобфускации кода.

	+++++++++++++++
	+ Deobfuscate +
	+++++++++++++++

	В интеренет можно много хороших онлайн-инструментов для деобфускации кода JavaScript и превращения его в то, что мы можем понять.
	Одним из хороших инструментов является UnPacker
	UnPacker	-	https://matthewfl.com/unPacker.html
	Вы можете скопировать наш вышеобфусцированный код (который в самом начале этого файла) и запустить его в UnPacker, нажав кнопку UnPack.
	***	Если Вы возьмете второй с верзу обфусцированный код, то Вам придется деобфусцировать его дважды, так как он также был обфусцирован два раза

	+++++++++++++++++++++++
	+ Reverse Engineering +
	+++++++++++++++++++++++

	Хотя эти инструменты пока хорошо справляются с очисткой кода до чего-то, что мы можем понять
	Однако, как только код становится более запутанным и закодированным, автоматизированным инструментам становится намного сложнее его очистить.
	Это особенно верно, если код был запутан с помощью специального инструмента запутывания.

	Нам нужно будет вручную выполнить обратную разработку кода, чтобы понять, как он был запутан, и его функциональность в таких случаях.
	Если вам интересно узнать больше о продвинутой деобфускации и обратной разработке JavaScript, вы можете посетить следущий ресурс (https://academy.hackthebox.com/module/details/38)

=====================================================================
* Deobfuscation Examples *
**************************

	+++++++++++++++++
	+ Code Analysis +
	+++++++++++++++++

	Для разбора данного раздела воспользуемся следующим обфусцированным кодом

		eval(function (p, a, c, k, e, d) { e = function (c) { return c.toString(36) }; if (!''.replace(/^/, String)) { while (c--) { d[c.toString(a)] = k[c] || c.toString(a) } k = [function (e) { return d[e] }]; e = function () { return '\\w+' }; c = 1 }; while (c--) { if (k[c]) { p = p.replace(new RegExp('\\b' + e(c) + '\\b', 'g'), k[c]) } } return p }('g 4(){0 5="6{7!}";0 1=8 a();0 2="/9.c";1.d("e",2,f);1.b(3)}', 17, 17, 'var|xhr|url|null|generateSerial|flag|HTB|1_4m_7h3_53r14l_g3n3r470r|new|serial|XMLHttpRequest|send|php|open|POST|true|function'.split('|'), 0, {}))
	
	И сперва прогоним его через деобфускатор, чтобы получить оригинальный код

		function generateSerial()
			{
			var flag="...SNIP...
				{
				...SNIP...
			}
			";
			var xhr=new XMLHttpRequest();
			var url="/serial.php";
			xhr.open("POST",url,true);
			xhr.send(null)
		}

		/////////////////////
		/// HTTP Requests ///
		/////////////////////

		Давайте рассмотрим каждую строку функции generateSerial.
	
			i)		var xhr=new XMLHttpRequest();
					Функция начинается с определения переменной xhr, которая создает объект XMLHttpRequest.
					Поскольку мы можем не знать точно, что XMLHttpRequest делает в JavaScript, давайте погуглим XMLHttpRequest, чтобы узнать, для чего он используется.
					После того, как мы прочитаем о нем, мы увидим, что это функция JavaScript, которая обрабатывает веб-запросы.

			ii)		var url="/serial.php";
					Вторая определенная переменная — это переменная URL, которая содержит URL для /serial.php, который должен находиться в том же домене, поскольку домен не был указан.

			iii)	xhr.open("POST",url,true);
					Далее мы видим, что xhr.open используется с "POST" и URL.
					Мы можем снова поискать эту функцию в Google и увидеть, что она открывает HTTP-запрос, определенный как "GET или POST", на URL

						xhr	-	это объект XMLHttpRequest, который используется в JavaScript для общения с сервером без перезагрузки страницы.
                                Он позволяет отправлять и получать данные в формате XML, HTML или текстовом формате.
                    
						open()	-	используется для настройки параметров запроса.
                                    В данном случае:
                    					
										"POST"	-	указывает метод запроса, который будет использоваться для отправки данных на сервер.
										
										url		-	Это URL-адрес, на который будет отправлен запрос.
                                    				Обычно это адрес сервера, который будет обрабатывать запрос и возвращать результаты.
                    					
										true 	-	Это асинхронный флаг.
                                    				Если true, то запрос будет выполнен асинхронно, что означает, что выполнение скрипта не останавливается, пока не будет получен ответ от сервера.
                                    				Если false, запрос будет выполнен синхронно, что означает, что выполнение скрипта будет приостановлено до получения ответа от сервера.

			iv)		xhr.send(null)
					А затем следующая строка xhr.send отправит запрос.

		Итак, все, что делает generateSerial, это просто отправляет запрос POST на /serial.php, не включая никаких данных POST и не получая ничего в ответ.

		Разработчики могли реализовать эту функцию всякий раз, когда им нужно было сгенерировать серийный номер, например, при нажатии на определенную кнопку Generate Serial.
		Однако, поскольку мы не видели никаких похожих HTML-элементов, которые генерируют серийные номера, разработчики, должно быть, еще не использовали эту функцию и сохранили ее для будущего использования.

		С помощью деобфускации кода и анализа кода мы смогли обнаружить эту функцию.
		Теперь мы можем попытаться воспроизвести ее функциональность, чтобы увидеть, обрабатывается ли она на стороне сервера при отправке запроса POST.
		Если функция включена и обрабатывается на стороне сервера, мы можем обнаружить невыпущенную функциональность, которая обычно содержит ошибки и уязвимости.

		Как мы уже обнаружили, основная функция данного кода отправляет пустой запрос POST на /serial.php.
		Далее мы попытаемся сделать то же самое с помощью cURL, чтобы отправить запрос POST на /serial.php.
		Чтобы узнать больше о cURL и веб-запросах, вы можете посетить данный ресурс (https://academy.hackthebox.com/module/details/35)

		////////////
		/// cURL ///
		////////////

		cURL — мощный инструмент командной строки, используемый в дистрибутивах Linux, macOS и даже в последних версиях Windows PowerShell.
		Мы можем запросить любой веб-сайт, просто указав его URL, и мы получим его в текстовом формате

			<user_name>@<host_name>$ curl <http://SERVER_IP:PORT/serial.php> OR <http://www.URL.com:PORT/serial.php>
		
		Это будет тот же самый HTML-код, если бы мы решили просмотреть Source Code страницы в браузере.

		////////////////////
		/// POST Request ///
		////////////////////

		Чтобы отправить запрос POST, нам следует добавить флаг -X POST к нашей команде, и она должна отправить запрос POST:

			<user_name>@<host_name>$ -s curl <http://SERVER_IP:PORT/serial.php> OR <http://www.URL.com:PORT/serial.php> -X POST

		Однако запрос POST обычно содержит данные POST.
		Поэтому без отправляемых данных Вы просто исходный получите код страницы		
		
		Чтобы отправить данные, мы можем использовать флаг "-d <param1=sample>" и включить наши данные для каждого параметра следующим образом:

			<user_name>@<host_name>$ -s curl <http://SERVER_IP:PORT/serial.php> OR <http://www.URL.com:PORT/serial.php> -X POST -d "param1=sample"

	++++++++++++
	+ Decoding +
	++++++++++++

	Отправив нужный нам запрос, мы можем получить странный блок текста, который, по-видимому, закодирован

		<user_name>@<host_name>$ curl http://SERVER_IP:PORT/serial.php -X POST -d "param1=sample"

		ZG8gdGhlIGV4ZXJjaXNlLCBkb24ndCBjb3B5IGFuZCBwYXN0ZSA7KQo=

	Это еще один важный аспект обфускации, о котором мы говорили в разделе "Advanced Obfuscation".
	Многие методы могут еще больше запутать код и сделать его менее читаемым для людей и менее обнаруживаемым для систем.
	По этой причине вы очень часто будете находить обфусцированный код, содержащий закодированные текстовые блоки, которые декодируются при выполнении.

	Мы рассмотрим 3 наиболее часто используемых метода кодирования текста

		//////////////
		/// Base64 ///
		//////////////

		Кодировка base64 обычно используется для сокращения использования специальных символов
		Поскольку любые символы, закодированные в base64, будут представлены в виде буквенно-цифровых символов, в дополнение к + и / только.
		Независимо от входных данных, даже если они в двоичном формате, результирующая строка, закодированная в base64, будет использовать только их.

		Строки, закодированные в base64, легко обнаружить, поскольку они содержат только буквенно-цифровые символы.
		Однако наиболее отличительной чертой base64 является его заполнение (окончание) с помощью символов =.
		
		Длина строк, закодированных в base64, должна быть кратна 4.
		Если, например, полученный вывод содержит всего 3 символа, то в качестве заполнения добавляется дополнительный = и т. д.

		Чтобы закодировать любой текст в base64 в Linux, мы можем вывести его на экран и передать с помощью «|» в base64:

			<user_name>@<host_name>$ echo <anything_you_wat> | base64
		
			YW55dGhpbmdfaV93YXQK

		Если мы хотим декодировать любую строку, закодированную в base64, мы можем использовать base64 -d

			<user_name>@<host_name>$ echo <YW55dGhpbmdfaV93YXQK> | base64

			anything_you_wat

		///////////
		/// HEX ///
		///////////

		Другим распространенным методом кодирования является шестнадцатеричное кодирование, которое кодирует каждый символ в его шестнадцатеричном порядке в таблице ASCII.
		Например:

			"a"	-	это 61 в шестнадцатеричном формате
			"b"	-	это 62
			"c"	-	это 63 и т. д.

		Вы можете найти полную таблицу ASCII в Linux с помощью команды "man ascii".

		Любая строка, закодированная в hex, будет состоять только из шестнадцатеричных символов, которых всего 16	-	0-9 и a-f.
		Это делает обнаружение строк в hex-кодировке таким же простым, как и обнаружение строк в base64-кодировке.
		
		Чтобы закодировать любую строку в шестнадцатеричном формате в Linux, можно использовать команду xxd -p:

			<user_name>@<host_name>$ echo <anything_you_wat> | xxd -p

			616e797468696e675f695f7761740a

		Чтобы расшифровать строку в шестнадцатеричном коде, можно использовать команду xxd -p -r:

			<user_name>@<host_name>$ echo <616e797468696e675f695f7761740a> | xxd -p -r

			anything_you_wat

		////////////////////
		/// Caesar/Rot13 ///
		////////////////////

		Другой распространенный - и очень старый - метод кодирования - это шифр Caesar (Caesar cipher), который сдвигает каждую букву на фиксированное число.
		Например, сдвиг на 1 символ делает a -> b, а b -> c и т. д.

		Многие вариации шифра Цезаря используют разное количество сдвигов, наиболее распространенным из которых является rot13, который сдвигает каждый символ на 13 раз вперед.		

		Несмотря на то, что этот метод кодирования делает любой текст случайным, его все равно можно обнаружить, поскольку каждый символ сопоставлен с определенным символом.
		Например, в rot13 http://www становится uggc://jjj, что все еще сохраняет некоторое сходство и может быть распознано как таковое.

		В Linux нет специальной команды для кодирования rot13.
		Однако довольно легко создать собственную команду для сдвига символов:	

			<user_name>@<host_name>$ echo <anything_you_wat> | tr 'A-Za-z' 'N-ZA-Mn-za-m'

			nalguvat_lbh_jng

		Мы можем использовать ту же предыдущую команду для декодирования rot13:

			<user_name>@<host_name>$ echo <nalguvat_lbh_jng> | tr 'A-Za-z' 'N-ZA-Mn-za-m'

			anything_you_wat
	
		Другим вариантом кодирования/декодирования rot13 может быть использование онлайн-инструмента, например rot13
		rot13	-	https://rot13.com/

	Существуют сотни других методов кодирования, которые мы можем найти в сети.
	Несмотря на то, что они являются наиболее распространенными, иногда мы сталкиваемся с другими методами кодирования, для идентификации и декодирования которых может потребоваться определенный опыт.

	Если вы сталкиваетесь с похожими типами кодирования, сначала попробуйте определить тип кодирования, а затем найдите онлайн-инструменты для его декодирования.
	Некоторые инструменты могут помочь нам автоматически определить тип кодирования, например, Cipher Identifier.
	Cipher Identifier	-	https://www.boxentriq.com/code-breaking/cipher-identifier

	Помимо кодирования, многие инструменты обфускации используют шифрование, которое кодирует строку с помощью ключа, что может сильно затруднить обратную разработку и деобфускацию обфусцированного кода, особенно если ключ дешифрования не хранится в самом скрипте.


