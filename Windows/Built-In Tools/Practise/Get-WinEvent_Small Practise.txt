Теперь давайте сосредоточимся на извлечении определенных журналов событий с помощью командлета Get-WinEvent.
В своей основе Get-WinEvent извлекает журналы событий с локальных или удаленных компьютеров.
Примеры ниже демонстрируют, как извлекать события из различных журналов.

    +++++++++++++++++++++++++++++++++++++++++
    + Retrieving events from the System log +
    +++++++++++++++++++++++++++++++++++++++++

    Этот пример извлекает первые 50 событий из системного журнала, что облегчает анализ и устранение неполадок
    Он выбирает определенные свойства, включая:
    
        -   the event's creation time
        -   ID
        -   provider name
        -   level display name
        -   message.
        
        PS C:\....\....> Get-WinEvent -LogName 'System' -MaxEvents 50 | Select-Object TimeCreated, ID, ProviderName, LevelDisplayName, Message | Format-Table -AutoSize

            TimeCreated             Id      ProviderName                             LevelDisplayName   Message
            -----------             --      ------------                             ----------------   -------
            6/2/2023 9:41:42 AM     16      Microsoft-Windows-Kernel-General         Information        The access history in hive \??\C:\Users\Administrator\AppData\Local\Packages\MicrosoftWindows.Client.CBS_cw5...
            6/2/2023 9:38:32 AM     10016   Microsoft-Windows-DistributedCOM         Warning            The machine-default permission settings do not grant Local Activation permission for the COM Server applicat...
            6/2/2023 9:36:14 AM     7001    Microsoft-Windows-Winlogon               Information        User Logon Notification for Customer Experience Improvement Program	
            6/2/2023 9:30:10 AM     1014    Microsoft-Windows-DNS-Client             Warning            Name resolution for the name settings-win.data.microsoft.com timed out after none of the configured DNS serv...
            6/2/2023 9:29:54 AM     7026    Service Control Manager                  Information        The following boot-start or system-start driver(s) did not load: ...
            6/2/2023 9:29:54 AM     10148   Microsoft-Windows-WinRM                  Information        The WinRM service is listening for WS-Management requests. ...
            6/2/2023 9:29:51 AM     51046   Microsoft-Windows-DHCPv6-Client          Information        DHCPv6 client service is started
            --- SNIP ---
    
    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    + Retrieving events from Microsoft-Windows-WinRM/Operational +
    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    В этом примере события извлекаются из журнала Microsoft-Windows-WinRM/Operational.
    
        i)      Чтобы извлечь первые ## (в примере ниже это будут 30 собыьтй) событий из журнала нужно использовать параметр -MaxEvents
        
        ii)     Чтобы извлечь самые старые события, вместо ручной сортировки результатов мы можем использовать параметр -Oldest с командлетом Get-WinEvent.
                Этот параметр позволяет нам извлекать первые события на основе их хронологического порядка.
    
    PS C:\....\....> Get-WinEvent -LogName 'Microsoft-Windows-WinRM/Operational' -MaxEvents 30 | Select-Object TimeCreated, ID, ProviderName, LevelDisplayName, Message | Format-Table -AutoSize

    PS C:\....\....> Get-WinEvent -LogName 'Microsoft-Windows-WinRM/Operational' -Oldest -MaxEvents 30 | Select-Object TimeCreated, ID, ProviderName, LevelDisplayName, Message | Format-Table -AutoSize    
    
    Команда извлекает  и выбирает соответствующие свойства для отображения, включая:
    
        -   event's creation time
        -   ID
        -   provider name
        -   level display name
        -   message.
    
        TimeCreated             Id      ProviderName                LevelDisplayName    Message
        -----------             --      ------------                ----------------    -------
        8/3/2022 4:41:38 PM     145     Microsoft-Windows-WinRM     Information         WSMan operation Enumeration started with resourceUri ...
        8/3/2022 4:41:42 PM     254     Microsoft-Windows-WinRM     Information         Activity Transfer
        8/3/2022 4:41:42 PM     161     Microsoft-Windows-WinRM     Error               The client cannot connect to the destination specifie...
        8/3/2022 4:41:42 PM     142     Microsoft-Windows-WinRM     Error               WSMan operation Enumeration failed, error code 215085...
        8/3/2022 9:51:03 AM     145     Microsoft-Windows-WinRM     Information         WSMan operation Enumeration started with resourceUri ...
        6/2/2023 9:29:54 AM     209     Microsoft-Windows-WinRM     Information         The Winrm service started successfully
    
    ++++++++++++++++++++++++++++++++++++++
    + Retrieving events from .evtx Files +
    ++++++++++++++++++++++++++++++++++++++

    Если у вас есть экспортированный файл .evtx с другого компьютера или вы создали резервную копию существующего журнала, вы можете использовать командлет Get-WinEvent для чтения и запроса этих журналов.
    Эта возможность особенно полезна для целей аудита или когда вам нужно анализировать журналы в скриптах.

    Чтобы получить записи журнала из файла .evtx, вам необходимо указать путь к файлу журнала с помощью параметра -Path.
    Указав путь к файлу журнала с помощью параметра -Path, мы можем извлечь события из этого конкретного файла.
    
    В приведенном ниже примере показано, как читать события из файла 'C:\Tools\chainsaw\EVTX-ATTACK-SAMPLES\Execution\exec_sysmon_1_lolbin_pcalua.evtx', который представляет собой экспортированный журнал Windows PowerShell.
    
    PS C:\....\....> Get-WinEvent -Path 'C:\Tools\chainsaw\EVTX-ATTACK-SAMPLES\Execution\exec_sysmon_1_lolbin_pcalua.evtx' -MaxEvents 5 | Select-Object TimeCreated, ID, ProviderName, LevelDisplayName, Message | Format-Table -AutoSize

    TimeCreated             Id  ProviderName                LevelDisplayName    Message
    -----------             --  ------------                ----------------    -------
    5/12/2019 10:01:51 AM   1   Microsoft-Windows-Sysmon    Information         Process Create:...
    5/12/2019 10:01:50 AM   1   Microsoft-Windows-Sysmon    Information         Process Create:...
    5/12/2019 10:01:43 AM   1   Microsoft-Windows-Sysmon    Information         Process Create:...
    
    Команда выбирает соответствующие свойства и форматирует вывод для более легкого анализа, отображая:
    
        -   event's creation time
        -   ID
        -   provider name
        -   level display name
        -   message.
    
    +++++++++++++++++++++++++++++++++++++++++
    + Filtering events with FilterHashtable +
    +++++++++++++++++++++++++++++++++++++++++

    Для фильтрации журналов событий Windows мы можем использовать параметр -FilterHashtable, который позволяет нам определять конкретные условия для журналов, которые мы хотим получить.

        i)      Параметр ID=# позволит нам отобразить события Sysmon с определенными, интересующими нас, идентификаторами (к примеру - 1 и 3, которые связанны с «опасными» или необычными двоичными файлами), происходящие в течение короткого промежутка времени,
                Это может потенциально указывать на наличие процесса, взаимодействующего с сервером Command and Control (C2)
        
        ii)     Выбор источника определяется параметром LogName (если мы выбираем из имеющихся журналов в EventViewer), или Path (если мы работаем с сохраненным файлом журнала)

        iii)    При одновременном использовании двуъ параметров, но при этом один выдергивает данные из другого, то используется связка @{parametr1='value';paramet2='value'}
                Также, надо помнить, что основной параметр (из которого будут выдергивать данные) идет первым

    К примеру, команда ниже извлекает события с идентификаторами 1 и 3 из журнала событий Microsoft-Windows-Sysmon/Operational, выбирает определенные свойства из этих событий и отображает их в табличном формате.
    Ну или вариант работы с созраненным файлом, где события с темиже идентификаторами извлектся из мохраненного журнала - C:\Tools\chainsaw\EVTX-ATTACK-SAMPLES\Execution\sysmon_mshta_sharpshooter_stageless_meterpreter.evtx

    PS C:\....\....> Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-Sysmon/Operational'; ID=1,3} | Select-Object TimeCreated, ID, ProviderName, LevelDisplayName, Message | Format-Table -AutoSize
    PS C:\....\....> Get-WinEvent -FilterHashtable @{Path='C:\Tools\chainsaw\EVTX-ATTACK-SAMPLES\Execution\sysmon_mshta_sharpshooter_stageless_meterpreter.evtx'; ID=1,3} | Select-Object TimeCreated, ID, ProviderName, LevelDisplayName, Message | Format-Table -AutoSize

    TimeCreated             Id  ProviderName                LevelDisplayName    Message
    -----------             --  ------------                ----------------    -------
    6/15/2019 12:14:32 AM   1   Microsoft-Windows-Sysmon    Information         Process Create:...
    6/15/2019 12:13:44 AM   3   Microsoft-Windows-Sysmon    Information         Network connection detected:...
    6/15/2019 12:13:42 AM   1   Microsoft-Windows-Sysmon    Information         Process Create:...

    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    + Filtering events with FilterHashtable and specific Start/End Date +
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    Предыдущий пример отображает результат связаный с процессом, взаимодействующим с сервером управления и контроля (C2) сразу после его создания.

    Если мы хотим получить журналы событий на основе диапазона дат (28.05.23 - 02.06.2023), это можно сделать следующим образом.

    PS C:\....\....> $startDate = (Get-Date -Year 2023 -Month 5 -Day 28).Date
    PS C:\....\....> $endDate   = (Get-Date -Year 2023 -Month 6 -Day 3).Date
    PS C:\....\....> Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-Sysmon/Operational'; ID=1,3; StartTime=$startDate; EndTime=$endDate} | Select-Object TimeCreated, ID, ProviderName, LevelDisplayName, Message | Format-Table -AutoSize

    *** Примечание: вышеприведенное отфильтрует между начальной датой включительно и конечной датой без учета. Вот почему мы указали 3 июня, а не 2 июня.

    +++++++++++++++++++++++++++++++++++++
    + Filtering events with FilterXPath +
    +++++++++++++++++++++++++++++++++++++

    Дело в том, что стандартная оснастка просмотра событий не поддерживает все функции XPath, что может создавать дополнительные проблемы при фильтрации
    Одним из основных ограничений XPath 1.0 является то, что он не поддерживает поиск по атрибутам.
    То есть, если вы хотите найти события, связанные с определенным EventID, вы можете воспользоваться элементом EventID, но вы не сможете использовать атрибуты, вложенных элементов для поиска событий (например: TargetUserName.)
    
    XPath, в оснастке, не поддерживает регулярные выражения и поиск подстрок, которые могут быть полезны при фильтрации журналов событий Windows.
    Регулярные выражения позволяют искать текстовые строки, соответствующие определенному шаблону, что может быть полезно, например, при поиске IP-адресов или имен файлов.
    Таким образом, недостатки XPath для фильтрации журналов событий Windows заключаются в ограниченных возможностях поиска по атрибутам вложенных элементов, отсутствии некоторых функций сравнения, а также отсутствии поддержки регулярных выражений.

    Чтобы использовать запросы XPath с Get-WinEvent, нам нужно использовать параметр -FilterXPath.
    Это позволяет нам создать запрос XPath для фильтрации журналов событий.

    Например, если мы хотим получить события Process Creation (Sysmon Event ID 1) в журнале Sysmon, чтобы идентифицировать установку любого инструмента Sysinternals, мы можем использовать команду ниже.
    *** Примечание: во время установки инструмента Sysinternals пользователь должен принять представленное лицензионное соглашение.
        Действие принятия включает в себя раздел реестра, включенный в команду ниже.
    
    *** Примечание: Изображение и CommandLine можно идентифицировать, просмотрев XML-представление любого события Sysmon с идентификатором 1, например, с помощью средства просмотра событий.
    
    PS C:\....\....> Get-WinEvent -LogName 'Microsoft-Windows-Sysmon/Operational' -FilterXPath "*[EventData[Data[@Name='Image']='C:\Windows\System32\reg.exe']] and *[EventData[Data[@Name='CommandLine']='`"C:\Windows\system32\reg.exe`" ADD HKCU\Software\Sysinternals /v EulaAccepted /t REG_DWORD /d 1 /f']]" | Select-Object TimeCreated, ID, ProviderName, LevelDisplayName, Message | Format-Table -AutoSize
    
    TimeCreated             Id  ProviderName                LevelDisplayName    Message
    -----------             --  ------------                ----------------    -------
    5/29/2023 12:44:46 AM   1   Microsoft-Windows-Sysmon    Information         Process Create:...
    5/29/2023 12:29:53 AM   1   Microsoft-Windows-Sysmon    Information         Process Create:...
    
    Более того, предположим, что мы хотим исследовать любые сетевые соединения с определенным подозрительным IP-адресом (52.113.194.132), который зарегистрировал Sysmon.
    Для этого мы могли бы использовать следующую команду.

    PS C:\....\....> Get-WinEvent -LogName 'Microsoft-Windows-Sysmon/Operational' -FilterXPath "*[System[EventID=3] and EventData[Data[@Name='DestinationIp']='52.113.194.132']]"
    
    ProviderName: Microsoft-Windows-Sysmon

    TimeCreated             Id  LevelDisplayName    Message
    -----------             --  ----------------    -------
    5/29/2023 6:30:24 PM    3   Information         Network connection detected:...
    5/29/2023 12:32:05 AM   3   Information         Network connection detected:...
    
    +++++++++++++++++++++++++++++++++++++++++++++
    + Filtering events based on property values +
    +++++++++++++++++++++++++++++++++++++++++++++

    Давайте рассмотрим пример, который представит нам все свойства журналов событий Sysmon с идентификатором 1.
    
        i)      Параметр -Property * при использовании с Select-Object указывает команде выбрать все свойства переданных ей объектов.
                В контексте команды Get-WinEvent эти свойства будут включать всю доступную информацию о событии.
    
    PS C:\....\....> Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-Sysmon/Operational'; ID=1} -MaxEvents 1 | Select-Object -Property *

    Message         : Process Create:
                    RuleName: -
                    UtcTime: 2023-06-03 01:24:25.104
                    ProcessGuid: {52ff3419-9649-647a-1902-000000001000}
                    ProcessId: 1036
                    Image: C:\Windows\System32\taskhostw.exe
                    FileVersion: 10.0.19041.1806 (WinBuild.160101.0800)
                    Description: Host Process for Windows Tasks
                    Product: Microsoft® Windows® Operating System
                    Company: Microsoft Corporation
                    OriginalFileName: taskhostw.exe
                    CommandLine: taskhostw.exe -RegisterDevice -ProtectionStateChanged -FreeNetworkOnly
                    CurrentDirectory: C:\Windows\system32\
                    User: NT AUTHORITY\SYSTEM
                    LogonGuid: {52ff3419-85d0-647a-e703-000000000000}
                    LogonId: 0x3E7
                    TerminalSessionId: 0
                    IntegrityLevel: System
                    Hashes: MD5=C7B722B96F3969EACAE9FA205FAF7EF0,SHA256=76D3D02B265FA5768294549C938D3D9543CC9FEF6927
                    4728E0A72E3FCC335366,IMPHASH=3A0C6863CDE566AF997DB2DEFFF9D924
                    ParentProcessGuid: {00000000-0000-0000-0000-000000000000}
                    ParentProcessId: 1664
                    ParentImage: -
                    ParentCommandLine: -
                    ParentUser: -
    Id                   : 1
    Version              : 5
    Qualifiers           :
    Level                : 4
    Task                 : 1
    Opcode               : 0
    Keywords             : -9223372036854775808
    RecordId             : 32836
    ProviderName         : Microsoft-Windows-Sysmon
    ProviderId           : 5770385f-c22a-43e0-bf4c-06f5698ffbd9
    LogName              : Microsoft-Windows-Sysmon/Operational
    ProcessId            : 2900
    ThreadId             : 2436
    MachineName          : DESKTOP-NU10MTO
    UserId               : S-1-5-18
    TimeCreated          : 6/2/2023 6:24:25 PM
    ActivityId           :
    RelatedActivityId    :
    ContainerLog         : Microsoft-Windows-Sysmon/Operational
    MatchedQueryIds      : {}
    Bookmark             : 		System.Diagnostics.Eventing.Reader.EventBookmark
    LevelDisplayName     : Information
    OpcodeDisplayName    : Info
    TaskDisplayName      : Process Create (rule: ProcessCreate)
    KeywordsDisplayNames : {}
    Properties           : {System.Diagnostics.Eventing.Reader.EventProperty,
                    System.Diagnostics.Eventing.Reader.EventProperty,
                    System.Diagnostics.Eventing.Reader.EventProperty,
                    System.Diagnostics.Eventing.Reader.EventProperty...}

    Если мы хотим проверить родительскую командную строку каждого события на наличие строки -enc, а затем вывести все свойства любых соответствующих событий в виде списка.
    То необходимо слешка изменить крмнаду
    
    PS C:\....\....> Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-Sysmon/Operational'; ID=1} | Where-Object {$_.Properties[21].Value -like "*-enc*"} | Format-List

    TimeCreated     : 5/29/2023 12:44:58 AM
    ProviderName    : Microsoft-Windows-Sysmon
    Id              : 1
    Message         : Process Create:
                    RuleName: -
                UtcTime: 2023-05-29 07:44:58.467
                ProcessGuid: {52ff3419-57fa-6474-7005-000000000c00}
                ProcessId: 2660
                Image: C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe
                FileVersion: 4.8.4084.0 built by: NET48REL1
                Description: Visual C# Command Line Compiler
                Product: Microsoft® .NET Framework
                Company: Microsoft Corporation
                OriginalFileName: csc.exe
                CommandLine: "C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe" /noconfig /fullpaths
                @"C:\Users\ADMINI~1\AppData\Local\Temp\z5erlc11.cmdline"
                CurrentDirectory: C:\Users\Administrator\
                User: DESKTOP-NU10MTO\Administrator
                LogonGuid: {52ff3419-57f9-6474-8071-510000000000}
                LogonId: 0x517180
                TerminalSessionId: 0
                IntegrityLevel: High
                Hashes: MD5=F65B029562077B648A6A5F6A1AA76A66,SHA256=4A6D0864E19C0368A47217C129B075DDDF61A6A262388F9D2104
                5D82F3423ED7,IMPHASH=EE1E569AD02AA1F7AECA80AC0601D80D
                ParentProcessGuid: {52ff3419-57f9-6474-6e05-000000000c00}
                ParentProcessId: 5840
                ParentImage: C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe
                ParentCommandLine: "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" -NoProfile
                -NonInteractive -ExecutionPolicy Unrestricted -EncodedCommand JgBjAGgAYwBwAC4AYwBvAG0AIAA2ADUAMAAwADEAIA
                ...SNIP...
                AkAHMAcABsAGkAdABfAHAAYQByAHQAcwBbADAAXQApAAoAJgAkAGUAeABlAGMAXwB3AHIAYQBwAHAAZQByAA==
                ParentUser: DESKTOP-NU10MTO\Administrator

    imeCreated      : 5/29/2023 12:44:57 AM
    ProviderName    : Microsoft-Windows-Sysmon
    Id              : 1
    Message         : Process Create:
                    RuleName: -
                    UtcTime: 2023-05-29 07:44:57.919
                    ProcessGuid: {52ff3419-57f9-6474-6f05-000000000c00}
                    ProcessId: 3060
                    Image: C:\Windows\System32\chcp.com
                    FileVersion: 10.0.19041.1806 (WinBuild.160101.0800)
                    Description: Change CodePage Utility
                    Product: Microsoft® Windows® Operating System
                    Company: Microsoft Corporation
                    OriginalFileName: CHCP.COM
                    CommandLine: "C:\Windows\system32\chcp.com" 65001
                    CurrentDirectory: C:\Users\Administrator\
                    User: DESKTOP-NU10MTO\Administrator
                    LogonGuid: {52ff3419-57f9-6474-8071-510000000000}
                    LogonId: 0x517180
                    TerminalSessionId: 0
                    IntegrityLevel: High
                    Hashes: MD5=33395C4732A49065EA72590B14B64F32,SHA256=025622772AFB1486F4F7000B70CC51A20A640474D6E4DBE95A70
                    BEB3FD53AD40,IMPHASH=75FA51C548B19C4AD5051FAB7D57EB56
                    ParentProcessGuid: {52ff3419-57f9-6474-6e05-000000000c00}
                    ParentProcessId: 5840
                    ParentImage: C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe
                    ParentCommandLine: "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" -NoProfile
                    -NonInteractive -ExecutionPolicy Unrestricted -EncodedCommand JgBjAGgAYwBwAC4AYwBvAG0AIAA2ADUAMAAwADEAIA
                    ...SNIP...
                    AkAHMAcABsAGkAdABfAHAAYQByAHQAcwBbADAAXQApAAoAJgAkAGUAeABlAGMAXwB3AHIAYQBwAHAAZQByAA==
                    ParentUser: DESKTOP-NU10MTO\Administrator
                    --- SNIP ---
    
        i)      Where-Object {$_.Properties[21].Value -like "*-enc*"}
                эта часть команды дополнительно фильтрует извлеченные события на основе следующего за ним блока скрипта.
                    -   $_
                        в блоке скрипта $_ ссылается на текущий объект в конвейере, т. е. на каждое отдельное событие, которое было извлечено и передано из предыдущей команды.

                    -   .Properties[21].Value
                        свойство Properties события Sysmon "Process Create" представляет собой массив, содержащий различные данные о событии.
                        Конкретный индекс 21 соответствует свойству ParentCommandLine события, которое содержит точную командную строку, используемую для запуска процесса.
    
                    -   -like "*-enc*"
                        Это оператор сравнения, который сопоставляет строки на основе подстановочной строки, где * представляет собой любую последовательность символов.
                        В этом случае он ищет любые командные строки, содержащие -enc где-либо внутри.
                        Строка -enc может быть частью подозрительных команд, например, это общий параметр в командах PowerShell для обозначения закодированной команды, которая может использоваться для сокрытия вредоносных скриптов.

        ii)     Format-List
                Этот командлет отображает свойства входных объектов в виде списка, что упрощает чтение и анализ.
    
Представленные далее примеры могут показаться слегка "замороченными", так как выгледят как целый скрипт
Однако, это всего лишь одна команда
Просто использует большой набор параметров
И чтобы не писать все в одну строку, а также иметь возможность ввести несколько переменных/комнад одним блоком, ее ввод переносят на новые строки
Для этого используют { (открывает возвожность ввода построчно, т.н. начало) и } (закрывает ввод блока комнад и/или переменных, т.н. конец)

    +++++++++++++++++++++++++++++++++++++++++++++++
    + Filtering events with FilterHashtable & XML +
    +++++++++++++++++++++++++++++++++++++++++++++++

    Рассмотрим сценарий обнаружения вторжения, где было обнаружено подозрительное сетевое подключение к определенному IP (52.113.194.132).
    При установленном Sysmon вы можете использовать журналы Event ID 3 (Network Connection) для исследования потенциальной угрозы.

    Представленный ниже скрипт:
    
        -   извлечет все события сетевого подключения Sysmon (ID 3)
        -   проанализирует данные XML для каждого события, чтобы получить определенные сведения (исходный IP, целевой IP, GUID процесса и идентификатор процесса)
        -   отфильтрует результаты, включив только события, в которых целевой IP совпадает с предполагаемым IP.

    Кроме того, мы можем использовать ProcessGuid для отслеживания исходного процесса, который установил соединение, что позволит нам понять дерево процессов и идентифицировать любые вредоносные исполняемые файлы или скрипты.
    *** Примечание: Вы можете задаться вопросом, как мы могли узнать о Event.EventData.Data. Формат Windows XML EventLog (EVTX) можно найти здесь   -   https://github.com/libyal/libevtx/blob/main/documentation/Windows%20XML%20Event%20Log%20(EVTX).asciidoc
    
    PS C:\....\....> Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-Sysmon/Operational'; ID=3} |
    `ForEach-Object {
    $xml = [xml]$_.ToXml()
    $eventData = $xml.Event.EventData.Data
    New-Object PSObject -Property @{
        SourceIP = $eventData | Where-Object {$_.Name -eq "SourceIp"} | Select-Object -ExpandProperty '#text'
        DestinationIP = $eventData | Where-Object {$_.Name -eq "DestinationIp"} | Select-Object -ExpandProperty '#text'
        ProcessGuid = $eventData | Where-Object {$_.Name -eq "ProcessGuid"} | Select-Object -ExpandProperty '#text'
        ProcessId = $eventData | Where-Object {$_.Name -eq "ProcessId"} | Select-Object -ExpandProperty '#text'
    }
    }  | Where-Object {$_.DestinationIP -eq "52.113.194.132"}

    DestinationIP   ProcessId   SourceIP        ProcessGuid
    -------------   ---------   --------        -----------
    52.113.194.132  9196        10.129.205.123  {52ff3419-51ad-6475-1201-000000000e00}
    52.113.194.132  5996        10.129.203.180  {52ff3419-54f3-6474-3d03-000000000c00}
    
    В разделе «Подключение к ETW» мы искали аномальную активность загрузки clr.dll и mscoree.dll в процессах, которые обычно не требуют их.
    Команда ниже использует идентификатор события Sysmon 7 для обнаружения загрузки вышеупомянутых DLL.

    PS C:\....\....> $Query = @"
        <QueryList>
            <Query Id="0">
                <Select Path="Microsoft-Windows-Sysmon/Operational">*[System[(EventID=7)]] and *[EventData[Data='mscoree.dll']] or *[EventData[Data='clr.dll']]
                </Select>
            </Query>
        </QueryList>
        "@
    
    PS C:\....\....> Get-WinEvent -FilterXml $Query | ForEach-Object {Write-Host $_.Message `n}
    
    Image loaded:
    RuleName: -
    UtcTime: 2023-06-05 22:23:16.560
    ProcessGuid: {52ff3419-6054-647e-aa02-000000001000}
    ProcessId: 2936
    Image: C:\Tools\GhostPack Compiled Binaries\Seatbelt.exe
    ImageLoaded: C:\Windows\Microsoft.NET\Framework64\v4.0.30319\clr.dll
    FileVersion: 4.8.4515.0 built by: NET48REL1LAST_C
    Description: Microsoft .NET Runtime Common Language Runtime - 	WorkStation
    Product: Microsoft® .NET Framework
    Company: Microsoft Corporation
    OriginalFileName: clr.dll
    Hashes: MD5=2B0E5597FF51A3A4D5BB2DDAB0214531,SHA256=8D09CE35C987EADCF01686BB559920951B0116985FE4FEB5A488A6A8F7C4BDB9,IMPHASH=259C196C67C4E02F941CAD54D9D9BB8A
    Signed: true
    Signature: Microsoft Corporation
    SignatureStatus: Valid
    User: DESKTOP-NU10MTO\Administrator

    Image loaded:
    RuleName: -
    UtcTime: 2023-06-05 22:23:16.544
    ProcessGuid: {52ff3419-6054-647e-aa02-000000001000}
    ProcessId: 2936
    Image: C:\Tools\GhostPack Compiled Binaries\Seatbelt.exe
    ImageLoaded: C:\Windows\System32\mscoree.dll
    FileVersion: 10.0.19041.1 (WinBuild.160101.0800)
    Description: Microsoft .NET Runtime Execution Engine
    Product: Microsoft® Windows® Operating System
    Company: Microsoft Corporation
    OriginalFileName: mscoree.dll
    Hashes: MD5=D5971EF71DE1BDD46D537203ABFCC756,SHA256=8828DE042D008783BA5B31C82935A3ED38D5996927C3399B3E1FC6FE723FC84E,IMPHASH=65F23EFA1EB51A5DAAB399BFAA840074
    Signed: true
    Signature: Microsoft Windows
    SignatureStatus: Valid
    User: DESKTOP-NU10MTO\Administrator
    --- SNIP ---

    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    + Filtering folder with many saved logs to find the creation time of the specific pattern/share +
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    Используя Get-WinEvent необходимо просмотреть все журналы событий, расположенных в каталоге "C:\Tools\chainsaw\EVTX-ATTACK-SAMPLES\Lateral Movement"
    И определите, когда был добавлен ресурс \\*\PRINT.
    Введите время идентифицированного события в формате HH:MM:SS в качестве ответа.

     PS C:\....\....> Get-WinEvent -Path "C:\Tools\chainsaw\EVTX-ATTACK-SAMPLES\Lateral Movement\*.evtx" | 
                        Where-Object { $_.Message -like "*\\*\PRINT*" } |
                        Select-Object -ExpandProperty TimeCreated |
                        Sort-Object -Unique |
                        ForEach-Object { $_.ToString("HH:mm:ss") }

    Объяснение:

        -   Get-WinEvent -Path "C:\Tools\chainsaw\EVTX-ATTACK-SAMPLES\Lateral Movement\*.evtx"
            Обрабатывает все файлы журналов в указанной директории.
    
        -   Where-Object { $_.Message -like "*\\*\PRINT*" }
            Фильтрует события, в которых содержится строка \\*\PRINT.
    
        -   Select-Object -ExpandProperty TimeCreated
            Извлекает только время создания события.
    
        -   Sort-Object -Unique
            Сортирует временные метки и удаляет дубликаты.
    
        -   ForEach-Object { $_.ToString("HH:mm:ss") }
            Форматирует время в нужный формат HH:mm:ss.

    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    + Examining folder with many saved logs to determine the process responsible for executing a DLL hijacking attack +
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    Любой сохраненный лог-файл содержит информацию о том, с помощью какого инструмента(Provider) он был создан/собранн
    Определив инструмент сбора, мы можем понять - по какому EventID нам следует фильтровать события
    В данной задаче это Sysmnon Event ID 7   -   Imageloaded 
    Это событие говорит о том - был ли загружен/использован сторонний файл для запуска легитимного приложения

    Вариантов решения данной задачи может быть 2

        /////////
        /// 1 ///
        /////////

        Это если у нас немного лог-файлов и мы можем провеить их по одному, то делаем следующим образом

            i)      Редактируем конфигурационный файл sysmon, меня в нем слово "include" на "exclude" в разделе про DLL (это 7й раздел)
            ii)     Активируем обновленную конфигурацию, использую команду  -   C:\....\....\....\sysmon.exe -c sysmonconfig-export.xml
            iii)    Фильтруем лог-файл по коду 7 и просматриваем все события
            iv)     Если после фильтрации событий все равно много, то используем следующий XML шаблон

                        <QueryList>
                            <Query Id="0" Path="file://C:\Logs\DLLHijack\DllHijack.evtx">
                                <Select Path="file://C:\Logs\DLLHijack\DllHijack.evtx">*[System[(EventID=7)]] and *[EventData[Data[@Name='Signed'] and (Data='false')]]</Select>
                            </Query>
                        </QueryList>

        /////////
        /// 2 ///
        /////////

        Когда лог-файлов много, то лучше всего использовать комнадлет Get-WinEvent

            i)  Вариант, отображающий всю инормацию каждого события
        
                    Get-WinEvent -Path "C:\Logs\DLLHijack\*.evtx"  -ErrorAction SilentlyContinue | 
                        Where-Object {$_.Id -eq 7 -and $_.Message -like "*Signed=false*"} | 
                        Select-Object TimeCreated, ID, ProviderName, LevelDisplayName, Message
        
            ii) Вариант, отображающий только интресующие поля каждого события

                    Get-WinEvent -FilterHashtable @{Path='C:\Logs\DLLHijack\*.evtx'; ID=7} |
                        ForEach-Object {
                            $xml = [xml]$_.ToXml()
                            $eventData = $xml.Event.EventData.Data
                            $system = $xml.Event.System
                            New-Object PSObject -Property @{
                                RecordTime = $system.TimeCreated.SystemTime
                                EventTime = $eventData | Where-Object {$_.Name -eq "UtcTime"} | Select-Object -ExpandProperty '#text'
                                Image = $eventData | Where-Object {$_.Name -eq "Image"} | Select-Object -ExpandProperty '#text'
                                ImageLoaded = $eventData | Where-Object {$_.Name -eq "ImageLoaded"} | Select-Object -ExpandProperty '#text'
                                Signed = $eventData | Where-Object {$_.Name -eq "Signed"} | Select-Object -ExpandProperty '#text'
                            }
                        } | Where-Object {$_.Image -like "*" -and $_.ImageLoaded -like "*" -and $_.Signed -eq "false" -and $_.UtcTime -like "*" -and $_.RecordTime -like "*"} |
                        Select-Object RecordTime, EventTime, Image, ImageLoaded, Signed |
                        Format-List
                
                Объяснение:

                    1.  Get-WinEvent -FilterHashtable @{Path='C:\Logs\DLLHijack\*.evtx'; ID=7}
                        Эта часть кода используется для извлечения событий из файлов журналов Windows, которые находятся в указанной директории C:\Logs\DLLHijack\ и имеют ID события 7.

                    2.  ForEach-Object { ... }
                        Этот блок обрабатывает каждое событие, полученное из Get-WinEvent.
                        Каждый элемент ($_) из вывода Get-WinEvent передается в ForEach-Object, где происходит дальнейшая обработка данных события.

                    3.  $xml = [xml]$_.ToXml()
                        Каждое событие преобразуется в XML-формат с помощью метода ToXml().
                        В PowerShell XML представлен как объект, который позволяет легко манипулировать его элементами.

                            $_ — это текущее событие.
                            [xml] — это тип данных, который позволяет распарсить строку в формат XML.
                            $_ .ToXml() — преобразует событие в строку XML.
                            Таким образом, $xml теперь содержит XML-представление текущего события.

                    4.  $eventData = $xml.Event.EventData.Data
                        Эта строка извлекает все данные события, которые находятся в элементе <EventData>.
                        Из этого элемента будут извлечены все вложенные теги <Data>, которые содержат нужную информацию (например, UtcTime, Image, ImageLoaded, Signed и другие).

                            $xml.Event — обращение к основному элементу события (<Event>).
                            $xml.Event.EventData — доступ к элементу <EventData>, который содержит информацию о событии.
                            $xml.Event.EventData.Data — доступ ко всем данным внутри тега <Data>.
                            $eventData теперь содержит коллекцию данных для текущего события.

                    5.  $system = $xml.Event.System
                        Этот код извлекает информацию о системе, из которой пришло событие, из элемента <System>.

                            $xml.Event.System — доступ к элементу <System>, который содержит информацию о событии, такую как:
                                TimeCreated (время события),
                                Computer (имя компьютера),
                                Provider (поставщик),
                                и другие.

                    6.  New-Object PSObject -Property @{ ... }
                        Здесь создается новый объект PowerShell (PSObject), который используется для представления данных события в удобном для дальнейшей обработки виде.
                        В этом объекте мы определяем несколько свойств, которые будут взяты из XML-содержимого события.
                        При этом первое значение (к примеру - EventTime) - это то, как оно будет отображаться/называться в выводе
                        А второе (к примеру - UtcTime) - это то, как оно называется в логе
                            
                            RecordTime — время события из элемента <System> (время создания события).
                            EventTime — время из элемента <Data Name="UtcTime">.
                            Image — путь к исполнимому файлу процесса из элемента <Data Name="Image">.
                            ImageLoaded — путь к загруженному образу, который был связан с процессом (например, DLL) из элемента <Data Name="ImageLoaded">.
                            Signed — статус подписи файла (например, true или false), из элемента <Data Name="Signed">.
                            Используя Where-Object, мы фильтруем коллекцию данных и извлекаем только значения для нужных полей.

                    7.  Where-Object {...}
                        Этот блок используется для фильтрации данных, созданных в предыдущем шаге.
                        В нем происходит фильтрация объектов, чтобы оставить только те записи, которые соответствуют указанным условиям:

                            $_ представляет текущий объект, передаваемый через конвейер.
                            $_ .Image -like "*" — проверка, что значение для Image не пустое.
                            $_ .ImageLoaded -like "*" — проверка, что значение для ImageLoaded не пустое.
                            $_ .Signed -eq "false" — фильтрация по полю Signed, чтобы оставить только те события, где оно равно "false".
                            $_ .UtcTime -like "*" — проверка, что UtcTime не пустое.
                            $_ .RecordTime -like "*" — проверка, что RecordTime не пустое.
                    
                    8.  Select-Object RecordTime, EventTime, Image, ImageLoaded, Signed
                        Эта команда выбирает только те свойства объекта, которые будут отображены в конечном выводе. В данном случае выбираются:

                            RecordTime
                            EventTime
                            Image
                            ImageLoaded
                            Signed

    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    + Examining folder with many saved logs to determine determine the process that executed unmanaged PowerShell code +
    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    Данный пример базируется на Sysmon Event ID 8   -   CreateRemoteThread
    Оно обнаруживает, когда процесс создает поток в другом процессе.
    И как правило используется вредоносным ПО для внедрения кода и сокрытия в других процессах.
    Событие указывает исходный и целевой процессы (source and target process).

    Вариантов опять 2:

        /////////
        /// 1 ///
        /////////

        С одним файлом все как всегда:

            i)      Фильтруем по Event ID (можем члибо через меню, либоо через XML-запрос)
            ii)     Интересующие нас поля находятся в разделе EventData:
                        -   SourceImage
                        -   TargetImage
            iii)    Ищем не состыковки
                    Дело в том, что каждый из легитимных процессов, долже запускаться из своего основного местоположения
                    И если какой либо из процессов (Source or Target) распологался не там где должен, то это говорит о потенциальной угрозе
                    В нашем случем приложение(процесс) calc.exe запускался не из-под папки Windows? и вдобавок назывался calculator.exe
        
        /////////
        /// 2 ///
        /////////        

        Источники в интеренете говорят о том, что лучше использовать Event ID 7, так как....
        "Согласно руководству, наличие «Microsoft .NET Runtime…», clr.dll и clrjit.dll в процессах, которые обычно не требуют их, указывает на потенциальные атаки с использованием сборки-исполнения или неуправляемого внедрения PowerShell.
        Эти библиотеки DLL обычно используются для выполнения кода C#. Поэтому стоит искать события, содержащие «clr.dll».
        Результаты посика могут выявить подозрительный исполняемый файл, который не должен иметь доступа к этой библиотеке DLL."

        Для реализации этого способа можно использовать следующую команду:

            Get-WinEvent -Path 'C:\Logs\PowershellExec\*' -ErrorAction SilentlyContinue |
                Where-Object {$_.Id -eq 7 -and $_.Message -like "*crl.dll*"} |
                Select-Object TimeCreated, ID, ProviderName, LevelDisplayName, Message

        Однако, можно использовать и Event ID 8
        На мой взгляд она подходит больше, так как отображает меньше шума
        Но лучше всего использовать эти два события (можно вместе, можно пооочереди)
        И выявить закономерности


            Get-WinEvent -FilterHashtable @{Path='C:\Logs\PowershellExec\*'; ID=8} |
                ForEach-Object {
                    $xml = [xml]$_.ToXml()
                    $eventData = $xml.Event.EventData.Data
                    New-Object PSObject -Property @{
                        SourceImage = $eventData | Where-Object {$_.Name -eq "SourceImage"} | Select-Object -ExpandProperty '#text'
                        TargetImage = $eventData | Where-Object {$_.Name -eq "TargetImage"} | Select-Object -ExpandProperty '#text'
                    }
                } | Where-Object {$_.SourceImage -like "*" -and $_.TargetImage -like "*"}
        
        Как вы можете видеть, данный код оптимиззирован для отображения только необходимых полей
        Но если Вам нужны другие поля, то вы запросто можете отредактировать его по своему усмотрению (см. пример с DLL injection)
    
