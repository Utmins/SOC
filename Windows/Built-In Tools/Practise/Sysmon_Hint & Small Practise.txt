Поскольку большая часть обычной активности или «шума», наблюдаемого в сети, исключается или отфильтровывается с помощью Sysmon, мы можем сосредоточиться на значимых событиях.
Это позволяет нам быстро выявлять и расследовать подозрительную активность.
При активном мониторинге сети вам нужно будет использовать несколько обнаружений и методов одновременно, чтобы выявить угрозы.

В представленных ниже примерах мы рассмотрим только то, как будут выглядеть подозрительные журналы с обеими конфигурациями Sysmon, и как оптимизировать вашу охоту, используя только Sysmon.
Мы рассмотрим, как обнаруживать:

    -   Detecting DLL Hijacking
    -   Detecting Unmanaged PowerShell/C-Sharp Injection

    -   Ransomware
    -   Persistence
    -   Mimikatz (example 1)
    -   Mimikatz (example 2)
    -   Metasploit
    -   Command and Control (C2) beacons.

Sysmon предлагает довольно открытую и настраиваемую платформу для использования.
Существет несколько основных моментов, которые необхожимо всегда учитывать, когда работает над анализом того или иного события
Данные моменты позволят Вам гарантировать, что вы работаете эффективно и не упускаете ни одной потенциальной угрозы.
Вот некоторые из них:

    *)  Exclude > Include (Исключить > Включить)

        При создании правил для вашего файла конфигурации Sysmon обычно лучше всего отдавать приоритет исключению событий, а не включению событий.
        Это не позволит вам случайно пропустить важные события и увидеть только самые важные события.

    *)  Using CLI (использование коммандной строки)
    
        Как и в большинстве приложений, CLI дает вам максимальный контроль и фильтрацию, позволяя осуществлять более детальный контроль.
        Вы можете использовать Get-WinEvent или wevutil.exe для доступа к журналам и их фильтрации.
        По мере включения Sysmon в SIEM или другие решения по обнаружению эти инструменты станут менее используемыми и необходимыми.

        Командная строка обычно используется поверх графического интерфейса Event Viewer, поскольку она обеспечивает более детальный контроль и фильтрацию, в то время как графический интерфейс не позволяет.

    *)  Know your environment before implementation (Знайте свою среду перед внедрением)

        Знание своей среды важно при внедрении любой платформы или инструмента.
        Вам необходимо иметь четкое представление о сети или среде, в которой вы работаете, чтобы полностью понимать, что является нормой, а что подозрительным, и эффективно разрабатывать свои правила.

*** Event Viewer может быть не лучшим средством для фильтрации событий и предлагает ограниченный контроль над журналами.
    Основной фильтр, который вы будете использовать с Event Viewer, — это фильтрация EventID и ключевых слов.
    Вы также можете выбрать фильтрацию путем написания XML, но это утомительный процесс, который плохо масштабируется.

    Альтернативой являетя   -   меню фильтров (Filter Current Log)
    Оно находится в меню Actions.
    Из этого меню мы можем добавлять любые фильтры или категории по своему усмотрению.

*** Для просмотра и фильтрации событий с помощью PowerShell мы будем использовать Get-WinEvent вместе с запросами XPath.
    Мы будем использовать wevutil.exe для просмотра событий после фильтрации.

    Мы можем использовать любые запросы XPath, которые можно найти в представлении событий XML.
    Вот несколько фильтров XPath, которые нам могут пригодиться
    
        -   Filter by Event ID              -   */System/EventID=<ID>
        -   Filter by XML Attribute/Name    -   */EventData/Data[@Name="<XML Attribute/Name>"]
        -   Filter by Event Data            -   */EventData/Data=<Data>

    Мы можем объединить эти фильтры с различными атрибутами и данными, чтобы получить максимальный контроль над нашими журналами.
    
    Вот пример использования Get-WinEvent для поиска сетевых подключений, поступающих с порта 4444

        Get-WinEvent -Path <Path to Log> -FilterXPath '*/System/EventID=3 and */EventData/Data[@Name="DestinationPort"] and */EventData/Data=4444'

    +++++++++++++++++++++++++++
    + Detecting DLL Hijacking +
    +++++++++++++++++++++++++++

    В данном случае мы хотим обнаружить перехват DLL.
    Идентификаторы журнала событий Sysmon, относящиеся к перехватам DLL, можно найти в документации Sysmon  -   https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon
    
    Чтобы обнаружить перехват DLL, нам нужно сосредоточиться на Event Type 7, который соответствует событиям загрузки модуля.
    Для этого нам нужно изменить файл конфигурации Sysmon sysmonconfig-export.xml, который мы скачали с https://github.com/SwiftOnSecurity/sysmon-config.

    Изучив измененную конфигурацию, мы можем заметить, что:
    
        -   Интересующий нас раздел     -   <!--SYSMON EVENT ID 7 : DLL (IMAGE) LOADED BY PROCESS [ImageLoad]-->
        -   Искомое праувило            -   <RuleGroup name="" groupRelation="or">
        -   Редактируемое поле          -   <ImageLoad onmatch="include">
    
    В данном поле комментарий «include» обозначает события, которые должны быть включены.
    В случае обнаружения перехвата DLL мы меняем «include» на «exclude», чтобы гарантировать, что ничего не исключено, что позволяет нам захватить необходимые данные.
    Чтобы использовать обновленную конфигурацию Sysmon, выполните следующее

        C:\....\....\....\sysmon.exe -c sysmonconfig-export.xml
    
    С измененной конфигурацией Sysmon мы можем начать наблюдать за событиями загрузки образа.
    
    Журнал событий содержит статус подписи DLL (в данном случае это подписано Microsoft), процесс или образ, ответственный за загрузку DLL, и конкретную загруженную DLL.
    В нашем примере мы видим, что "MMC.exe" (поле - Image) загрузил "psapi.dll" (поле - ImageLoaded), который также подписан Microsoft.
    Оба файла находятся в каталоге System32.

    Теперь давайте приступим к построению механизма обнаружения, чтобы получить больше информации о перехватах DLL, проведение исследований имеет первостепенное значение.
    Просмотрев различные источники в интеренете, мы натыкаемся на информативную запись в блоге, которая содержит исчерпывающий список различных методов перехвата DLL
    Для целей нашего обнаружения мы сосредоточимся на конкретном перехвате, включающем уязвимый исполняемый файл calc.exe, и списке DLL, которые могут быть перехвачены.

    Давайте попробуем осуществить перехват, используя в качестве примера "calc.exe" и "WININET.dll".
    Чтобы упростить процесс, мы можем использовать рефлексивную DLL "hello world" Стивена Фьюэра.
    *** Следует отметить, что для перехвата DLL не требуются рефлексивные DLL.

    Выполнив необходимые шаги, которые включают:
    
        -   переименование reflective_dll.x64.dll в WININET.dll
        -   перемещение calc.exe из C:\Windows\System32 вместе с WININET.dll в доступный для записи каталог (например, папку Desktop)
        -   выполнение calc.exe, мы достигаем успеха.
    
    В результате, вместо приложения Калькулятор отображается MessageBox.

    Далее мы анализируем влияние взлома.
    Сначала мы фильтруем журналы событий, чтобы сосредоточиться на идентификаторе Event Type 7, представляющем события загрузки модуля.
    Затем мы ищем экземпляры «calc.exe», нажимая «Find...», чтобы определить загрузку DLL, связанную с нашим взломом.
    
    Вывод Sysmon дает ценную информацию.
    Мы можем наблюдать несколько индикаторов компрометации (IOC) для создания эффективных правил обнаружения
    Давайте рассмотрим эти IOC:

        -   "calc.exe", изначально расположенный в System32, не должен находиться в доступном для записи каталоге.
            Следовательно, копия "calc.exe" в доступном для записи каталоге служит IOC, поскольку она всегда должна находиться в System32 или, потенциально, в Syswow64.

        -   "WININET.dll", изначально расположенный в System32, не должен загружаться за пределами System32 с помощью calc.exe.
            Если экземпляры загрузки "WININET.dll" происходят за пределами System32 с "calc.exe" в качестве родительского процесса, это указывает на захват DLL внутри calc.exe.
            Хотя необходимо проявлять осторожность при оповещении обо всех экземплярах загрузки "WININET.dll" за пределами System32 (поскольку некоторые приложения могут упаковывать определенные версии DLL для стабильности)
            Но в случае "calc.exe" мы можем с уверенностью утверждать о захвате из-за неизменного имени DLL, которое злоумышленники не могут изменить, чтобы избежать обнаружения.

        -   Оригинальный "WININET.dll" подписан Microsoft, в то время как наш внедренный DLL остается неподписанным.

    Эти три мощных IOC предоставляют эффективные средства обнаружения перехвата DLL с участием calc.exe.
    Важно отметить, что хотя Sysmon и журналы событий предлагают ценную телеметрию для поиска и создания правил оповещения, они не являются единственными источниками информации.

    ++++++++++++++++++++++++++++++++++++++++++++++++++++
    + Detecting Unmanaged PowerShell/C-Sharp Injection +
    ++++++++++++++++++++++++++++++++++++++++++++++++++++

    Прежде чем углубляться в методы обнаружения, давайте кратко рассмотрим C# и его среду выполнения.
    C# считается «управляемым» языком, то есть для выполнения его кода ему требуется внутренняя среда выполнения.
    Common Language Runtime (CLR) служит этой средой выполнения.
    Управляемый код не запускается напрямую как сборка; вместо этого он компилируется в формат байт-кода, который обрабатывается и выполняется средой выполнения.
    Следовательно, управляемый процесс полагается на CLR для выполнения кода C#.

    Как защитники, мы можем использовать эти знания для обнаружения необычных инъекций или выполнений C# в нашей среде.
    Для этого мы можем использовать полезную утилиту под названием Process Hacker.

    Process Hacker — бесплатная утилита с открытым исходным кодом для мониторинга системных процессов и служб, запущенных под управлением 32-битных и 64-разрядных операционных систем семейства Windows, используемая как замена или дополнение диспетчера задач Windows.

    Используя Process Hacker, мы можем наблюдать ряд процессов в нашей среде.
    Сортируя процессы по имени, мы можем выявить интересные цветовые различия.
    В частности, "powershell.exe", управляемый процесс, выделен зеленым цветом по сравнению с другими процессами.
    При наведении курсора на powershell.exe отображается метка "Процесс управляется (.NET)", подтверждающая его управляемый статус.

    Изучая загрузки модулей для powershell.exe, щелкнув правой кнопкой мыши по powershell.exe, щелкнув «Properties» и перейдя к «Modules», мы можем найти соответствующую информацию.
    Наличие «Microsoft .NET Runtime...», clr.dll и clrjit.dll должно привлечь наше внимание.
    Эти 2 DLL используются, когда код C# запускается как часть среды выполнения для выполнения байт-кода.
    Если мы наблюдаем эти DLL, загруженные в процессы, которые обычно не требуют их, это предполагает потенциальную атаку выполнения сборки или неуправляемой инъекции PowerShell.

    Чтобы продемонстрировать неуправляемую инъекцию PowerShell, мы можем внедрить неуправляемую DLL, похожую на PowerShell, в случайный процесс, например spoolsv.exe.
    Мы можем сделать это, используя проект PSInject следующим образом.

        PS: powershell -ep bypass
            Import-Module .\Invoke-PSInject.ps1
            Invoke-PSInject -ProcId [Process ID of spoolsv.exe] -PoshCode "V3JpdGUtSG9zdCAiSGVsbG8sIEd1cnU5OSEi"
    
    После внедрения мы наблюдаем, что «spoolsv.exe» переходит из неуправляемого в управляемое состояние.
    Кроме того, обращаясь к соответствующей вкладке «Modules» Process Hacker и Sysmon Event ID 7, мы можем изучить информацию о загрузке DLL, чтобы подтвердить наличие вышеупомянутых DLL.

    ++++++++++++++++++++++
    + Hunting Metasploit +
    ++++++++++++++++++++++

    Metasploit можно использовать для легкого запуска эксплойтов на машине и обратного подключения к оболочке meterpreter.
    Поэтому мы будем охотиться за самой оболочкой meterpreter и используемыми ею функциями.
    
    Для начала мы будем искать сетевые соединения, которые исходят из подозрительных портов, таких как 4444 и 5555.
    По умолчанию Metasploit использует порт 4444.
    Если есть соединение с любым известным или неизвестным IP-адресом, его следует исследовать.
        
    Мы также можем искать созданные подозрительные процессы.
    Этот метод охоты можно применять к другим различным RAT и маякам C2.
    *** Для получения дополнительной информации об этой технике и используемых инструментах ознакомьтесь с программным обеспечением MITRE ATT&CK    -   https://attack.mitre.org/software/

    Для получения дополнительной информации о том, как вредоносные программы и полезные нагрузки взаимодействуют с сетью, ознакомьтесь с таблицей общих портов вредоносных программ.
    https://docs.google.com/spreadsheets/d/17pSTDNpa0sf6pHeRhusvWG6rThciE8CsXTSlDUAZDyo/edit?pli=1&gid=0#gid=0

    К примеру:
    
        *)  Сначала мы рассмотрим измененную конфигурацию Ion-Security для обнаружения создания новых сетевых подключений.
            Фрагмент кода ниже будет использовать идентификатор события 3 вместе с портом назначения для идентификации активных подключений, в частности подключений на порту 4444 и 5555.

                <RuleGroup name="" groupRelation="or">
                    <NetworkConnect onmatch="include">
                        <DestinationPort condition="is">4444</DestinationPort>
                        <DestinationPort condition="is">5555</DestinationPort>
                    </NetworkConnect>
                </RuleGroup>
        
        **) Вариант использования командлетов PowerShell будет выглядеть следующим образом (события будут отображены от самого последенего к самому первому)
            Только сперва необходимо подгрузить конфигурационный файл sysmon

                Get-WinEvent -Path <Path to Log> -FilterXPath '*/System/EventID=3 and */EventData/Data[@Name="DestinationPort"] and */EventData/Data=4444'
            
            В результате нам будет отображен список событий, подходящих под наше условие
            А чтобы посмотреть детальную информацию по каждому событию, нужно использовать следующий командлет
    
                Get-WinEvent -Path <Path to Log> -FilterXPath '*/System/EventID=3 and */EventData/Data[@Name="DestinationPort"] and */EventData/Data=4444' | Select-Object -Property *
            
            А для отображения только некоторых событий (допустим 3х последних)

                Get-WinEvent -Path <Path to Log> -FilterXPath '*/System/EventID=3 and */EventData/Data[@Name="DestinationPort"] and */EventData/Data=4444' -MaxEvents 3 | Select-Object -Property *
            
            А для отображения только некоторых событий (допустим 3х первых)

                Get-WinEvent -Path <Path to Log> -FilterXPath '*/System/EventID=3 and */EventData/Data[@Name="DestinationPort"] and */EventData/Data=4444' -Oldest -MaxEvents 3 | Select-Object -Property *

    ++++++++++++++++++++++
    + Detecting Mimikatz +
    ++++++++++++++++++++++

    Mimikatz хорошо известен и обычно используется для дампа учетных данных из памяти вместе с другой постэксплуатационной активностью Windows.
    Mimikatz в основном известен для дампа LSASS.
    Поэтому, мы можем охотиться за:
    
        -   созданным файлом
        -   выполнением файла из процесса с повышенными правами
        -   созданием удаленного потока и процессами, которые создает Mimikatz.
    
    Антивирус обычно обнаруживает Mimikatz, поскольку сигнатура очень хорошо известна, но злоумышленники все еще могут скрыть или использовать дропперы, чтобы загрузить файл на устройство.
    Для этого поиска мы будем использовать пользовательский файл конфигурации, чтобы минимизировать сетевой шум и сосредоточиться на поиске.

    Для получения дополнительной информации об этой технике и используемом программном обеспечении ознакомьтесь с MITRE ATTACK
        T1055   -   https://attack.mitre.org/techniques/T1055/
        S0002   -   https://attack.mitre.org/software/S0002/

    Вы можете загрузить журналы событий, используемые в этой комнате, из этой задачи или открыть их в папке Practice на предоставленной машине.

    К примеру:

        *)  Код, конфигурациооного файла для ПОИСКА ФАЙЛОВ, созданных с именем Mimikatz.
            Это простой метод, но он может позволить вам найти все, что могло обойти AV.
            В большинстве случаев при работе с продвинутой угрозой вам понадобятся более продвинутые методы поиска, такие как поиск поведения LSASS, но этот метод все равно может быть полезен.

            Это очень простой способ обнаружения активности Mimikatz, которая обошла антивирус или другие меры обнаружения.
            Но в большинстве случаев предпочтительнее использовать другие методы, такие как поиск специфичного поведения LSASS.

                <RuleGroup name="" groupRelation="or">
                    <FileCreate onmatch="include">
                        <TargetFileName condition="contains">mimikatz</TargetFileName>
                    </FileCreate>
                </RuleGroup>
            
            Код, конфигурациооного файла для ПОИС НЕНОРМАЛЬНОГО ПОВЕДЕНИЯ LSASS
            Это событие вместе с LSASS будет показывать потенциальное злоупотребление LSASS, которое обычно связано с Mimikatz, каким-либо другим инструментом сброса учетных данных.
            Если к LSASS обращается процесс, отличный от svchost.exe, это следует считать подозрительным поведением и следует изучить его более подробно.
            
            Чтобы помочь в поиске подозрительных событий, вы можете использовать фильтр, чтобы искать только процессы, помимо svchost.exe.
            Sysmon предоставит нам дополнительные сведения, которые помогут в проведении расследования, такие как путь к файлу, из которого возник процесс.
            Для помощи в обнаружении мы будем использовать пользовательский файл конфигурации. 

                <RuleGroup name="" groupRelation="or">
                    <ProcessAccess onmatch="exclude">
                        <SourceImage condition="image">svchost.exe</SourceImage>
                    </ProcessAccess>
                    <ProcessAccess onmatch="include">
                        <TargetImage condition="image">lsass.exe</TargetImage>
                    </ProcessAccess>
                </RuleGroup>

        **) Вариант использования командлетов PowerShell будет выглядеть следующим образом
            Приведенный ниже вариант комнадлете хорош тем, что позволяет нам отфильтровать события, даже если мы не знаем ID события

                Get-WinEvent -Path <Path to Log> -FilterXPath '*/System/EventID=10 and */EventData/Data[@Name="TargetImage"] and */EventData/Data="C:\Windows\system32\lsass.exe"'
            
            Если же мы знаем ID события, то его также модно добавить в комнадлет

                Get-WinEvent -Path <Path to Log> -FilterXPath '*/System/EventID=10 and */EventData/Data[@Name="TargetImage"] and */EventData/Data="C:\Windows\system32\lsass.exe"'

    +++++++++++++++++++++++++++++++++++++++++++
    + Mimikatz - Detecting Credential Dumping +
    +++++++++++++++++++++++++++++++++++++++++++

    Другим критическим аспектом кибербезопасности является обнаружение действий по сбросу учетных данных.
    
    Одним из широко используемых инструментов для сброса учетных данных является Mimikatz, предлагающий различные методы извлечения учетных данных Windows.
    Одна конкретная команда, "sekurlsa::logonpasswords", позволяет сбрасывать хэши паролей или пароли в виде открытого текста, обращаясь к службе Local Security Authority Subsystem Service (LSASS).
    LSASS отвечает за управление учетными данными пользователей и является основной целью для инструментов сброса учетных данных, таких как Mimikatz.

    Атаку можно осуществить следующим образом:

        C:\....\....> mimikatz.exe
            mimikatz # privilege::debug
            ...SNIP...
            mimikatz # sekurlsa::logonpasswords
            ...SNIP...
    
    В результате мы можем увидеть, что вывод команды "sekurlsa::logonpasswords" дает мощное представление о скомпрометированных учетных данных.

    Чтобы обнаружить эту активность, мы можем положиться на другое событие Sysmon.
    Вместо того чтобы сосредоточиться на загрузках DLL, мы переключаем внимание на события доступа к процессам.
    Проверяя идентификатор события Sysmon 10, который представляет события "ProcessAccess", мы можем идентифицировать любые подозрительные попытки доступа к LSASS

    Например, если мы наблюдаем, как случайный файл (в данном случае AgentEXE) из случайной папки (в данном случае Downloads) пытается получить доступ к LSASS, это указывает на необычное поведение.
    Кроме того, SourceUser отличается от TargetUser (например, SourceUser — «waldo», а TargetUser — «SYSTEM»). Это еще больше подчеркивает ненормальность.
    Также стоит отметить, что в рамках процесса сброса учетных данных на основе mimikatz пользователь должен запросить SeDebugPrivileges.
    Как следует из названия, он в основном используется для отладки.
    Это может быть еще одним индикатором компрометации (IOC).

    Обратите внимание, что некоторые легитимные процессы могут получать доступ к LSASS, например, процессы, связанные с аутентификацией, или инструменты безопасности, такие как AV или EDR.

    +++++++++++++++++++
    + Hunting Malware +
    +++++++++++++++++++

    Вредоносное ПО имеет множество форм и вариаций с различными конечными целями.
    Два типа вредоносного ПО, на которых мы сосредоточимся, — это RAT и бэкдоры.
    
    RAT или трояны удаленного доступа используются так же, как и любая другая полезная нагрузка, для получения удаленного доступа к машине.
    Они обычно поставляются с другими антивирусными и методами уклонения от обнаружения, которые отличают их от других полезных нагрузок, таких как MSFVenom.
    Их обычно также использует модель клиент-сервер и поставляется с интерфейсом для простого администрирования пользователей.
    Примерами RAT являются Xeexe и Quasar.
    
    Чтобы помочь обнаружить и выследить вредоносное ПО, нам сначала нужно будет идентифицировать вредоносное ПО, которое мы хотим выследить или обнаружить, и определить способы, которыми мы можем изменить файлы конфигурации, это известно как поиск на основе гипотез.
    Конечно, существует множество других способов обнаружения и регистрации вредоносного ПО, однако мы рассмотрим только базовый способ обнаружения открытых портов обратного подключения.

    К примеру:

        *)  Первая техника, которую мы будем использовать для поиска вредоносного ПО, похожа на процесс поиска Metasploit.
            Используя известные подозрительные порты для включения в наши журналы, мы можем дополнить нашу методологию поиска, в которой мы можем использовать журналы для идентификации злоумышленников в нашей сети
            А затем использовать захваты пакетов или другие стратегии обнаружения для продолжения расследования.

            !!! При использовании файлов конфигурации в производственной среде вы должны быть осторожны и точно понимать, что происходит в файле конфигурации
                Злоумышленники начали использовать порт 53 как часть своего вредоносного ПО/полезной нагрузки, которая осталась бы незамеченной, если бы вы слепо использовали этот файл конфигурации как есть.
            
            Фрагмент кода показаный ниже будет оповещать, когда определенные порты, такие как 1034 и 1604, а также исключать общие сетевые соединения, такие как OneDrive

                <RuleGroup name="" groupRelation="or">
                    <NetworkConnect onmatch="include">
                        <DestinationPort condition="is">1034</DestinationPort>
                        <DestinationPort condition="is">1604</DestinationPort>
                    </NetworkConnect>
                    <NetworkConnect onmatch="exclude">
                        <Image condition="image">OneDrive.exe</Image>
                    </NetworkConnect>
                </RuleGroup>
        
        **) Вариант использования командлетов PowerShell будет выглядеть следующим образом

            Get-WinEvent -Path <Path to Log> -FilterXPath '*/System/EventID=3 and */EventData/Data[@Name="DestinationPort"] and */EventData/Data=<Port>'

    +++++++++++++++++++++++
    + Hunting Persistence +
    +++++++++++++++++++++++

    Persistence используется злоумышленниками для сохранения доступа к машине после ее взлома.
    Существует множество способов, с помощью которых злоумышленник может получить устойчивость на машине.
    Мы сосредоточимся на модификации реестра, а также на сценариях запуска.
    
    Мы можем отслеживать устойчивость с помощью Sysmon, ища события создания файлов, а также события изменения реестра.
    Файл конфигурации SwiftOnSecurity хорошо справляется с задачей целенаправленного определения устойчивости и используемых методов.
    Вы также можете фильтровать по именам правил, чтобы обойти сетевой шум и сосредоточиться на аномалиях в журналах событий.

    К примеру:

        *)  Сначала мы рассмотрим обнаружения для файла(-ов), помещенного в каталоги \Startup\ или \Start Menu.
            Ниже приведен фрагмент конфигурации, который поможет в отслеживании событий для этой техники.
            Для получения дополнительной информации об этой технике ознакомьтесь с MITRE ATT&CK T1547   -   https://attack.mitre.org/techniques/T1547/

                <RuleGroup name="" groupRelation="or">
                    <FileCreate onmatch="include">
                        <TargetFilename name="T1023" condition="contains">\Start Menu</TargetFilename>
                        <TargetFilename name="T1165" condition="contains">\Startup\</TargetFilename>
                    </FileCreate>
                </RuleGroup>
            
            В результате мы видим, что ФАЙЛ был помещен в папку Startup.
            Злоуышленники почти никогда не делают это настолько очевидным, но любые изменения в меню Start должны быть исследованы.
            
            Вы можете настроить файл конфигурации, чтобы он был более детализированным и создавать оповещения, выходящие за пределы тега File Created.
            Мы также можем фильтровать по имени правила T1023

                <RuleGroup name="" groupRelation="or">
                    <RegistryEvent onmatch="include">
                        <TargetObject name="T1060,RunKey" condition="contains">CurrentVersion\Run</TargetObject>
                        <TargetObject name="T1484" condition="contains">Group Policy\Scripts</TargetObject>
                        <TargetObject name="T1060" condition="contains">CurrentVersion\Windows\Run</TargetObject>
                    </RegistryEvent>
                </RuleGroup>

    ++++++++++++++++++++++++++++++++
    + Detecting Evasion Techniques +
    ++++++++++++++++++++++++++++++++

    Существует ряд методов уклонения, используемых авторами вредоносных программ для обхода как антивирусов, так и обнаружений.
    Вот некоторые из них:
        -   альтернативные потоки данных (Alternate Data Streams)
        -   инъекции (Injections)
        -   маскировка (Masquerading)
        -   упаковка/сжатие (Packing/Compression)
        -   перекомпиляция (Recompiling)
        -   обфускация (Obfuscation)
        -   методы предотвращения обратного выполнения (Anti-Reversing Techniques)
    
    Однако мы сосредоточимся на альтернативных потоках данных и инъекциях.
    
    Альтернативные потоки данных используются вредоносными программами для сокрытия своих файлов от обычной проверки путем сохранения файла в другом потоке, отличном от $DATA.
    Sysmon поставляется с идентификатором события для обнаружения недавно созданных и используемых потоков, что позволяет нам быстро обнаруживать и преследовать вредоносное ПО, использующее ADS.
    
    Методы инъекции бывают разных типов:
        -   перехват потока (Thread Hijacking)
        -   PE-инъекция (PE Injection)
        -   DLL-инъекция (DLL Injection)
        -   другие.
    
    Но мы сосредоточимся на DLL-инъекции и бэкдоринге DLL.
    Это делается путем взятия уже используемой DLL, используемой приложением, и перезаписи или включения вашего вредоносного кода в DLL.
    Для получения дополнительной информации об этой методике ознакомьтесь с MITRE ATT&CK T1564 (https://attack.mitre.org/techniques/T1564/004/) и T1055 (https://attack.mitre.org/techniques/T1055/)

    К примеру:

        *)  Alternate Data Streams

            Первая техника, которую мы рассмотрим, — это скрытие файлов с использованием альтернативных потоков данных с помощью Event ID 15.
            Event ID 15 будет хэшировать и регистрировать любые потоки NTFS, включенные в файл конфигурации Sysmon.
            Это позволит нам охотиться за вредоносным ПО, которое уклоняется от обнаружения с помощью ADS.
            
            Для помощи в охоте на ADS мы будем использовать файл конфигурации SwiftOnSecurity Sysmon.
            Фрагмент кода представлен ниже будет охотиться за файлами в папках Temp и Startup, а также с расширениями .hta и .bat.

                <RuleGroup name="" groupRelation="or">
                    <FileCreateStreamHash onmatch="include">
                        <TargetFilename condition="contains">Downloads</TargetFilename>
                        <TargetFilename condition="contains">Temp\7z</TargetFilename>
                        <TargetFilename condition="ends with">.hta</TargetFilename>
                        <TargetFilename condition="ends with">.bat</TargetFilename>
                    </FileCreateStreamHash>
                </RuleGroup>
            
        *)  Detecting Remote Threads 

            Злоумышленники также часто используют удаленные потоки для уклонения от обнаружения в сочетании с другими методами.
            Удаленные потоки создаются с помощью Windows API CreateRemoteThread и могут быть доступны с помощью OpenThread и ResumeThread.
            Это используется в нескольких методах уклонения, включая внедрение DLL, перехват потока и опустошение процесса.
            
            Мы будем использовать Sysmon event ID 8 из файла конфигурации SwiftOnSecurity.
            Фрагмент кода ниже из правила исключит общие удаленные потоки без включения каких-либо конкретных атрибутов, что позволяет создать более открытое и точное правило события.

                <RuleGroup name="" groupRelation="or">
                    <CreateRemoteThread onmatch="exclude">
                        <SourceImage condition="is">C:\Windows\system32\svchost.exe</SourceImage>
                        <TargetImage condition="is">C:\Program Files (x86)\Google\Chrome\Application\chrome.exe</TargetImage>
                    </CreateRemoteThread>
                </RuleGroup>
            
            В результате мы можем видеть (из представленного лога), powershell.exe создает удаленный поток и обращается к notepad.exe.
            Это, очевидно, PoC и теоретически может выполнить любой другой тип исполняемого файла или DLL.
            Конкретная техника, используемая в этом примере, называется Reflective PE Injection.
        
        **) Detecting Evasion Techniques with PowerShell

            Как и в предыдущих задачах, мы будем использовать Get-WinEvent вместе с XPath для фильтрации и поиска файлов
            В обоих событиях нам нужно будет фильтровать только по EventID, поскольку правило, используемое в файле конфигурации, уже выполняет большую часть тяжелой работы.

                Get-WinEvent -Path <Path to Log> -FilterXPath '*/System/EventID=8'
