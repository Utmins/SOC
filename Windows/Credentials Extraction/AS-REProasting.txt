=====================================================================
* Руководство *
***************

Это пошаговое руководство, цель которой — продемонстрировать проблему, а не подробно описать атаку.

Атака будут выполняться с предоставленных машин Windows 10 (WS001) и Kali Linux.
Предполагается, что злоумышленник уже получил remote code execution (или что-то подобное) на этой машине Windows 10 (WS001).
Пользователь, который, как мы предполагаем, скомпрометирован, — это Боб, обычный пользователь в Active Directory без назначенных специальных разрешений.

Окружение состоит из следующих машин и соответствующих им IP-адресов:

	-	DC1		172.16.18.3
	-	DC2		172.16.18.4
	-	Server01	172.16.18.10
	-	PKI		172.16.18.15
	-	WS001		DHCP или 172.16.18.25 (в зависимости от раздела)
	-	Kali Linux	DHCP или 172.16.18.20 (в зависимости от раздела)

Если надо подключиться к любой из управляющих машин AD сервера (к примеру - DC1)

	i)		Поключаемся к хосту жертвы через RDP
	ii)		Пуск -> Windows Accessories -> Remote Desktop
	iii)		Computer	=	DC1 ip address
			User Name	=	Имя пользователя (к примеру htb-student)
	iv)		Пароль введем позже (будет предоставлен запрос)
	v)		Соглашаемся на устанвку соединения
	
=====================================================================
* Легенда *
***********

Атака AS-REProasting похожа на атаку Kerberoasting
Мы можем получить взламываемые хэши для учетных записей пользователей, у которых включено свойство "Do not require Kerberos preauthentication enabled".
Успех этой атаки зависит от надежности пароля учетной записи пользователя, который мы взломаем.

=====================================================================
* Схема атаки *
***************

Чтобы получить взламываемые билеты, мы можем использовать утилиту/интсрумент Rubeus (https://github.com/GhostPack/Rubeus)
Однако на этот раз мы будем использовать действие asreprooast.
Если мы не укажем имя, Rubeus извлечет хэши для каждого пользователя, которому не требуется предварительная аутентификация Kerberos:

Как было сказано ранее - злоумышленник смог создать точку проникновения в систему жертвы и может создавать удаленное подключение
В данном примере атакующая система - Kali Linux, а системы жертвы - Windows

	1)	Подключаемся к жертве через RDP

			:$ xfreerdp /u:<domain_name\\user_name> /p:<password> /v:<target_ip> /dynamic-resolution

	2)	Запускаем утилиту Rubeus (предварительно закачав ее на машину жертвы, в нашем случае в парку Downloads)

			PS C:\Users\bob\Downloads> .\Rubeus.exe asreproast /outfile:asrep.txt

		Как только утилита закончит извлекать хэши, она сообзит Вам, куда они были сохранены

	3)	Затем нам нужно переместить извлеченный файл с билетами на виртуальную машину Kali Linux для взлома
		В данном демонстрационном варианте будет извлечен только один хэш для пользователя Anni, так как для него/нее не требуется предварительная аутентификация

		***	Чтобы облегчить передачу файлов между машинами, предварительно (создателями тестового стенда) была создана общая папка на WS001 (C:\Users\bob\Downloads\Share), доступ к которой можно получить через SMB.
			Сетевой путь папки - \\WS001\Share
	
		Для переноса файла(-ов) на атакующую машину воспользуемся утилитой smbclient (непосредственно из терминала атакующей машины) и комнадами put и/или get

			:$ smbclient \\\\<target_ip>\\Share -U <domain_name>/administrator%<password>
			smb: \> dir
			smb: \> get <file_name>

		Если по умоланию, то файл будет скопирован в корневой каталог текущего пользователя Linux

	4)	Расшифровка хэшей
		Для рашифровки мы будем использовать hashcat
		
		hashcat с hash-mode (опция -m) 18200 для AS-REProasting.
		Также, чтобы hashcat мог распознать хэш, нам нужно отредактировать его, добавив 23$ после $krb5asrep$:
		Мы также передаем файл словаря с паролями (file_with_passwords, к примеру rockyou.txt) и сохраняем вывод всех успешно взломанных билетов в файл cracked.txt

			:$ sudo hashcat -m 18200 -a 0 <file_name> <file_with_passwords>  --outfile asrepcrack.txt --force
		
=====================================================================
* Предотвращение/защита *
*************************

Как и с Kerberos, успех этой атаки зависит от надежности пароля пользователей с настроенной опцией «Do not require Kerberos preauthentication configured».

Прежде всего, мы должны использовать это свойство только при необходимости
Хорошей практикой является ежеквартальная проверка учетных записей, чтобы убедиться, что мы не назначили это свойство.
Поскольку это свойство часто встречается у некоторых обычных учетных записей пользователей, они, как правило, имеют более простые для взлома пароли, чем учетные записи служб с именами SPN (те, что от Kerberoast).
Поэтому для пользователей, которым требуется такая настройка, мы должны назначить отдельную политику паролей, которая требует не менее 20 символов, чтобы помешать попыткам взлома.

=====================================================================
* Обнаружение *
***************

При запуске Rubeus было сгенерировано событие с идентификатором 4768, сигнализирующее о создании билета аутентификации Kerberos

Проблема в том, что AD генерирует это событие для каждого пользователя, который аутентифицируется с помощью Kerberos на любом устройстве
Поэтому присутствие этого события очень распространено.
Однако можно узнать, откуда пользователь аутентифицировался, чтобы мы затем могли использовать это для корреляции известных хороших попыток входа с потенциальными вредоносными извлечениями хэша.

Может быть сложно проверить определенные IP-адреса, особенно если пользователь перемещается по офисным помещениям.
Однако можно тщательно изучить конкретную VLAN и оповестить обо всем, что находится за ее пределами

=====================================================================
* Ловушка/Honeypot *
********************

Для этой атаки пользователь honeypot является отличным вариантом обнаружения для настройки в средах AD
Это должен быть пользователь, который не использует среду в реальной ситуации/не нуждается в ней, так что попытки входа в систему не выполняются регулярно.
Поэтому любая попытка(и) входа в систему для этой учетной записи, скорее всего, вредоносна и требует проверки.

Однако предположим, что пользователь honeypot — это единственная учетная запись, для которой предварительная аутентификация Kerberos не требуется.
В этом случае могут быть лучшие методы обнаружения, поскольку для продвинутых злоумышленников будет совершенно очевидно, что это пользователь honeypot, в результате чего они будут избегать взаимодействия с ним.

Тем не менее, существуют организации, которым нужна была одна из этих учетных записей (связанная с приложением), что «безопасность через неизвестность», стоящая за наличием только одной из этих учетных записей, может спасти их, поскольку злоумышленники будут избегать преследования, думая, что это пользователь honeypot.
Хотя в некоторых случаях это может быть правдой, мы не должны позволять проблеску надежды определять состояние безопасности среды.

Чтобы создать хорошего пользователя honeypot, мы должны обеспечить следующее:

	-	Учетная запись должна быть относительно старым пользователем, в идеале ставшим фиктивным 
		Ибо продвинутые злоумышленники вероятнее не станут запрашивать билеты для новых учетных записей, потому что у них, вероятно, есть надежные пароли и вероятность быть пользователем honeypot.

	-	Для service account user пароль в идеале должен быть старше двух лет.
		Для обычных пользователей сохраняйте пароль, чтобы он не стал старше одного года.

	-	Учетная запись должна иметь записи входов после дня смены пароля
		В противном случае это станет очевидным, если последний день смены пароля совпадает с предыдущим входом.

	-	Учетной записи должны быть назначены некоторые привилегии
		В противном случае не будет интересно пытаться взломать хэш его пароля.

Если мы вернемся к нашей игровой среде и настроим пользователя 'svc-iam' (предположительно, остатки старой учетной записи IAM) с рекомендациями выше, то любой запрос на получение TGT для этой учетной записи должен быть оповещенным. Полученное событие будет выглядеть следующим образом: