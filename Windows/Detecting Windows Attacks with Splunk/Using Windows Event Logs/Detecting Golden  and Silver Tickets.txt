=====================================================================
* Введение *
************

Это пошаговое руководство, цель которой — продемонстрировать проблему, а не подробно описать атаку

Однако, дам один полезнй совет  -   если Вы застряли на каком-то этапе, так как фильтр, который Вы используете не дает нужного ответа, то просто удалите его, НО оставьте только те моменты в которых Вы полностью усовершенствованный
К примеру, Вам надо найти сервис, который был отакован скопроментированным полователем, но используемый фильтр, который вывел Вас на скопроментированного пользователя, не отображает нужную Вам информацию
Тогда, Вам надо удалить все, но оставить только index, username, soureimage (если используете), earliest/latest (если точно уверены во временном диапозоне)
И уже вычленять информацию из предоставленного результата
Более того, желательно знать значение EvenCode or EventID, но на крайний случай спросить интеренет

=====================================================================
* Golden Ticket *
*****************

Атака Golden Ticket — это мощный метод, при котором злоумышленник подделывает Ticket Granting Ticket (TGT) для получения несанкционированного доступа к домену Windows Active Directory в качестве администратора домена.
Злоумышленник создает TGT с произвольными учетными данными пользователя, а затем использует этот поддельный билет, чтобы выдать себя за администратора домена, тем самым получая полный контроль над доменом.
Атака Golden Ticket скрытна и постоянна, поскольку поддельный билет имеет длительный срок действия и остается действительным до истечения срока его действия или отзыва.

Вот как выглядит атака по шагам:

    -   Злоумышленник извлекает NTLM-хэш учетной записи KRBTGT с помощью атаки DCSync (в качестве альтернативы он может использовать дампы процессов NTDS.dit и LSASS на контроллере домена).

    -   Вооружившись хешем KRBTGT, злоумышленник подделывает TGT для произвольной учетной записи пользователя, присваивая ему права администратора домена.
        Для этого можно использовать утилиту Mimikatz

            mimikatz # kerberos::golden /domain:<target.domain.name> /sid:<SID#_of_KRBTGT_account> /rc4:<KRBTGT_NTLM_hash_value> /user:<arbitrary_user_name> /ptt
    
    -   Проверяем успешность интегрированного TGT билета в произвольный аккаунты

            C:\Users\johndoe> klist

        А также возможность опросить удаленную машину (в нашем случем это dc - domain controller) на предоставление нужной информации (к примеру - название установленной ОС)

            C:\Users\johndoe> wmic /node:dc OS GET Name

    +++++++++++++++++++++++++++++++++++++++++
    + Golden Ticket Detection Opportunities +
    +++++++++++++++++++++++++++++++++++++++++

    Обнаружение атак Golden Ticket может быть сложной задачей, поскольку TGT может быть подделан злоумышленником в автономном режиме, практически не оставляя следов выполнения Mimikatz.
    Тем не менее вот несколько вариантов как можно отслеживать распространенные методы извлечения хеша KRBTGT:

        -   Атака DCSync

        -   Доступ к файлу NTDS.dit

        -   Чтение памяти LSASS на контроллере домена (событие Sysmon ID 10)

    С другой точки зрения, Golden Ticket — это просто еще один билет для обнаружения Pass-the-Ticket.

    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    + Detecting Golden Tickets With Splunk (Yet Another Ticket To Be Passed Approach) +
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    Теперь давайте рассмотрим, как можно идентифицировать Overpass-the-Hash с помощью Splunk.

    Представленный ниже фильтр используется для выявления незавершённых Kerberos-аутентификаций (возможно, попытки взлома или сканирования) в Windows Security логах.

        index=main earliest=1690451977 latest=1690452262 source="WinEventLog:Security" user!=*$ EventCode IN (4768,4769,4770) 
        | rex field=user "(?<username>[^@]+)"
        | rex field=src_ip "(\:\:ffff\:)?(?<src_ip_4>[0-9\.]+)"
        | transaction username, src_ip_4 maxspan=10h keepevicted=true startswith=(EventCode=4768)
        | where closed_txn=0
        | search NOT user="*$@*"
        | table _time, ComputerName, username, src_ip_4, service_name, category
    
    Фильтр ищет начатые, но незавершённые Kerberos-аутентификации (4768) от пользовательских учётных записей, исключая машинные, в течение указанного периода времени.

=====================================================================
* Silver Ticket *
*****************

Злоумышленники, обладающие хэшем пароля целевой учетной записи службы (например, SharePoint, MSSQL), могут подделывать билеты Kerberos Ticket Granting Service (TGS), также известные как Silver Tickets.
Серебряные билеты можно использовать для выдачи себя за любого пользователя, но они более ограничены в области действия, чем Golden Tickets, поскольку они позволяют злоумышленникам получать доступ только к определенному ресурсу (например, MSSQL) и системе, в которой размещен этот ресурс.

Вот как выглядит атака по шагам:

    -   Злоумышленник извлекает NTLM-хеш целевой учетной записи службы (или учетной записи компьютера для доступа CIFS) с помощью таких инструментов, как Mimikatz или других методов сброса учетных данных.

    -   Генерация Silver Ticket: используя извлеченный NTLM-хеш, злоумышленник использует такие инструменты, как Mimikatz, для создания поддельного TGS-билета для указанной службы.
        *** Для генерации SIlver Ticket используется такой же модуль что и для Golen - golden

            mimikatz # kerberos::golden /sid:<SID#_of_target_account> /id:### /target:<service.of.target.domain.name> /domain:<target.domain.name> /rc4:<target_NTLM_hash_value> /user:<arbitrary_user_name> /ptt
    
    -   Проверяем успешность интегрированного TGT билета в произвольный аккаунты

            C:\Users\johndoe> klist
        
        А также возможно опросить удаленную машину (в нашем случем это iis  -   web server) на предоставление нужной информации (к примеру - отображение содержание корневого коталога сервера)

            C:\Users\johndoe> ls \\iis.domain.name.local\c$

    +++++++++++++++++++++++++++++++++++++++++
    + Silver Ticket Detection Opportunities +
    +++++++++++++++++++++++++++++++++++++++++

    Обнаружение поддельных билетов на обслуживание (TGS) может быть сложной задачей, поскольку нет простых индикаторов атаки.
    В атаках как Golden Ticket, так и Silver Ticket могут использоваться произвольные пользователи, в том числе несуществующие.
    
    К примеру, Event ID 4720 (A user account was created) может помочь идентифицировать недавно созданных пользователей.
    Впоследствии мы можем сравнить этот список пользователей с вошедшими в систему пользователями.

    Поскольку проверка разрешений пользователей отсутствует, пользователям могут быть предоставлены административные разрешения.
    Для обнаружения аномально назначенных привилегий может использоваться Event ID 4672 (Special Privileges Assigned to New Logon).

    ++++++++++++++++++++++++++++++++++++++++
    + Detecting Silver Tickets With Splunk +
    ++++++++++++++++++++++++++++++++++++++++

    Теперь давайте рассмотрим, как можно идентифицировать Silver Tickets с помощью Splunk
    Рассмотрим на следующих примерах

        /////////////////////////////////////////////////////////////////////
        /// Detecting Silver Tickets With Splunk Through User Correlation ///
        /////////////////////////////////////////////////////////////////////

        В данном примере нам сначала надо создать список пользователей (users.csv), используя Event ID 4720 (A user account was created).

            index=main latest=1690448444 EventCode=4720
            | stats min(_time) as _time, values(EventCode) as EventCode by user
            | outputlookup users.csv

        *** Если у Вас уже есть список пользователей (возможно вы его генерировали когда-то раньше)
            То его можно загрузить прямо в Splunk, нажав Settings -> Lookups -> Lookup table files -> New Lookup Table File.
        
        Затем нам надо сравнить этот список с вошедшими в систему пользователями следующим образом.
        Этот фильтр анализирует успешные входы в систему (событие Windows EventCode=4624) за последние 24 часа, выявляя неизвестных пользователей, которых нет в списке из файла users.csv.

            index=main latest=1690545656 EventCode=4624
            | stats min(_time) as firstTime, values(ComputerName) as ComputerName, values(EventCode) as EventCode by user
            | eval last24h = 1690451977
            | where firstTime > last24h
            ```| eval last24h=relative_time(now(),"-24h@h")```
            | convert ctime(firstTime)
            | convert ctime(last24h)
            | lookup users.csv user as user OUTPUT EventCode as Events
            | where isnull(Events)
        
        Вот расшифровка ключевых моментов фильтра:

            -   stats <.....> by user
                Эта команда группирует указанные параметры по полю "user" и создает таблицу с переименноваными столбцами.

            -   eval "variable" = <value>
                Эта команда определяет переменную "variable" и присваивает ей определенное значение <value> временной метки.
                В нашем примере это значение представляет собой пороговое значение времени для фильтрации результатов.

            -   where firstTime > "variable"
                Данная команда фильтрует результаты, чтобы включить только входы в систему, которые произошли после порогового значения времени, определенного в "variable".

            -   eval l"variable"=relative_time(now(),"-24h@h")
                Эта команда переопределит переменную last24h так, чтобы она была равна точно 24 часам до текущего времени. 
                *** Обратите внимание, что эта строка закомментирована (``` ..... ```) обратными кавычками, поэтому она не будет выполнена в этом поиске.

            -   convert 
                Эта команда осуществляет преобразование значений конкретного поля из одного в другое
                В нашем примере она преобразует поле firstTime из времени эпохи в понятный человеку формат.

            -   lookup
                Эта команда выполняет поиск с использованием файла users.csv, сопоставляет указанное поле из результатов поиска данного фильтра с полем пользователя в файле CSV и выводит столбец EventCode из файла CSV как новое поле с именем Events.

            -   where
                Эта команда фильтрует результаты, чтобы включить только те, которые удовлетворяют условию
                В нашем случае  -   это где поле Events равно null.
                Это означает, что пользователь не был найден в файле users.csv

        //////////////////////////////////////////////////////////////////////////////////////////////////
        /// Detecting Silver Tickets With Splunk By Targeting Special Privileges Assigned To New Logon ///
        //////////////////////////////////////////////////////////////////////////////////////////////////

        Этот фильтр используется для анализа событий с Event ID 4672 (Special Privileges Assigned to New Logon)
        То есть, когда пользователю предоставляются привилегии администратора или других чувствительных прав.

            index=main latest=1690545656 EventCode=4672
            | stats min(_time) as firstTime, values(ComputerName) as ComputerName by Account_Name
            | eval last24h = 1690451977 
            ```| eval last24h=relative_time(now(),"-24h@h") ```
            | where firstTime > last24h 
            | table firstTime, ComputerName, Account_Name 
            | convert ctime(firstTime)
        
        Он ищет впервые появившихся за последние 24 часа пользователей, которым были выданы особые привилегии (EventCode 4672), и показывает:

            -   время первого входа с привилегиями;
            -   имя компьютера, где это произошло;
            -   имя учётной записи.
