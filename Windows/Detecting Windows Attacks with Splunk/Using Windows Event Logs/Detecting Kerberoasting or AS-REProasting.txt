=====================================================================
* Введение *
************

Это пошаговое руководство, цель которой — продемонстрировать проблему, а не подробно описать атаку

Однако, дам один полезнй совет  -   если Вы застряли на каком-то этапе, так как фильтр, который Вы используете не дает нужного ответа, то просто удалите его, НО оставьте только те моменты в которых Вы полностью усовершенствованный
К примеру, Вам надо найти сервис, который был отакован скопроментированным полователем, но используемый фильтр, который вывел Вас на скопроментированного пользователя, не отображает нужную Вам информацию
Тогда, Вам надо удалить все, но оставить только index, username, soureimage (если используете), earliest/latest (если точно уверены во временном диапозоне)
И уже вычленять информацию из предоставленного результата
Более того, желательно знать значение EvenCode or EventID, но на крайний случай спросить интеренет

=====================================================================
* Kerberoasting *
*****************

    Kerberoasting — это метод, нацеленный на учетные записи служб в средах Active Directory для извлечения и взлома их хэшей паролей.
    Атака использует способ шифрования билетов служб Kerberos и использование слабых или легко взламываемых паролей для учетных записей служб.
    После того, как злоумышленник успешно взломает хэши паролей, он может получить несанкционированный доступ к целевым учетным записям служб и потенциально перемещаться по сети.

    Примером атаки Kerberoasting является использование модуля Rubeus kerberoast.
    
        PS C:\Users\johndoe\tools> .\Rubeus.exe kerberoast
    
    Данный модуль (kerberoast) ищет полльзователей текущего домена, которые подверженны данному типу атаки и извлекает следующую информацию для каждого найденного полтзователя

        -   SamAccountName
        -   DistinguishedName
        -   ServicePrincipalName
        -   PwdLastSet
        -   Supported ETypes
        -   Hash Value
    
    Вот как выглядит атака по шагам:

        -   Identify Target Service Accounts
            Атакующий перечисляет Active Directory для идентификации учетных записей служб с установленными именами участников службы (SPN).
            Учетные записи служб часто связаны со службами, работающими в сети, такими как SQL Server, Exchange или другими приложениями.
            
        -   Request TGS Tickets
            Атакующий использует идентифицированные учетные записи служб для запроса билетов Ticket Granting Service (TGS) из Key Distribution Center (KDC).
            Эти билеты TGS содержат зашифрованные хэши паролей учетных записей служб.
        
        -   Offline Brute-Force Attack
            Злоумышленник применяет методы офлайн-перебора, используя такие инструменты взлома паролей, как Hashcat или John the Ripper, чтобы попытаться взломать зашифрованные хеши паролей.

    ++++++++++++++++++++++++++++++++++++++++++++++++++
    + Benign Service Access Process & Related Events +
    ++++++++++++++++++++++++++++++++++++++++++++++++++

    Когда пользователь подключается к базе данных MSSQL (Microsoft SQL Server), используя учетную запись службы с именем SPN, в процессе аутентификации Kerberos происходят следующие шаги:
    Вот как выглядит данный процесс схематично

        +++++++++++++++++               +++++++++++++++++++++++++++++
        +               +-------1)----->+                           +
        +     User      +<------2)------+  Key Distribution Center  +
        +  Workstation  +-------3)----->+           (KDC)           +
        +               +<------4)------+                           +
        +++++++++++++++++               +++++++++++++++++++++++++++++
                |
                |
                5)
                |
                |
                \/
        +++++++++++++++++
        +               +
        +     MSSQL     +
        +    Server     +
        +               +
        +++++++++++++++++
    
        1)  TGT Request
            Пользователь (клиент) инициирует процесс аутентификации, запрашивая билет на предоставление билета (Ticket Granting Ticket - TGT) из центра распространения ключей (KDC), который обычно является частью контроллера домена Active Directory.

        2)  TGT Issue
            KDC проверяет личность пользователя (обычно с помощью хэша пароля) и выдает TGT, зашифрованный с помощью секретного ключа пользователя.
            TGT действителен в течение определенного периода и позволяет пользователю запрашивать билеты на обслуживание без необходимости повторной аутентификации.

        3)  Service Ticket Request
            Клиент отправляет запрос билета на обслуживание (Ticket Granting Service Request - TGS-REQ) в KDC для SPN сервера MSSQL, используя TGT, полученный на предыдущем шаге.

        4)  Service Ticket Issue
            KDC проверяет TGT клиента и, в случае успеха, выдает билет на обслуживание (TGS), зашифрованный с помощью секретного ключа учетной записи службы, содержащий идентификатор клиента и ключ сеанса.
            Затем клиент получает TGS.

        5)  Client Connection
            Клиент подключается к серверу MSSQL и отправляет TGS на сервер в рамках процесса аутентификации.
            Сервер MSSQL расшифровывает TGS, используя свой собственный секретный ключ, чтобы получить ключ сеанса и идентификатор клиента.
            Если TGS действителен и ключ сеанса верен, сервер MSSQL принимает соединение клиента и предоставляет доступ к запрошенным ресурсам.
    
    !!! Обратите внимание, что указанные выше шаги можно также наблюдать во время анализа сетевого трафика посредством Wireshark

        -   События связанные с TGT имеют в своем описание такие ключевые слова как AS-REQ / AS-Responder
        -   События связанные с TGT имеют в своем описание такие ключевые слова как TDS-REQ / TDS-Responder
    
    +++++++++++++++++++++++++++++++++++++++++++++++++
    + Kerberos Authentication in Windows Event Logs +
    +++++++++++++++++++++++++++++++++++++++++++++++++

    В процессе аутентификации Kerberos в журнале событий Windows генерируется несколько событий, связанных с безопасностью, когда пользователь подключается к серверу MSSQL:

        -   Event ID 4768 (Kerberos TGT Request)
            Происходит, когда клиентская рабочая станция запрашивает TGT из KDC, создавая это событие в журнале безопасности на контроллере домена.

        -   Event ID 4769 (Kerberos Service Ticket Request)
            Генерируется после того, как клиент получает TGT и запрашивает TGS для SPN сервера MSSQL.

        -   Event ID 4624 (Logon)
            Регистрируется в журнале безопасности на сервере MSSQL, указывая на успешный вход в систему, как только клиент инициирует подключение к серверу MSSQL и входит в систему, используя учетную запись службы с SPN для установки соединения.

    +++++++++++++++++++++++++++++++++++++++++
    + Kerberoasting Detection Opportunities +
    +++++++++++++++++++++++++++++++++++++++++

    Поскольку начальная фаза Kerberoasting включает в себя идентификацию целевых учетных записей служб, мониторинг активности LDAP, как объясняется в обзоре разведки домена, может помочь в выявлении подозрительных запросов LDAP.

    Альтернативный подход фокусируется на различии между безопасным доступом к службе и атакой Kerberoasting.
    В обоих сценариях будут запрошены билеты TGS для службы
    Но, только в случае безопасного доступа к службе, пользователь подключится к серверу и предоставит билет TGS.

    Логика обнаружения подразумевает поиск всех событий для запросов TGS и событий входа от одного и того же пользователя
    А затем выявление случаев, когда запрос TGS присутствует без последующего события входа.
    В случае доступа к службе IIS с использованием учетной записи службы с SPN будет сгенерировано дополнительное событие 4648 (A logon was attempted using explicit credentials) как событие входа.

    +++++++++++++++++++++++++++++++++++++++
    + Detecting Kerberoasting With Splunk +
    +++++++++++++++++++++++++++++++++++++++

    Теперь давайте рассмотрим, как можно определить Kerberoasting с помощью Splunk.
    Сперва познакомимся с достоверными (Benign) запросами TGS
    А затем изучим некоторые варианты обнаружения Kerberoasing-а

        ///////////////////////////
        /// Benign TGS Requests ///
        ///////////////////////////

        Представленный ниже фильтр предназначен для анализа аутентификаций, особенно тех, которые связаны с Kerberos и логонами с учётными данными.
        Он фильтрует события входа и Kerberos, извлекает имена пользователей без доменов, убирает дубликаты и выводит компактную таблицу с ключевыми атрибутами, удобную для анализа безопасности

            index=main earliest=1690388417 latest=1690388630 EventCode=4648 OR (EventCode=4769 AND service_name=iis_svc) 
            | dedup RecordNumber 
            | rex field=user "(?<username>[^@]+)"
            | table _time, ComputerName, EventCode, name, username, Account_Name, Account_Domain, src_ip, service_name, Ticket_Options, Ticket_Encryption_Type, Target_Server_Name, Additional_Information
    
        Вот расшифровка фильтра:

            -   index, earlier and latest
                Фильтрует поиск, чтобы включить только события из основного индекса, которые произошли между указанными самой ранней и самой поздней временными метками эпохи.

            -   EventCode ИЛИ (EventCode И service_name)
                Фильтрует поиск, чтобы включить только события с EventCode или EventCode с service_name.

            -   dedup
                Удаляет повторяющиеся события на основе поля RecordNumber.
                Это важно для предотвращения повторного анализа одного и того же события

            -   rex field=user
                Извлекает искомое выражение из поля user с помощью регулярного выражения и сохраняет ее в новом поле с именем username

            -   table
                Отображает указанные поля в табличном формате.
        
        Такой запрос часто используют для:

            *   анализа попыток входа через явные учётные данные (4648)
            *   контроля за выдачей Kerberos-билетов к web-сервисам (iis_svc)
            *   охоты на lateral movement / pass-the-ticket / pass-the-hash атаки
            *   или просто мониторинга IIS-аутентификаций в контексте Kerberos.

        //////////////////////////////////////////////
        /// Detecting Kerberoasting - SPN Querying ///
        //////////////////////////////////////////////

        Представленный ниже фильтр выводит события из WinEventLog (SilkService), в которых кто-то выполнял LDAP-запрос на поиск учётных записей с SPN
        Анализируя логи он указывает, что кто-то (или какая-то программа) выполняет LDAP-поиск в Active Directory по фильтру  -   (&(samAccountType=805306368)(servicePrincipalName=*))

            index=main earliest=1690448444 latest=1690454437 source="WinEventLog:SilkService-Log" 
            | spath input=Message 
            | rename XmlEventData.* as * 
            | table _time, ComputerName, ProcessName, DistinguishedName, SearchFilter 
            | search SearchFilter="*(&(samAccountType=805306368)(servicePrincipalName=*)*"

        Вот расшифровка ключевых моментов фильтра:

            -   source
                В данном примере источником данный (помимо index) служит указанный журнал
                
            -   spath
                Используется для разбора вложенных структур в полях, особенно XML/JSON, извлекая вложенные ключи как поля Splunk.
                Он позволяет извлекать структурированные данные JSON или XML, хранящиеся в указанном поле.

            -   rename
                Переименовывает одни поля в другие
                Это упрощает обращение к нужным полям, удаляя префикс

            -   search
                Фильтрует только те события, где в указанном поле (SearchFilter) содержится искомая строка
                samAccountType=805306368 указывает, что объект — обычный пользователь AD (типовая учётка, не группа, не компьютер).

        //////////////////////////////////////////////
        /// Detecting Kerberoasting - TGS Requests ///
        //////////////////////////////////////////////

        Данный фильтр выполняет поиск и фильтрацию событий аутентификации, фокусируясь на необычных Kerberos-запросах без события 4648, в рамках анализа подозрительных активностей.
        Его основная цель   -   выявить подозрительные TGS-запросы к iis_svc, которые происходят без явного логина пользователя (EventCode 4648).

            index=main earliest=1690450374 latest=1690450483 EventCode=4648 OR (EventCode=4769 AND service_name=iis_svc)
            | dedup RecordNumber
            | rex field=user "(?<username>[^@]+)"
            | bin span=2m _time 
            | search username!=*$ 
            | stats values(EventCode) as Events, values(service_name) as service_name, values(Additional_Information) as Additional_Information, values(Target_Server_Name) as Target_Server_Name by _time, username
            | where !match(Events,"4648")

        Вот расшифровка ключевых моментов фильтра:

            -   index, earlier & latest, EventCode ИЛИ (EventCode И service_name)
                Фильтрует поиск, чтобы включить только события из основного индекса, которые произошли между указанными самой ранней и самой поздней временными метками эпохи.
                Также он дополнительно фильтрует поиск, чтобы включить только события с EventCode или EventCode с service_name.
                
            -   dedup
                Удаляет повторяющиеся события на основе указанного поля.
            
            -   rex field=user
                Извлекает искомое выражение из поля user с помощью регулярного выражения и сохраняет ее в новом поле с именем username.
            
            -   bin
                Группирует события в n-минутные интервалы на основе указанного.
            
            -   search
                Отфильтровывает события, в которых указанное поле заканчивается на искомый символ ($).
            
            -   stats
                Группирует значения (velues) событий по выбранным полям (e.i. EventCode) с последующим переименованием этих полей в новые поля (events)
            
            -   where 
                Отфильтровывает события, используя указанный фильтр.

        /////////////////////////////////////////////////////////////////
        /// Detecting Kerberoasting Using Transactions - TGS Requests ///
        /////////////////////////////////////////////////////////////////

        Этот фильтр выполняет поиск подозрительной активности аутентификации, при которой запрос Kerberos билета (4769) не приводит к успешной интерактивной аутентификации (4648) в течение 5 секунд.
        Другими словами он анализирует (и возможно) бнаруживает попытки запроса Kerberos TGT (4769), при которых не последовало аутентификации (4648) в течение 5 секунд

        Хотя он и похож на пердыдущий фильтр, но отличается от него в первую очередь использованием команды transaction, которая группирует события в транзакции на основе указанных полей и критериев.

            index=main earliest=1690450374 latest=1690450483 EventCode=4648 OR (EventCode=4769 AND service_name=iis_svc)
            | dedup RecordNumber
            | rex field=user "(?<username>[^@]+)"
            | search username!=*$ 
            | transaction username keepevicted=true maxspan=5s endswith=(EventCode=4648) startswith=(EventCode=4769) 
            | where closed_txn=0 AND EventCode = 4769
            | table _time, EventCode, service_name, username

        Вот расшифровка ключевых моментов фильтра:

            -   index, earlier & latest, EventCode ИЛИ (EventCode И service_name)
                Фильтрует поиск, чтобы включить только события из основного индекса, которые произошли между указанными самой ранней и самой поздней временными метками эпохи.
                Также он дополнительно фильтрует поиск, чтобы включить только события с EventCode или EventCode с service_name.
            
            -   dedup
                Удаляет повторяющиеся события на основе указанного поля.
            
            -   rex field=user
                Извлекает искомое выражение из поля user с помощью регулярного выражения и сохраняет ее в новом поле с именем username.

            -   search
                Отфильтровывает события, в которых указанное поле заканчивается на искомый символ ($).

            -   transaction with keepevicted= maxspan= endswith= startswith=
                Группирует события в транзакции на основе поля имени пользователя.
                    Параметр keepevicted= включает события, которые не соответствуют критериям транзакции.
                    Параметр maxspan= устанавливает максимальную продолжительность транзакции.
                    Параметры endswith= и startswith= указывают, что транзакции должны начинаться с определенного события с и заканчиваться другим определенным событием.
            
            -   where 
                Отфильтровывает события, используя указанный фильтр.

            -   table
                Отображает указанные поля в табличном формате.

=====================================================================
* AS-REPRoasting *
******************

ASREPRoasting   -   это метод, используемый в средах Active Directory для атаки на учетные записи пользователей без включенной предварительной аутентификации.
В Kerberos предварительная аутентификация   -   это функция безопасности, требующая от пользователей подтверждения своей личности до выдачи TGT.
Однако для некоторых учетных записей пользователей, например с неограниченным делегированием, предварительная аутентификация не включена, что делает их уязвимыми для атак ASREPRoasting.

Для атак типа AS-REPRoasting также используют утилиту Rubeus, но уже с другим модулем   -   asreproast

    PS C:\Users\johndoe\tools> .\Rubeus.exe asreproast

Данный модуль (asreproast) ищет пользователей текущего домена, у которых отключена опция "Account requires Kerberos preauthentication" 
Найдя такого пользователя вы получите следующую информацию о нем

        -   Target Domain
        -   Searching Path
        -   SamAccountName
        -   DistinguishedName
        -   Using domain controller
        -   AS-REP Hash Value

Вот как выглядит атака по шагам:

    -   Identify Target User Accounts
        Злоумышленник идентифицирует учетные записи пользователей без включенной предварительной аутентификации.

    -   Request AS-REQ Service Tickets
        Злоумышленник инициирует запрос билета на обслуживание AS-REQ для каждой идентифицированной целевой учетной записи пользователя.
        
    -   Offline Brute-Force Attack
        Злоумышленник захватывает зашифрованные TGT и применяет методы подбора паролей в автономном режиме, чтобы попытаться взломать хэши паролей.

Как Вы могли заметеить  -   отличие KERBERroast от AS-REProast состоит в том, что в первом случае идет атака на межсервисовый досут, т.е. злоумышленник пытается взломать не сам пароль пользователя, а его возможность подключаться к различным сервисам без постоянной авторизации
Тогда как во втором варианте, злоумышленник атакует слабозащищенные (имеющие конкретную уязвимость) аккаунты

    +++++++++++++++++++++++++++++++
    + Kerberos Pre-Authentication +
    +++++++++++++++++++++++++++++++

    Предварительная аутентификация Kerberos -   это дополнительный механизм безопасности в протоколе аутентификации Kerberos, который усиливает защиту учетных данных пользователя во время процесса аутентификации.
    Когда пользователь пытается получить доступ к сетевому ресурсу или службе, клиент отправляет запрос аутентификации AS-REQ в KDC.

    Если предварительная аутентификация включена, этот запрос также содержит зашифрованную временную метку (pA-ENC-TIMESTAMP).
    KDC пытается расшифровать эту временную метку с помощью хэша пароля пользователя и, в случае успеха, выдает пользователю TGT.
    В этом случае, анализ пакетов, относящихся к Kerberos, при помощи Wireshark, будет содержать следующие записи:

        Kerberos
            as-requires
                padata: 2 items
                    > PA-DATA pA-ENC-TIMESTAMP
                    > PA-DATA pA-PAC-REQUEST

    Если предварительная аутентификация отключена, KDC не выполняет проверку временной метки, что позволяет пользователям запрашивать билет TGT, не зная пароля пользователя.
    В этом случае, анализ пакетов, относящихся к Kerberos, при помощи Wireshark, будет содержать следующие записи

        Kerberos
            as-requires
                padata: 1 item
                    > PA-DATA pA-PAC-REQUEST

    ++++++++++++++++++++++++++++++++++++++++++
    + AS-REPRoasting Detection Opportunities +
    ++++++++++++++++++++++++++++++++++++++++++

    Подобно Kerberoasting, начальная фаза AS-REPRoasting включает в себя идентификацию учетных записей пользователей с включенным неограниченным делегированием или учетных записей без предварительной аутентификации, которые могут быть обнаружены мониторингом LDAP.

    Идентификатор события аутентификации Kerberos (Event ID 4768 "TGT Request") содержит атрибут PreAuthType в дополнительной информационной части события, указывающий, включена ли предварительная аутентификация для учетной записи.

    ++++++++++++++++++++++++++++++++++++++++
    + Detecting AS-REPRoasting With Splunk +
    ++++++++++++++++++++++++++++++++++++++++

    Теперь давайте рассмотрим, как можно определить AS-REPRoasting с помощью Splunk.

        ///////////////////////////////////////////////////////////////////////////
        /// Detecting AS-REPRoasting - Querying Accounts With Pre-Auth Disabled ///
        ///////////////////////////////////////////////////////////////////////////

        Мы уже рассматривали похожий фильтр, когда знакомились с методом    -   "Detecting Kerberoasting - SPN Querying"
        Однако, фильтр представленный ниже, содержит более тонкий поисковой запрос
        А именно, он ищет уязвимые или неправильно настроенный аккаунты со слабой крпитозащитой

            index=main earliest=1690392745 latest=1690393283 source="WinEventLog:SilkService-Log" 
            | spath input=Message 
            | rename XmlEventData.* as * 
            | table _time, ComputerName, ProcessName, DistinguishedName, SearchFilter 
            | search SearchFilter="*(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=4194304)*"

        Поэтому, я разясню, только отличающийся элемент данного фильтра:

            -   search
                Содержанием значения части поля "SearchFilter"   -    userAccountControl, использует побитовый фильтр
                4194304 = USE_DES_KEY_ONLY (объекты, использующие только DES-шифрование Kerberos)
                Но на практике, этот бит также может ассоциироваться с учетными записями, поддерживающими только RC4 и DES, что делает их уязвимыми к Kerberoasting.

        ///////////////////////////////////////////////////////////////////////////////////
        /// Detecting AS-REPRoasting - TGT Requests For Accounts With Pre-Auth Disabled ///
        ///////////////////////////////////////////////////////////////////////////////////

        Данный фильтр ищет события Kerberos-аутентификации, но без предаутентификации (что может быть индикатором атаки), с последующим извлеченим IP-адреса атакующего и имен пользователей, которые были подвержены атаки

            index=main earliest=1690392745 latest=1690393283 source="WinEventLog:Security" EventCode=4768 Pre_Authentication_Type=0
            | rex field=src_ip "(\:\:ffff\:)?(?<src_ip>[0-9\.]+)"
            | table _time, src_ip, user, Pre_Authentication_Type, Ticket_Options, Ticket_Encryption_Type
        
        Данный фильтр достаточно прост
        Однаком следующие его элементы весьма интересны

            -   EventCode=4768
                Событие Kerberos Authentication Ticket (TGT) Request.
                Это событие появляется, когда клиент запрашивает билет Kerberos TGT у KDC

            -   Pre_Authentication_Type
                Фильтруются события, связанные с предаутентификацией
                Значение 0 означает, что предаутентификация не использовалась
            
            -   rex
                Использует регулярное выражение для извлечения необходимой информации.
                В нашем случае - поля src_ip (исходный IP-адрес)
                Также оно очищает IP-адреса, которые могли прийти в виде ::ffff:###.###.###.### оставляя только ###.###.###.###

=====================================================================
* Практика *
************

Необходимо найти имя пользователя, который инициировал процесс, выполнивший запрос LDAP, содержащий строку «*(&(samAccountType=805306368)(servicePrincipalName=*)*» в 2023-07-26 16:42:44

Решение будет двухэтапным, так как используемые фильтры будут дополнять друг друга

    1)  Сперва нам надо найти LDAP запрос, содержащий строку «*(&(samAccountType=805306368)(servicePrincipalName=*)*» в 2023-07-26 16:42:44
        Для этого воспользуемся фильтром "Detecting Kerberoasting - SPN Querying"
        Но без отображения результатов в виде таблицы, так как надо будет детально изучить содержание искомой записи (2023-07-26 16:42:44)

            index=main source="WinEventLog:SilkService-Log" 
                    | spath input=Message 
                    | rename XmlEventData.* as * 
                    | search SearchFilter="*(&(samAccountType=805306368)(servicePrincipalName=*)*"

        Анализируя искомую запись, нам нужны будут данные по полям:

            -   host            :   BLUE
            -   ComputerName    :   BLUE.corp.local
            -   EventCode       :   3
            -   PID             :   7136
            -   PName           :   
            -   ProcessID       :   7136
            -   ProcessId       :   7,136
            -   ProcessName     :   N/A
            -   ProviderGuid    :   099614a5-5dd7-4788-8bc9-e29f43db28fc
            -   ProviderName    :   Microsoft-Windows-LDAP-Client
            -   TID             :   3792
            -   ThreadID        :   3792

        Ценность данных полей заключается в том, что их значения могут совпадать/перекликаться с другими источниками (source)
        Ибо в данном источнике у нас нет информации о том, какйо пользователь запустил данный процесс
        Поэтому, нам надо будет просмотреть все остальные источники и ЗА ВСЕ время
    
    2)  Теперь нам надо проанализировать все источники (source) используя найденные значения
        Из найденных в шаге 1 значений, мы можем заметить один момент, который перекликается с заданием 
        Это аббревиатура LDAP
        Поэтому, мы будем использовать ее вместо Microsoft-Windows-LDAP-Client

        Итак, сперва запускаем сканирование по всем источникам (source) и постепенно начинаем добавлять в фильтр наши совпадения
        Так как наименование полей у каждого исчтоника может отличаться, то добавлять мы будем в ручную -   двойным нажатем мышки на понравившееся поле
        Если после добавления возможного поля, наш список доступных полей не удовлетворяет нашим условиям, то мы просто убираем только что добавленное поле из фильтра
        *** Также стоит добавить дополнительные поля, если нужные Вам не представленны в списке
            В нашем примере мы добавили поле "DestinationPortName" так как атака шла на службу LDAP, то нам стоило включить данное поле в списко допустимых полей
        
        Также, если количество отфильтрованных значений существенно снизилось, но не мнещается в всплывающее окно, то можно добавить в фильтр отображение в виде таблицы с интересующими паролями
        А также включить отчистку дубликатов

            index=main DestinationPortName=ldap host=BLUE 
            | dedup process_id
            | table _time, User, process_id
        
        Конечно, можно воспользоваться заготовкой фильтра из примера "Detecting Kerberoasting - TGS Requests"
        Но заготовки заточены под конкретные моменты/условия, а ручной поиск будет больше адаптирован под ваши нужды