`=====================================================================
* Руководство *
***************

Если использовать машину от HTB, то сперва надо запустить данную комнаду, чтобы скачать и распокавать все необходимые pcap файлы

	<usern_name>@<host_name>$ wget -O file.zip 'https://academy.hackthebox.com/storage/resources/pcap_files.zip' && mkdir tempdir && unzip file.zip -d tempdir && mkdir -p pcaps && mv tempdir/Intermediate_Network_Traffic_Analysis/* pcaps/ && rm -r tempdir file.zip

Удобнее всего просматривать PCAP-files используя Wireshark
Однако, в целях практики и выбработки навыков использования CLI-based tools мы будем использовать такие утилиты как tcpdump

=====================================================================
* Легенда *
***********

Хотя HTTP-трафик не зашифрован, иногда мы сталкиваемся с зашифрованным HTTP-трафиком.
В связи с этим, знание индикаторов и признаков вредоносного HTTP-трафика имеет решающее значение для наших усилий по анализу трафика.

В отличие от HTTP, который является протоколом без сохранения состояния, HTTPs включает шифрование для обеспечения безопасности веб-серверов и клиентов.
Он делает это с помощью следующего.

    -   Безопасность транспортного уровня (Transport Layer Security)
    -   Уровень защищенных сокетов (SSL)

В общем, когда клиент устанавливает HTTPS-соединение с сервером, он выполняет следующее.

    1)  Handshake (Рукопожатие):
        Сервер и клиент проходят рукопожатие при установлении HTTPS-соединения.
        Во время этого рукопожатия клиент и сервер договариваются о том, какие алгоритмы шифрования использовать, и обмениваются своими сертификатами.

    2)  Encryption (Шифрование):
        После завершения рукопожатия клиент и сервер используют заранее согласованный алгоритм шифрования для шифрования дальнейших данных, передаваемых между ними.

    3)  Further Data Exchange (Дальнейший обмен данными):
        После установления зашифрованного соединения клиент и сервер продолжат обмениваться данными друг с другом.
        Этими данными могут быть веб-страницы, изображения или другие веб-ресурсы.

    4)  Decryption (Расшифровка):
        Когда клиент передает данные на сервер или сервер передает данные клиенту, они должны расшифровать эти данные с помощью закрытого и открытого ключей.

Таким образом, одной из наиболее распространенных атак на основе HTTP является повторное согласование SSL, при котором злоумышленник согласовывает сеанс с минимально возможным стандартом шифрования.

Для установления зашифрованного соединения клиент и сервер должны пройти процесс рукопожатия. К счастью для нас, рукопожатия TLS и SSL в основном схожи по своим шагам.

    a)  Client Hello
        Первым шагом для клиента является отправка своего приветственного сообщения на сервер.
        Это сообщение содержит информацию, например, какие версии TLS/SSL поддерживаются клиентом, список наборов шифров (также известных как алгоритмы шифрования) и случайные данные (nonces), которые будут использоваться на следующих этапах.

    b)  Server Hello
        В ответ на клиентское приветствие сервер отправит сообщение Server Hello.
        Это сообщение включает выбранную сервером версию TLS/SSL, выбранный набор шифров из вариантов клиента и дополнительный nonce.

    c)  Certificate Exchange
        Затем сервер отправляет свой цифровой сертификат клиенту, подтверждая его личность.
        Этот сертификат включает открытый ключ сервера, который клиент будет использовать для проведения процесса обмена ключами.

    d)  Key Exchange
        Затем клиент генерирует то, что называется premaster secret.
        Затем он шифрует этот секрет с помощью открытого ключа сервера из сертификата и отправляет его на сервер.

    e)  Session Key Derivation
        Затем клиент и сервер используют одноразовые коды, обмененные на первых двух этапах, вместе с секретным ключом premaster для вычисления сеансовых ключей.
        Эти сеансовые ключи используются для симметричного шифрования и расшифровки данных во время безопасного соединения.

    f)  Finished Messages.
        Чтобы убедиться, что рукопожатие завершено и прошло успешно, а также что обе стороны вывели одинаковые сеансовые ключи, клиент и сервер обмениваются готовыми сообщениями.
        Это сообщение содержит хэш всех предыдущих сообщений рукопожатия и шифруется с использованием сеансовых ключей.

    g)  Secure Data Exchange.
        Теперь, когда рукопожатие завершено, клиент и сервер могут обмениваться данными по зашифрованному каналу.

Мы также можем взглянуть на это с общей алгоритмической точки зрения.

    Handshake Step                  Relevant Calculations
    ______________                  _____________________
    
    Client Hello	                ClientHello = { ClientVersion, ClientRandom, Ciphersuites, CompressionMethods }
    
    Server Hello	                ServerHello = { ServerVersion, ServerRandom, Ciphersuite, CompressionMethod }
    
    Certificate Exchange	        ServerCertificate = { ServerPublicCertificate }
    
    Key Exchange                    ClientDHPrivateKey
                                    ClientDHPublicKey = DH_KeyGeneration(ClientDHPrivateKey)
                                    ClientKeyExchange = { ClientDHPublicKey }
                                    ServerDHPrivateKey
                                    ServerDHPublicKey = DH_KeyGeneration(ServerDHPrivateKey)
                                    ServerKeyExchange = { ServerDHPublicKey }
    
    Premaster Secret                PremasterSecret = DH_KeyAgreement(ServerDHPublicKey, ClientDHPrivateKey)
                                    PremasterSecret = DH_KeyAgreement(ClientDHPublicKey, ServerDHPrivateKey)
    
    Session Key Derivation          MasterSecret = PRF(PremasterSecret, "master secret", ClientNonce + ServerNonce)
                                    KeyBlock = PRF(MasterSecret, "key expansion", ServerNonce + ClientNonce)
    
    Extraction of Session Keys      ClientWriteMACKey = First N bytes of KeyBlock
                                    ServerWriteMACKey = Next N bytes of KeyBlock
                                    ClientWriteKey = Next N bytes of KeyBlock
                                    ServerWriteKey = Next N bytes of KeyBlock
                                    ClientWriteIV = Next N bytes of KeyBlock
                                    ServerWriteIV = Next N bytes of KeyBlock

    Finished Messages               FinishedMessage = PRF(MasterSecret, "finished", Hash(ClientHello + ServerHello))

Однако существуют и другие атаки шифрования, о которых нам следует знать, например уязвимость Heartbleed (The Heartbleed Vulnerability CVE-2014-0160 - https://heartbleed.com/)

=====================================================================
* Подготовка *
**************

Как такового, подготовительного этапа, не существует
Для анализа чаще всего используют любой, подходящий пакетный анализатор
В нашем случае это - Wireshark

=====================================================================
* Анализ *
**********

	+++++++++++++++++++++++++++++++++++++++++
	+ Diving into SSL Renegotiation Attacks +
	+++++++++++++++++++++++++++++++++++++++++

    Чтобы найти нарушения в рукопожатиях, мы можем использовать слудеющий фильтр в Wireshark.
    В котором content_type == 22 определяет только сообщения о рукопожатии

        -   ssl.record.content_type == 22
    
    Когда мы ищем атаки повторного согласования SSL, мы можем искать следующее.

        i)      Multiple Client Hellos (Несколько клиентских приветствий)
                Это самый очевидный признак атаки повторного согласования SSL.
                Мы можем заметить несколько клиентских приветствий от одного клиента в течение короткого периода.
                Злоумышленник повторяет это сообщение, чтобы вызвать повторное согласование и, как ожидается, получить более низкий набор шифров.

        ii)     Out of Order Handshake Messages (Сообщения о нарушении порядка установления связи)
                Иногда мы можем наблюдать некоторое нарушенние последовательности трафика из-за потери пакетов и других причин
                Но в случае повторного согласования SSL очевидными признаками будут получение сервером клиентского приветствия после завершения согласования связи.

    Причины, по которым злоумышленник может провести данный тип атаки против нас следующие:

        -   Denial of Service
            Атаки повторного согласования SSL потребляют массу ресурсов на стороне сервера, и, как следствие, это может перегрузить сервер и привести к тому, что он перестанет отвечать.

        -   SSL/TLS Weakness Exploitation
            Злоумышленник может попытаться провести повторное согласование, чтобы потенциально использовать уязвимости с нашей текущей реализацией наборов шифров.

        -   Cryptanalysis (Криптоанализ)
            Злоумышленник может использовать повторное согласование как часть общей стратегии для анализа наших шаблонов SSL/TLS для других систем.

=====================================================================
* Дополнительные Вопросы *
**************************
