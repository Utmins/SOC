Zeek (ранее Bro) — это коммерческий инструмент с открытым исходным кодом для мониторинга сети (анализатор трафика).

Zeek отличается от известных инструментов мониторинга и IDS/IPS тем, что предоставляет широкий спектр подробных журналов, готовых к исследованию как для криминалистики, так и для действий по анализу данных.
В настоящее время Zeek предоставляет более 50 журналов в 7 категориях.

    ++++++++++++++++++++
    + Архитектура Zeek +
    ++++++++++++++++++++

Zeek имеет два основных уровня:

    -   «Event Engine»
        Уровень Event Engine — это то, где обрабатываются пакеты
        Он также называется ядром событий и отвечает за описание события без фокусировки на деталях события.
        Здесь пакеты делятся на части, такие как исходные и конечные адреса, идентификация протокола, анализ сеанса и извлечение файла.

    -   «Policy Script Interpreter». 
        Уровень Policy Script Interpreter — это то, где проводится семантический анализ.
        Он отвечает за описание корреляций событий с помощью сценариев Zeek.

    +++++++++++++++++++
    + Zeek Frameworks +
    +++++++++++++++++++

Zeek имеет несколько фреймворков для предоставления расширенных функций на уровне сценариев.
Эти фреймворки повышают гибкость Zeek и совместимость с другими сетевыми компонентами.
Каждый фреймворк фокусируется на определенном варианте использования и легко запускается с установкой Zeek. 
Наличие ide по функциональности каждого фреймворка может помочь пользователям быстро идентифицировать интересующее событие

Доступные фреймворки:

    -   Logging	Notice
    -   Input
    -   Configuration
    -   Intelligence
    -   Cluster
    -   Broker Communication
    -   Supervisor
    -   GeoLocation
    -   File Analysis
    -   Signature
    -   Summary
    -   NetControl
    -   Packet Analysis
    -   TLS Decryption

Более детально о каждом фреймворке можно прочитать тут  -   https://docs.zeek.org/en/master/frameworks/index.html


    +++++++++++++++
    + Zeek Output +
    +++++++++++++++

Как упоминалось ранее, Zeek предоставляет более 50 файлов журналов в семи различных категориях
Которые полезны в различных областях, таких как мониторинг трафика, обнаружение вторжений, поиск угроз и веб-аналитика.

После запуска Zeek он автоматически начнет исследовать трафик или заданный файл pcap и автоматически сгенерирует журналы.
После обработки pcap с помощью Zeek он создаст журналы в рабочем каталоге.
Если вы запустите Zeek как службу, ваши журналы будут расположены в пути журнала по умолчанию.
Путь журнала по умолчанию   -   /opt/zeek/logs/

    ++++++++++++++++++++++++
    + Начало работы с Zeek +
    ++++++++++++++++++++++++

Существует два варианта работы Zeek:

    1)  Запуск его как службы
    2)  Запуск Zeek с помощью pcap.

1)  Перед началом работы с Zeek рекомендуется проверять версию экземпляра Zeek.
Это как правило делается только когда вы либо впервые запускаете Zeek на своей системе, либо работает на новой или чужой системе
Это помогает понять установлен ли вообще Zeek и какой версии
Для этого используют команду    -   zeek -v

Для запуска Zeek как службы нам нужно использовать модуль «ZeekControl».
Для использования модуля «ZeekControl» требуются права суперпользователя.
Вы можете повысить привилегии сеанса и переключиться на учетную запись суперпользователя, чтобы изучить сгенерированные файлы журнала с помощью следующей команды: sudo su

Здесь мы можем управлять службой Zeek и просматривать ее состояние.
Основное управление службой Zeek осуществляется с помощью трех команд:

    -   status
    -   start
    -   stop

Вы также можете использовать режим "ZeekControl" со следующими командами:

    -   zeekctl status
    -   zeekctl start
    -   zeekctl stop

Использование Zeek как службы   -   единственный способ прослушивать сетевой трафик в реальном времени.

2)  Помимо использования Zeek в качестве инструмента мониторинга сети, мы также можем использовать его в качестве исследователя пакетов.
Для этого нам нужно обработать файлы pcap с помощью Zeek.
После обработки файла pcap Zeek автоматически создает файлы журналов в соответствии с трафиком.

В режиме обработки pcap журналы сохраняются в рабочем каталоге.
Вы можете просмотреть сгенерированные журналы с помощью команды ls -l

Вот некоторые коючи, которые используются в режиме работы с pcap-файлами:

    Parameter	    Description
    
    -r	            Параметр чтения, чтение/обработка файла pcap.
    -C              Игнорирование ошибок контрольной суммы.
    -v              Информация о версии.
    -S              Использовать файл подписи
    zeekctl         ZeekControl модуль.

Для исследования сгенерированных журналов потребуются инструменты командной строки (cat, cut, grep sort и uniq) и дополнительные инструменты (zeek-cut). 

*************
* ZEEK Logs *
*************

Zeek генерирует файлы журналов в соответствии с данными трафика.
У вас будут журналы для каждого соединения в сети, включая протоколы и поля уровня приложения.
Zeek способен идентифицировать более 50 журналов и классифицировать их по семи категориям.
Журналы Zeek — это хорошо структурированные и разделенные табуляцией файлы ASCII, поэтому их чтение и обработка просты, но требуют усилий.
Вы должны быть знакомы с сетями и протоколами, чтобы сопоставлять журналы в расследовании, знать, на чем сосредоточиться, и находить конкретные доказательства.

Каждый вывод журнала состоит из нескольких полей, и каждое поле содержит другую часть данных трафика.
Корреляция выполняется с помощью уникального значения, называемого «UID».
«UID» представляет собой уникальный идентификатор, назначенный каждому сеансу.

Zeek logs in a nutshell:

        Category                    Description                                                                     Log Files

        Network                     Network protocol logs                                                           conn.log, dce_rpc.log, dhcp.log, dnp3.log, dns.log, ftp.log, http.log, irc.log,
                                                                                                                    kerberos.log, modbus.log, modbus_register_change.log, mysql.log, ntlm.log, ntp.log,
                                                                                                                    radius.log, rdp.log, rfb.log, sip.log, smb_cmd.log, smb_files.log, smb_mapping.log,
                                                                                                                    smtp.log, snmp.log, socks.log, ssh.log, ssl.log, syslog.log, tunnel.log.

        Files                       File analysis result logs                                                       files.log, ocsp.log, pe.log, x509.log.

        NetControl                  Network control and flow logs                                                   netcontrol.log, netcontrol_drop.log, netcontrol_shunt.log, netcontrol_catch_release.log, openflow.log.

        Detection                   Detection and possible indicator logs                                           intel.log, notice.log, notice_alarm.log, signatures.log, traceroute.log.

        Network Observations        Network flow logs.                                                              known_certs.log, known_hosts.log, known_modbus.log, known_services.log, software.log.

        Miscellaneous               Additional logs cover external alerts, inputs and failures          b           arnyard2.log, dpd.log, unified2.log, unknown_protocols.log, weird.log, weird_stats.log.

        Zeek Diagnostic             Zeek diagnostic logs cover system messages, actions and some statistics.        broker.log, capture_loss.log, cluster.log, config.log, loaded_scripts.log, packet_filter.log, print.log, prof.log, reporter.log, stats.log, stderr.log, stdout.log.


За более детальной информацией следует обратиться к
    -   официальной документации Zeek (https://docs.zeek.org/en/current/script-reference/log-files.html)
    -   шпаргалке по журналам Corelight (https://corelight.com/about-zeek/zeek-data).

Некоторые файлы журналов обновляются ежедневно, а некоторые — в каждом сеансе.

Вы можете классифицировать журналы перед началом расследования.
Таким образом, будет проще найти искомые вами доказательства/аномалии.

Приведенная таблица является кратким примером использования нескольких файлов журналов.
*** Вы можете создать свою рабочую модель или настроить заданную.

        Overall Info            Protocol Based      Detection           Observation
        
        conn.log                http.log            notice.log          known_host.log
        files.log               dns.log             signatures.log      known_services.log
        intel.log               ftp.log             pe.log              software.log
        loaded_scripts.log      ssh.log             traceroute.log      weird.log

    Overall Info:       Цель состоит в том, чтобы просмотреть все соединения, общие файлы, загруженные скрипты и индикаторы одновременно.
                        Это первый шаг расследования.

    Protocol Based:     После того, как вы просмотрите весь трафик и обнаружите подозрительные индикаторы или захотите провести более глубокое расследование, вы сосредоточитесь на определенном протоколе.
    
    Detection:          Используйте готовые или пользовательские скрипты и результаты сигнатур для подтверждения своих выводов с помощью дополнительных индикаторов или связанных действий.
    
    Observation:        Сводка по хостам, службам, программному обеспечению и статистике неожиданной активности поможет вам обнаружить возможные недостающие точки и завершить расследование.

И хотя журналы ZEEK хорошо структурированы, каждый их них содержит огромный объем информации, который очень тяжело распределить используя обычные утилиты команднеой строки Линукс (cat, cut, grep sort, and uniq)
Поэтому утилиты Линукс чаще всего используют с утилитой Zeek, которая призвана сократить усилия по извлечению определенных столбцов из файлов журнала
Данная утилита  -   zeek cut

Каждый файл журнала предоставляет "имена полей" в начале.
Эта информация поможет вам при использовании zeek-cut.
*** Убедитесь, что вы используете "поля", а не "типы".
Вот пример совместного использования Линукс утилит с утилитой zeek cut

    ~:$ cat <log.filename> | zeek-cut uid proto id.orig_h id.orig_p id.resp_h id.resp_p | sort -u | wc -lack

*******************
* ZEEK Signatures *
*******************

Zeek поддерживает сигнатуры для правил и корреляций событий, чтобы находить заслуживающие внимания действия в сети.
Сигнатуры Zeek используют низкоуровневое сопоставление шаблонов и охватывают условия, аналогичные правилам Snort.
В отличие от правил Snort, правила Zeek не являются основной точкой обнаружения событий.
Zeek имеет язык сценариев и может объединять несколько событий, чтобы найти событие, представляющее интерес.

Подписи Zeek состоят из трех логических путей:

    1)   Signature id
        Уникальное имя подписи.
    
    2)   Conditions	
            -   Header
                Фильтрация заголовков пакетов по определенным адресам источника и назначения, протоколам и номерам портов.
            -   Content
                Фильтрация полезной нагрузки пакета по определенному значению/шаблону.

    3)   Action	
            -   Default action
                Создать файл «signatures.log» в случае совпадения подписи.
            -   Additional action
                Запустить скрипт Zeek.

В таблице ниже приведены наиболее распространенные условия и фильтры для подписей Zeek.

    Condition Field	                            Available Filters
    
    Header                                      src-ip      (Source IP)
                                                dst-ip      (Destination IP)
                                                src-port    (Source port)
                                                dst-port    (Destination port)
                                                ip-proto    (Target protocol. Supported protocols; TCP, UDP, ICMP, ICMP6, IP, IP6)
    
    Content                                     payload                 (Packet payload)
                                                http-request            (Decoded HTTP requests)
                                                http-request-header     (Client-side HTTP headers)
                                                http-request-body       (Client-side HTTP request bodys)
                                                http-reply-header       (Server-side HTTP headers)
                                                http-reply-body         (Server-side HTTP request bodys)
                                                ftp                     (Command line input of FTP sessions)

    Context                                     same-ip     (Filtering the source and destination addresses for duplication.)
    
    Action                                      event       (Signature match message)
    
    Comparison Operators                        ==, !=, <, <=, >, >=
    
    NOTE!                                       Filters accept string, numeric and regex values

*** Подписи Zeek используют расширение «.sig».

    ++++++++++++++++++++++
    + SIGNATURE Examples +
    ++++++++++++++++++++++

Не забываем, что "подписи" Zeek поддерживают регулярные выражения (RegEx).
Регулярное выражение ".*" соответствует любому символу ноль или более раз.
Правило сработает, если в полезной нагрузке пакета будет обнаружена искомая фраза
Как только совпадение произойдет, Zeek сгенерирует оповещение и создаст дополнительные файлы журнала (signatures.log и notification.log).

Для использования "подписи", ее сперва необходимо создать

    //////////////////////////////////////////////////
    /// Example | Cleartext Submission of Password ///
    //////////////////////////////////////////////////

Вот примерный образец "подписи", который мы можем использовать для поиска пароля в файле журнала, который (пароль) не был зашифрован, т.е. был в формате cleartext

    signature http-password {
        ip-proto == tcp
        dst-port == 80
        payload /.*password.*/
        event "Cleartext Password Found!"
    }

    # signature: Signature name.
    # ip-proto: Filtering TCP connection.
    # dst-port: Filtering destination port 80.
    # payload: Filtering the "password" phrase.
    # event: Signature match message.

Теперь надо запустить Zeek с использование определенных ключей, а также указанием имени pcap-файла и sig-файла

    ~:$ zeek -C -r http.pcap -s http-password.sig

После использования данной команды будут сгенерированы несколько лог-файло, согласно имеющейяся в pcap-файле информации и соответсвующим категортям

    ~:$ ls
    clear-logs.sh  conn.log  files.log  http-password.sig  http.log  http.pcap  notice.log  packet_filter.log  signatures.log

Далее мы можем просмотреть, интересующие нас, лог-файлы с использованием Линус и Zeek утилит

    ~:$ cat notice.log  | zeek-cut id.orig_h id.resp_h msg

            10.10.57.178	44.228.249.3	10.10.57.178: Cleartext Password Found!
            10.10.57.178	44.228.249.3	10.10.57.178: Cleartext Password Found!
    
    ~:$ cat signatures.log | zeek-cut src_addr dest_addr sig_id event_msg 

            10.10.57.178		http-password	10.10.57.178: Cleartext Password Found!
            10.10.57.178		http-password	10.10.57.178: Cleartext Password Found!

Как показано в выходных данных терминала выше, signatures.log и notification.log предоставляют основные сведения и сообщение подписи.
Оба журнала также имеют поле баннера приложения.
Таким образом, можно узнать, где происходит совпадение подписи. Давайте посмотрим на баннер приложения!

    /////////////////////////////////
    /// Example | FTP Brute-force ///
    /////////////////////////////////

Давайте создадим еще одно правило для фильтрации FTP-трафика.
На этот раз мы будем использовать фильтр содержимого FTP для исследования командных строк FTP-трафика.
Цель состоит в том, чтобы обнаружить попытки входа "admin" на FTP.
Эта базовая сигнатура поможет нам идентифицировать попытки входа администратора и получить представление о возможных злоупотреблениях учетной записью администратора или событиях компрометации.

    signature ftp-admin {
        ip-proto == tcp
        ftp /.*USER.*dmin.*/
        event "FTP Admin Login Attempt!"
    }

После создания "полписи" мы можем запустить Zeek с подписью и исследуем signatures.log и notification.log

    ~:$ zeek -C -r ftp.pcap -s ftp-admin.sig
    ~:$ cat signatures.log | zeek-cut src_addr dst_addr event_msg sub_msg | sort -r| uniq

        10.234.125.254	10.121.70.151	10.234.125.254: FTP Admin Login Attempt!	USER administrator
        10.234.125.254	10.121.70.151	10.234.125.254: FTP Admin Login Attempt!	USER admin

Наше правило показывает нам, что есть несколько попыток регистрации с именами учетных записей, содержащими фразу «admin».
Вывод дает нам отличную информацию, что были осуществленны попытки брутфорсинга учетной записи администратора.


Сигнатуру, указанную выше можно считать сигнатурой случая.
Хотя она точна и отлично работает, в реальной жизни нам придется использовать более глобальные сигнатуры для обнаружения «известных угроз/аномалий», таких как атаки нулевого дня и инсайдерские атаки в реальной среде.

Главное помнить, что нелогично созданные правила/сигнатуры могут приветси к пропуску реальной аномалии.
Поэтому при создании сигнатур надо руководствоватсья простым правилос — логическая регистрация, а не регистрация всего.

К примеру   -   мы можем улучшить нашу подпись, не ограничивая фокус только на учетной записи администратора.
В этом случае нам нужно знать, как работает протокол FTP и коды ответов по умолчанию.
Если вы не знаете этих подробностей, обратитесь к документации RFC.

    Улучшенный вариант №1   -   создаст журналы для каждого события, содержащего «ответ FTP 530», что позволит нам отслеживать события сбоев входа независимо от имени пользователя.

        signature ftp-brute {
            ip-proto == tcp
            payload /.*530.*Login.*incorrect.*/
            event "FTP Brute-force Attempt"
        }
    
Файлы подписей Zeek могут состоять из нескольких подписей.
Поэтому у нас может быть один файл для каждого протокола/ситуации/типа угрозы.

    Улучшенный вариант №2

        signature ftp-username {
            ip-proto == tcp
            ftp /.*USER.*/
            event "FTP Username Input Found!"
        }

        signature ftp-brute {
            ip-proto == tcp
            payload /.*530.*Login.*incorrect.*/
            event "FTP Brute-force Attempt!"
        }

В результате использования "Улучшенного варианта №2" мы получили Следующее

    ~:$ zeek -C -r ftp.pcap -s ftp-admin.sig
    ~:$ cat notice.log | zeek-cut uid id.orig_h id.resp_h msg sub | sort -r| nl | uniq | sed -n '1001,1004p'

        1001	CeMYiaHA6AkfhSnd	10.234.125.254	10.121.70.151	10.234.125.254: FTP Username Input Found!	USER admin
        1002	CeMYiaHA6AkfhSnd	10.234.125.254	10.121.70.151	10.121.70.151: FTP Brute-force Attempt!	530 Login incorrect.
        1003	CeDTDZ2erDNF5w7dyf	10.234.125.254	10.121.70.151	10.234.125.254: FTP Username Input Found!	USER administrator
        1004	CeDTDZ2erDNF5w7dyf	10.234.125.254	10.121.70.151	10.121.70.151: FTP Brute-force Attempt!	530 Login incorrect.

****************
* ZEEK SCRIPTS *
****************

Zeek имеет свой собственный язык сценариев, управляемый событиями, который так же мощен, как языки высокого уровня, и позволяет нам исследовать и сопоставлять обнаруженные события.
Поскольку он так же мощен, как языки программирования высокого уровня, вам нужно будет потратить время на язык сценариев Zeek, чтобы стать профессионалом.
Ниже будут представленны только основы сценариев Zeek, чтобы помочь понять, изменить и создать базовые сценарии.
*** Обратите внимание, что сценарии можно использовать для применения политики, и в этом случае они называются сценариями политики.

Существуют 3 категории скриптов ZEEK:

    -   BASE Scripts
        В Zeek по умолчанию установлены базовые скрипты, и они не предназначены для изменения.
        Расположены     -   /opt/zeek/share/zeek/base
    
    -   USER Generated/Modified Scripts
        Должны быть расположены     -   /opt/zeek/share/zeek/site

    -   POLICY Scripts
        Расположены     -   /opt/zeek/share/zeek/policy

Как и в случае со Snort, для автоматической загрузки/использования скрипта в режиме живого сниффинга необходимо идентифицировать скрипт в файле конфигурации Zeek.
Вы также можете использовать скрипт для одного запуска, как и сигнатуры.
Файл конфигурации расположена   -   /opt/zeek/share/zeek/site/local.zeek

Вот несколько ВАЖНЫХ моментов при работе с ZEEK:

    -   Скрипты Zeek используют расширение ".zeek".
    -   Не изменяйте ничего в каталоге "zeek/base".
    -   Скрипты, созданные и измененные пользователем, должны находиться в каталоге "zeek/site".
    -   Вы можете вызывать скрипты в режиме мониторинга в реальном времени, загрузив их с помощью команды load @/script/path или load @script-name в файле local.zeek.
    -   Zeek ориентирован на события, а не на пакеты!
        Нам нужно использовать/писать скрипты для обработки интересующего события.

Пример ZEEK Script

    event dhcp_message (c: connection, is_orig: bool, msg: DHCP::Msg, options: DHCP::Options)
    {
    print options$host_name;
    }

Пройдемся более детально по организации скриптов в Zeek

    /////////////////////////////////////////
    /// Scripts 101 | Write Basic Scripts ///
    /////////////////////////////////////////

Скрипты содержат:
    
    -   операторы
    -   типы
    -   атрибуты
    -   объявления и операторы
    -   директивы.

101)    Давайте рассмотрим простой пример события под названием "zeek_init" и "zeek_done".
        Эти события срабатывают после запуска и остановки процесса Zeek.
        Обратите внимание, что эти события не имеют параметров, а некоторые события потребуют параметров.

            event zeek_init()
                {
                print ("Started Zeek!");
                }
            event zeek_done()
                {
                print ("Stopped Zeek!");
                }

            # zeek_init: Do actions once Zeek starts its process.
            # zeek_done: Do activities once Zeek finishes its process.
            # print: Prompt a message on the terminal.

        Вышеприведенный вывод показывает, как работает скрипт и предоставляет сообщения на терминале.
        Zeek будет создавать журналы в рабочем каталоге отдельно от задач скриптов.

102)    Давайте выведем данные пакета на терминал и посмотрим необработанные данные.
        В этом скрипте мы запрашиваем сведения о соединении и извлекаем их без какой-либо фильтрации или сортировки данных.
        Для этого мы используем событие "new_connection".
        Это событие автоматически генерируется для каждого нового соединения.
        
        Этот скрипт предоставляет объемную информацию на терминале.
        Нам нужно ознакомиться со структурой данных Zeek, чтобы уменьшить объем информации и сосредоточиться на интересующем нас событии.
        Для этого нам нужно исследовать объемные данные.

            event new_connection(c: connection)
            {
                print c;
            }
        
        Скрипт #102 предоставляет объемные данные для каждого соединения.
        Этот стиль не является лучшим использованием, и в реальной жизни нам нужно будет фильтровать информацию для определенных целей.
        Если вы внимательно посмотрите на вывод, вы увидите идентификатор и значение поля для каждой части.
        Поэтому мы немного доработаем данный скрипт

103)    Чтобы отфильтровать интересующее событие, мы будем использовать первичный тег (в данном случае это c --происходит от "c: connection"--), значение идентификатора (id=) и имя поля.
        Вы должны заметить, что поля такие же, как и поля в файлах журнала.

            event new_connection(c: connection)
            {
                print ("###########################################################");
                print ("");
                print ("New Connection Found!");
                print ("");
                print fmt ("Source Host: %s # %s --->", c$id$orig_h, c$id$orig_p);
                print fmt ("Destination Host: resp: %s # %s <---", c$id$resp_h, c$id$resp_p);
                print ("");
            }

            # %s: Identifies string output for the source.
            # c$id: Source reference field for the identifier.
        
        Вышеприведенный вывод показывает, что мы успешно извлекаем определенную информацию из событий.
        Помните, что этот скрипт извлекает интересующее нас событие (в этом примере — новое соединение), и у нас все еще есть журналы в рабочем каталоге.
        Мы всегда можем изменить и оптимизировать скрипты в любое время.
        
        Результат использования данного скрипта будет выглядеть примерно так:

            ~:$ zeek -C -r sample.pcap 103.zeek

                ###########################################################
                New Connection Found! Source Host: 192.168.121.2 # 58304/udp ---> 
                Destination Host: resp: 192.168.120.22 # 53/udp <--- 
                ###########################################################

    /////////////////////////////////////////////////////////
    /// Scripts 201 | Use Scripts and Signatures Together ///
    /////////////////////////////////////////////////////////

До сих пор мы рассматривали основы скриптов Zeek.
Теперь пришло время использовать скрипты совместно с другими скриптами и сигнатурами, чтобы приблизиться на один шаг к корреляции событий. Скрипты Zeek могут ссылаться на сигнатуры и другие скрипты Zeek. Эта гибкость обеспечивает огромное преимущество в корреляции событий.

Давайте продемонстрируем эту концепцию на примере.
Мы создадим скрипт, который определяет, есть ли у нашего ранее созданного правила "ftp-admin" попадание

    event signature_match (state: signature_state, msg: string, data: string)
    {
    if (state$sig_id == "ftp-admin")
        {
        print ("Signature hit! --> #FTP-Admin ");
        }
    }

Этот базовый скрипт быстро проверяет, есть ли совпадение подписи, и предоставляет вывод терминала для уведомления нас.
Для этого мы используем событие "signature_match". 
*** Подробнее о событиях можно прочитать здесь  -   https://docs.zeek.org/en/master/scripts/base/bif/event.bif.zeek.html

Обратите внимание, что мы ищем только совпадения подписи "ftp-admin". 
Поэтому, нам также необходимо создать файл-подпись
Подпись показана ниже.

    signature ftp-admin {
        ip-proto == tcp
        ftp /.*USER.*admin.*/
        event "FTP Username Input Found!"
    }

Теперь, когда у нас есть файл-скрипт и файл-подпись, мы можем использовать их вместе при анализе pcap-файла

    ~:$ zeek -C -r ftp.pcap -s ftp-admin.sig 201.zeek 

        Signature hit! --> #FTP-Admin Signature hit! --> #FTP-Admin
        Signature hit! --> #FTP-Admin Signature hit! --> #FTP-Admin

Вышеприведенный вывод показывает, что мы успешно объединили подпись и скрипт.
Zeek обработал подпись и журналы, затем скрипт контролировал выходные данные и предоставлял терминальный вывод для каждого попадания в правило.

    ////////////////////////////////////////
    /// Scripts 202 | Load Local Scripts ///
    ////////////////////////////////////////

Выше было сказано, что Zeek имеет базовые скрипты, расположенные в "/opt/zeek/share/zeek/base".
Вы можете загрузить все локальные скрипты, указанные в вашем файле "local.zeek".
*** Обратите внимание, что базовые скрипты охватывают множество функций фреймворка.
Вы можете загрузить все базовые скрипты, легко выполнив команду     -   local

    ~:$ zeek -C -r ftp.pcap local
    ~:$ ls
        101.zeek  103.zeek          clear-logs.sh  ftp.pcap            packet_filter.log  stats.log
        102.zeek  capture_loss.log  conn.log       loaded_scripts.log  sample.pcap        weird.log

Вышеприведенный вывод демонстрирует, как запустить все базовые скрипты с помощью команды "local".
Посмотрите на вышеприведенный вывод терминала   -   на этот раз Zeek предоставил дополнительные файлы журнала.
Загруженные скрипты сгенерировали файлы load_scripts.log, capture_loss.log, notification.log, stats.log.
Обратите внимание, что в нашем случае было загружено и использовано 465 скриптов с помощью команды "local".
Однако Zeek не предоставляет файлы журнала для скриптов, у которых нет попаданий или результатов.

Другой способ загрузки скриптов — указание пути к интересующему нас скрипту.
В этом случае у вас есть возможность загрузить определенный скрипт или фреймворк.

Давайте вернемся к случаю перебора паролей FTP.
На предыдущих этапах мы создали скрипт, который обнаруживает множественные неудачные попытки входа администратора.
У Zeek также есть скрипт обнаружения перебора паролей FTP.
Теперь давайте воспользуемся скриптом по умолчанию и выявим различия.

    ~:$ zeek -C -r ftp.pcap /opt/zeek/share/zeek/policy/protocols/ftp/detect-bruteforcing.zeek 
    ~:$ cat notice.log | zeek-cut ts note msg 

        1024380732.223481	FTP::Bruteforcing	10.234.125.254 had 20 failed logins on 1 FTP server in 0m1s

Этот скрипт предоставляет гораздо больше информации, чем тот, который мы создали.
Он предоставляет один однострочный вывод и сводку соединения для подозрительного инцидента.

*** Вы можете найти и прочитать больше о готовых скриптах и ​​фреймворках, посетив онлайн-книгу -   https://docs.zeek.org/en/master/frameworks/index.html

    /////////////////////////////////////
    /// Scripts 203 | Load Frameworks ///
    /////////////////////////////////////

Zeek имеет более 15 фреймворков, которые помогают аналитикам обнаруживать различные интересующие события.
Ббольше информации о готовых скриптах и ​​фреймворках можно найти тут   -   https://docs.zeek.org/en/master/frameworks/index.html

Ниже будут рассмотренны только несколько из них:

    *)   File Framework | Hashes

        Не все функции фреймворка предназначены для использования в режиме CLI.
        Большинство из них используются в скриптах.
        Вы можете легко увидеть использование фреймворков в скриптах, вызвав определенный фреймворк как -   load @ $PATH/base/frameworks/framework-name.
        
        Теперь давайте используем готовую функцию файлового фреймворка и получим хэши MD5, SHA1 и SHA256 обнаруженных файлов.
        Но сперва посмотрим, как устроен скрипт, призванный запускать, указанный в нем, фреймворк 
        
            ~:$ cat hash-demo.zeek 

                # Enable MD5, SHA1 and SHA256 hashing for all files.
                @load /opt/zeek/share/zeek/policy/frameworks/files/hash-all-files.zeek
        
        В предыдущих задачах мы упоминали, что Zeek в значительной степени полагается на скрипты, а фреймворки зависят от скриптов.
        Давайте подробнее рассмотрим фреймворк хэша файла и увидим стоящий за ним скрипт.
        
            ~:$ cat /opt/zeek/share/zeek/policy/frameworks/files/hash-all-files.zeek 
                
                # Enable MD5, SHA1 and SHA256 hashing for all files.

                @load base/files/hash
                event file_new(f: fa_file)
                    {
                    Files::add_analyzer(f, Files::ANALYZER_MD5);
                    Files::add_analyzer(f, Files::ANALYZER_SHA1);
                    Files::add_analyzer(f, Files::ANALYZER_SHA256);
                    }
        
        А теперь выполним скрипт и исследуем файл журнала.
        Для этого мы вызовем скрипт фреймворка "File Analysis"  -   «hash-all-files».

            ~:$ zeek -C -r case1.pcap hash-demo.zeek
            ~:$ cat files.log | zeek-cut md5 sha1 sha256

                cd5a4d3fdd5bffc16bf959ef75cf37bc	33bf88d5b82df3723d5863c7d23445e345828904	6137f8db2192e638e13610f75e73b9247c05f4706f0afd1fdb132d86de6b4012
            
            либо

            ~:$ zeek -C -r case1.pcap /opt/zeek/share/zeek/policy/frameworks/files/hash-all-files.zeek
            ~:$ cat files.log | zeek-cut md5 sha1 sha256

                cd5a4d3fdd5bffc16bf959ef75cf37bc	33bf88d5b82df3723d5863c7d23445e345828904	6137f8db2192e638e13610f75e73b9247c05f4706f0afd1fdb132d86de6b4012
        
        Посмотрите на приведенные выше выходные данные терминала.
        Оба скрипта дали одинаковый результат.
        Здесь предпочтение остается за пользователем.
        
        Готовые фреймворки обычно используются в скриптах с методом "@load".
        Конкретные скрипты используются как практические скрипты для конкретных случаев использования.

    *)   File Framework | Extract Files

        Файловый фреймворк может извлекать не только логи из pcap-файла, но и различные файлы, которые передавались в исследуемом (захваченном) pcap-файле.
        Давайте посмотрим на эту функцию в действии!
        *** Мы также можем обратиться к фреймворку либо через наш собственный скрипт, либо напрямую
            В данном пример обратимся напрямую
        
            ~:$ zeek -C -r case1.pcap /opt/zeek/share/zeek/policy/frameworks/files/extract-all-files.zeek
            ~:$ ls -l

                -rw-r--r-- 1 ubuntu ubuntu 1344660 Jun 27  2019 case1.pcap
                drwxr-xr-x 2 ubuntu ubuntu    4096 Oct 12 18:19 extract_files
                -rw-r--r-- 1 ubuntu ubuntu    1179 Oct 12 18:19 files.log
                -rw-r--r-- 1 ubuntu ubuntu    1551 Oct 12 18:19 http.log
                -rw-r--r-- 1 ubuntu ubuntu     254 Oct 12 18:19 packet_filter.log
                -rw-r--r-- 1 ubuntu ubuntu     564 Oct 12 18:19 pe.log
                -rw-r--r-- 1 ubuntu ubuntu    6237 Oct 12 18:19 conn.log
                -rw-r--r-- 1 ubuntu ubuntu     850 Oct 12 18:19 dhcp.log
                -rw-r--r-- 1 ubuntu ubuntu   12466 Oct 12 18:19 dns.log

        После извлечения автоматически создается новая папка с именем "extract_files", в которой находятся все обнаруженные файлы.
        При делании мы можем определить тип извлеченных файлова с помощью команды file

            ~:$ file * | nl
                1	extract-1561667874.743959-HTTP-Fpgan59p6uvNzLFja:  ASCII text, with no line terminators
                2	extract-1561667889.703239-HTTP-FB5o2Hcauv7vpQ8y3:  Composite Document File V2 Document, Little Endian, Os: Windows, Version 6.3, Code page: 1252, Template: Normal.dotm, Last Saved By: Administrator, Revision Number: 2, Name of Creating Application: Microsoft Office Word, Create Time/Date: Thu Jun 27 18:24:00 2019, Last Saved Time/Date: Thu Jun 27 18:24:00 2019, Number of Pages: 1, Number of Words: 0, Number of Characters: 1, Security: 0
                3	extract-1561667899.060086-HTTP-FOghls3WpIjKpvXaEl: PE32 executable (GUI) Intel 80386, for MS Windows

        Zeek извлек три файла. Команда "file" показывает нам один файл .txt, один файл .doc/.docx и один файл .exe.
        Zeek переименовывает извлеченные файлы.
        Формат имени состоит из четырех значений, которые берутся из файлов conn.log и files.log
        Ключевое слово "extract" по умолчанию, значение временной метки (ts), протокол (source) и идентификатор соединения (conn_uids).

    *)   Notice Framework | Intelligence

        Интеллектуальная структура может работать с потоками данных для обработки и корреляции событий и выявления аномалий.
        Интеллектуальной структуре требуется поток для сопоставления и создания оповещений из сетевого трафика.
        Давайте продемонстрируем один файл разведданных об угрозах, созданный пользователем, и позволим Zeek использовать его в качестве основного источника разведданных.
        Расположение источника разведданных: /opt/zeek/intel/zeek_intel.txt

        *** Есть два критических момента, о которых вы никогда не должны забывать.
            1)  Во-первых, исходный файл должен быть разделен табуляцией.
            2)  Во-вторых, вы можете вручную обновить источник, и добавление дополнительных строк не требует повторного развертывания.
                Однако, если вы удалите строку из файла, вам нужно будет повторно развернуть экземпляр Zeek.

        Давайте добавим подозрительный URL-адрес, собранный из файла case1.pcap, в качестве исходной разведывательной информации и посмотрим на эту функцию в действии!
        Перед выполнением скрипта давайте рассмотрим файл разведданных и содержимое скрипта.

            ~:$ cat /opt/zeek/intel/zeek_intel.txt 
                #fields	indicator	indicator_type	meta.source	meta.desc
                smart-fax.com	Intel::DOMAIN	zeek-intel-test	Zeek-Intelligence-Framework-Test

            ~:$ cat intelligence-demo.zeek 
                # Load intelligence framework!
                @load policy/frameworks/intel/seen
                @load policy/frameworks/intel/do_notice
                redef Intel::read_files += { "/opt/zeek/intel/zeek_intel.txt" };
        
        Вышеприведенный вывод показывает содержимое файла intel и содержимое скрипта.
        Есть один вход разведки, и он сосредоточен на доменном имени, поэтому, когда это доменное имя появляется в сетевом трафике, Zeek создаст файл "intel.log" и предоставит доступные подробности.
        Проще говоря, файл-источник разведданных содержит критерии, по которым будет формироваться лог-файл после обработки файла-захвата
        А скрипт говорит о том, какие фреймворки должны быть использованы, при анализе файла-захвата с учетом критериев, указанных в файле-источнике разведданных

        Чтож, давайте проанализируем наш файл-захвата с использованием скрипта разведки, а затем просмотри содержимое соответсвующего лог-файла

            ~:$ zeek -C -r case1.pcap intelligence-demo.zeek 
            ~:$ cat intel.log | zeek-cut uid id.orig_h id.resp_h seen.indicator matched

                CZ1jLe2nHENdGQX377	10.6.27.102	10.6.27.1	smart-fax.com	Intel::DOMAIN	
                C044Ot1OxBt8qCk7f2	10.6.27.102	107.180.50.162	smart-fax.com	Intel::DOMAIN 

        Вышеприведенный вывод показывает, что Zeek обнаружил указанный домен и создал файл intel.log.
        Это один из самых простых способов использования фреймворка разведки.
        Подробнее о фреймворке разведки можно прочитать:

            https://docs.zeek.org/en/master/frameworks/intel.html
            https://docs.zeek.org/en/current/scripts/base/frameworks/intel/main.zeek.html#type-Intel::Type

    /////////////////////////////////////
    /// Scripts 204 | Package Manager ///
    /////////////////////////////////////

Менеджер пакетов Zeek помогает пользователям устанавливать сторонние скрипты и плагины для легкого расширения функциональности Zeek.
Менеджер пакетов устанавливается вместе с Zeek и доступен с помощью команды zkg.
Пользователи могут устанавливать, загружать, удалять, обновлять и создавать пакеты с помощью инструмента "zkg". \
Вы можете прочитать больше и просмотреть доступные пакеты здесь и здесь.
*** Обратите внимание, что для использования инструмента "zkg" вам потребуются права root.

Основные команды при работе с пакетами:

    Command                         Description

    zkg install package_path        Install a package. Example (zkg install zeek/j-gras/zeek-af_packet-plugin).
    zkg install git_url             Install package from GIT. Example (zkg install https://github.com/corelight/ztest).
    zkg list                        List installed package.
    zkg remove                      Remove installed package.
    zkg refresh                     Check version updates for installed packages.
    zkg upgrade                     Update installed packages.

Существует несколько способов использования пакетов

    1)  Первый подход заключается в использовании их в качестве фреймворков и вызове определенного пути/каталога пакета для каждого использования.
    2)  Второй и наиболее распространенный подход заключается в вызове пакетов из скрипта с помощью метода "@load".
    3)  Третий и последний подход к использованию пакетов заключается в вызове их имен пакетов
        *** Обратите внимание, что этот метод работает только для пакетов, установленных с помощью метода установки "zkg".

Давайте установим пакет, проверим установился он (отображается ли в списке установленных пакетов), а затем продемонстрируем его использование в различных подходах.

    ~:$ zkg install zeek/cybera/zeek-sniffpass
        The following packages will be INSTALLED:
        zeek/cybera/zeek-sniffpass (master)
        Proceed? [Y/n] Y
        Installing "zeek/cybera/zeek-sniffpass"
        Installed "zeek/cybera/zeek-sniffpass" (master)
        Loaded "zeek/cybera/zeek-sniffpass"

    ~:$ zkg list
        zeek/cybera/zeek-sniffpass (installed: master) - Sniffpass will alert on cleartext passwords discovered in HTTP POST requests

Как указано в описании на терминале выше, этот пакет создает оповещения для открытых текстовых паролей, найденных в HTTP-трафике.
Давайте используем этот пакет тремя разными способами!

    ### Calling with script
        ~:$ zeek -Cr http.pcap sniff-demo.zeek 

    ### Calling from path
        ~:$ zeek -Cr http.pcap /opt/zeek/share/zeek/site/zeek-sniffpass

    ### Calling with package name
        ~:$ zeek -Cr http.pcap zeek-sniffpass

Вышеприведенный вывод демонстрирует, как выполнить/загрузить пакеты с помощью pcap.
Вы можете использовать лучший для вашего случая.
Пакет "zeek-sniffpass" предоставляет дополнительную информацию в файле notification.log.

    ~:$ cat notice.log | zeek-cut id.orig_h id.resp_h proto note msg
            10.10.57.178	44.228.249.3	tcp	SNIFFPASS::HTTP_POST_Password_Seen	Password found for user BroZeek
            10.10.57.178	44.228.249.3	tcp	SNIFFPASS::HTTP_POST_Password_Seen	Password found for user ZeekBro

Вышеприведенный вывод показывает, что пакет нашел отправку паролей в открытом виде, предоставил уведомление и захватил имена пользователей.
Помните, использовали SIGNATURE для выполнения того же действия.
Теперь мы можем выполнить то же действие без использования файла подписи.
Это простая демонстрация преимуществ и гибкости скриптов Zeek.