=====================================================================
* TCPdump *
***********

+++++++++++++++++++
+ General Command +
+++++++++++++++++++
	
    tcpdump --version   -   Отображает строки версий tcpdump и libpcap, а затем завершает работу.	
	tcpdump -h          -   Отображает справку и информацию об использовании.	
	tcpdump -D          -   Отображает список доступных сетевых интерфейсов, с которых может захватывать данные tcpdump.	
	tcpdump -i (interface name or #)    -   Выполняет tcpdump и использует интерфейс, указанный для захвата.	
	tcpdump -i (int) -w file.pcap       -   Запускает захват указанного интерфейса и записывает выходные данные в файл.	
	tcpdump -r file.pcap                -   TCPDump прочитает выходные данные из указанного файла.	
	tcpdump -r/-w file.pcap -l \| grep 'string'     -   TCPDump будет использовать трафик захвата из живого захвата или файла и устанавливать стандартный вывод как строковый буфер. 	
		                                                Затем мы можем использовать канал (|) для отправки этих результатов другим инструментам, таким как grep, для поиска строк или определенных шаблонов.	
	tcpdump -i (int) host (ip)      -   TCPDump начнет захват интерфейса, указанного в (int), и будет захватывать только трафик, исходящий или предназначенный для IP-адреса или имени хоста, указанного после host.	
	tcpdump -i (int) port (#)       -   Будет фильтровать захват для всего, что поступает из порта или предназначено для него (#), и отбрасывает все остальное.	
	tcpdump -i (int) proto (#)      -   Будет фильтровать захват для любого трафика протокола, соответствующего (#). Например, (6) будет фильтровать весь TCP-трафик и отбрасывать остальной.	
	tcpdump -i (int) (proto name)   -   Будет использовать общее имя протокола для фильтрации перехваченного трафика. TCP/UDP/ICMP в качестве примеров.	
			
+++++++++++++++++++++++++++++++			
+ Common Switches and Filters +
+++++++++++++++++++++++++++++++

	D               -   Отобразит все интерфейсы, доступные для захвата.	
	i               -   Выбирает интерфейс для захвата. бывший. -я эт0	
	n               -   Не разрешайте имена хостов.	
	nn              -   Не разрешайте имена хостов или общеизвестные порты.	
	e               -	Захватит заголовок Ethernet вместе с данными верхнего уровня.	
	X               -	Показывать содержимое пакетов в шестнадцатеричном формате и ASCII.	
	XX              -	То же, что и X, но также указывает заголовки Ethernet. (например, использование Xe)	
	v, vv, vvv      -  	Увеличьте детализацию отображаемых и сохраняемых результатов.	
	c               -	Возьмите определенное количество пакетов, затем выйдите из программы.	
	s               -	Определяет, какую часть пакета нужно захватить.	
	S               -	измените относительные порядковые номера на экране захвата на абсолютные порядковые номера. (13248765839 вместо 101)	
	q               -	Печатайте меньше информации о протоколе.	
	r file.pcap     -	Чтение из файла.	
	w file.pcap     -	Записать в файл	
	host            -	Хост будет фильтровать видимый трафик, чтобы показать все, что связано с назначенным хостом. Двунаправленный	
	src / dest      -	src и dest являются модификаторами. Мы можем использовать их для обозначения хоста или порта источника или назначения.	
	net             -	net покажет нам все источники трафика из указанной сети или предназначенные для нее. Он использует обозначение /.	
	proto           -	будет фильтровать определенный тип протокола. (эфир, TCP, UDP и ICMP в качестве примеров)	
	port            -	порт является двунаправленным. Он покажет любой трафик с указанным портом в качестве источника или назначения.	
	portrange       -	Portrange позволяет нам указать диапазон портов. (0-1024)	
	and / &&        -	и && можно использовать для объединения двух разных фильтров. например, хост src И порт.	
	or              -	или Или допускает совпадение по любому из двух условий. Он не обязательно должен соответствовать обоим. Это может быть сложно.	
	not             -	not — это модификатор, говорящий что угодно, кроме x. Например, не UDP.	
	less / greater "< >"    -	Меньше и больше можно использовать для поиска пакета или варианта протокола определенного размера		
			

=====================================================================
* TShark *
**********

++++++++++++++++++++
+ General Commands +
++++++++++++++++++++

	tshark -h                       -	Печатает меню справки.	
	tshark -D                       -	Список доступных интерфейсов для захвата.	
	tshark -i (int)                 -	Захват на выбранном интерфейсе. Замените (int) именем или номером интерфейса.	
	tshark -i eth0 -f "host (ip)"   -	примените фильтр с (-f) для поиска конкретного хоста, используя tshark	

+++++++++++++++++++++++++++++++			
+ Common Switches and Filters +
+++++++++++++++++++++++++++++++

    D               -	Отобразит все интерфейсы, доступные для захвата и последующего выхода.	
	L               -	Будет перечислены среды канального уровня, с которых вы можете выполнить захват, а затем выйти. (Ethernet в качестве примера)	
	i               -	выберите интерфейс для захвата. (-я eth0)	
	f               -	фильтр пакетов в синтаксисе libpcap. Используется во время захвата.	
	c               -	Возьмите определенное количество пакетов, затем выйдите из программы. Определяет условие остановки.	
	a               -	Определяет условие автоостанова. Это может быть после определенного времени, определенного размера файла или после определенного количества пакетов.	
	r (pcap-file)   -	Чтение из файла.	
	W (pcap-file)   -	Запишите в файл в формате pcapng.	
	P               -	Будет распечатывать сводку пакета при записи в файл (-W)	
	x               -	добавит вывод Hex и ASCII в захват.	
	h               -	См. меню помощи	
			
=====================================================================
* WIRESHARK *
*************

+++++++++++++++++++			
+ Common Switches +
+++++++++++++++++++
	
	and (&&)	-	И 
	or (||)		-	ИЛИ
	not !()		-	НЕТ
					Использование !=value устарело; его использование может привести к несогласованным результатам.
					Для получения более согласованных результатов рекомендуется использовать стиль !(value).

	eq (==)		-	РАВНО любому (любое, если больше чем одно совпадение)
	   (===)	-	РАВНО всем (все, если больше чем одно совпадение)

	ne !(=)		-	НЕ РАВНО  всем (все, если больше чем одно совпадение)
	   !(==)	-	НЕ РАВНО любому (любое, если больше чем одно совпадение)

	gt (>)		-	БОЛЬШЕ ЧЕМ
	ge (>=)		-	БОЛЬШЕ, ЛИБО РАВНО

	lt (<)		-	МЕНЬШЕ ЧЕМ
	le (<=)		-	МЕНЬШЕ, ЛИБО РАВНО

	contains	-	Протокол, поле или срез содержит значение
	matches		-	Протокол или текстовое поле соответствует регулярному выражению, совместимому с Perl
	[...]		-	Последовательность/диапозон, указанные в скобках

++++++++++++++++++++++++++++++
+ General Filtering Commands +
++++++++++++++++++++++++++++++

	ip / ether / tcp                    -	Эти фильтры будут захватывать трафик только из указанных заголовков протокола.	
	broadcast / multicast / unicast     -	Захватывает определенный тип трафика. один к одному, один ко многим или один ко всем.

	host x.x.x.x                        -	Захватывать только трафик, относящийся к определенному хосту	
	net x.x.x.x/24                      -	Перехват трафика в определенную сеть или из нее (используя косую черту для указания маски)	
	src/dst net x.x.x.x/24              -	Использование src или dst net будет захватывать только трафик, исходящий из указанной сети или направляющийся в целевую сеть.	
	port #                              -	отфильтрует весь трафик, кроме указанного вами порта	
	portrange x-x                       -	Portrange будет захватывать трафик только со всех портов в пределах диапазона.
	src.port / dst.port == x        	-	захватит все, кроме указанного порта.
	
	ip.addr == x.x.x.x              -	Захватывайте только трафик, относящийся к определенному хосту. Это оператор ИЛИ.	
	ip.addr == x.x.x.x/24           -	Захват трафика, относящегося к конкретной сети. Это оператор ИЛИ.	
	ip.src/dst == x.x.x.x           -	Захват трафика к определенному хосту или от него.	
	eth.addr == ##:##:##:##:##:##	-	Отобразит обладателя указанного MAC аддреса (как получателя, так и отправителя)
	eth.src == ##:##:##:##:##:##	-	Отобразит источник Ethernet-кадра с указанным MAC-адрес в качестве отправителя.
	
	frame.len == ###				-	Отобразит по длине пакета.
										Для диапозона используют frame.len in {##...##}
	frame contains "xxx"			-	Отобразит только те пакеты, в полезной нагрузке (т.е. поле данных) содержится указанное слово (в нашем случае "xxx")

	
	http                            -	Будет фильтровать любой трафик, соответствующий протоколу http.	
	http && image-jfif              -	Этот фильтр отобразит любой пакет с файлом изображения в формате JPEG.	
	
+++++++++++++++++++++++++++
+ Potocol FLAGs Filtering +
+++++++++++++++++++++++++++

	///////////
	///	TCP	///
	///////////

	tcp								-	Отобразит все пакеты принадлежашию протоколу TCP

	tcp.port == ####				-	фильтровать по определенному TCP-порту.	
	tcp.port in {#### #### ####}	-	отобразит общее количество пакетов по указанным портам вместе
	tcp.stream eq #                 -	Позволяет нам следить за сеансом TCP, в котором мы захватили весь поток.	

	tcp.flags == 2									-	Only SYN flag.
	tcp.flags.syn == 1								-	SYN flag is set. The rest of the bits are not important.
	tcp.flags == 16									-	Only ACK flag.
	tcp.flags.ack == 1								-	ACK flag is set. The rest of the bits are not important.
	tcp.flags == 18									-	Only SYN, ACK flags.
	tcp.flags.syn == 1 && tcp.flags.ack == 1		-	SYN and ACK are set. The rest of the bits are not important
	tcp.flags == 4									-	Only RST flag
	tcp.flags.reset == 1							-	RST flag is set. The rest of the bits are not important.
	tcp.flags == 20									-	Only RST, ACK flags.
	tcp.flags.reset == 1 && tcp.flags.ack == 1		-	RST and ACK are set. The rest of the bits are not important.
	tcp.flags == 1									-	Only FIN flag
	tcp.flags.fin == 1								-	FIN flag is set. The rest of the bits are not important.

	///////////
	///	UDP	///
	///////////

	icmp.type == 3		-	Тип 3 в ICMP означает "Destination Unreachable" ("Назначение недоступно").
							Этот тип сообщений ICMP отправляется, когда хост не может достичь назначения по каким-то причинам
							Например, если маршрутизатор не может передать пакет дальше.
	icmp.code == 3		-	Код 3 в ICMP для типа 3 (Destination Unreachable) означает "Port Unreachable" ("Порт недоступен").
							Этот код указывает на то, что пакет был доставлен к целевому хосту, но указанный порт не отвечает (обычно это происходит, когда порт на целевом хосте закрыт или служба на этом порту не запущена).

	///////////
	///	ARP	///
	///////////

	arp.opcode == 1								-	Opcode 1 означает ARP-запрос (ARP Request).
													Это сообщение, которое отправляется устройством для того, чтобы найти MAC-адрес другого устройства в сети по его IP-адресу.
	arp.opcode == 2								-	Opcode 2 обозначает ARP-ответ (ARP Reply)
													Это сообщение, которое отправляется в ответ на запрос с запрашиваемым MAC-адресом.
	arp.dst.hw_mac == ##:##:##:##:##:##			-	Данный фильтр будет захватывать только те ARP-пакеты, в которых поле MAC-адреса назначения равно 00:00:00:00:00:00
	arp.duplicate-address-detected				-	Это сообщение указывает на то, что был обнаружен дубликат IP-адреса.
													Когда одно устройство в сети отправляет ARP-запрос для разрешения MAC-адреса по IP-адресу, и другое устройство отвечает тем же IP-адресом, это может сигнализировать о конфликте.
	arp.duplicate-address-frame					-	Это сообщение указывает на то, что был получен кадр ARP с дублирующимся IP-адресом.
													Это более низкоуровневое сообщение, которое конкретно относится к сетевым фреймам, где обнаружен конфликт IP-адресов.

	////////////
	///	DHCP ///
	////////////

	dhcp or bootp										-	Отобразит все пакеты принадлежашию протоколу DHCP
		
	dhcp.option.dhcp == 3								-	Отобразит пакеты, относящиеся только к типу DHCP-запросов (DHCPREQUEST)
	dhcp.option.dhcp == 5								-	Отобразит пакеты, относящиеся только к типу DHCP-подтверждения (DHCPACK)
	dhcp.option.dhcp == 6								-	Отобразит пакеты, в которых присутствует уведомления клиента от сервера о том, что его запрос на получение IP-адреса или другой конфигурации был отклонен (DHCPNAK)

	dhcp.option.hostname contains "keyword"					-	Отобразит олько те DHCP-запросы, в которых клиентское устройство использует имя хоста, содержащее указанное слово (в нашем пример "keyword")
	dhcp.option.domain_name contains "keyword"				-	Отобразит все пакеты DHCP, где в опциях указывается доменное имя, содержащее "keyword"
	dhcp.option.requested_ip_address == ###.###.###.###		-	Отобразит пакет, который содержит информацию о хосте запрашиващий указанный IP-адрес

	///////////////
	///	NetBIOS ///
	///////////////

	nbns								-	Отобразит все пакеты принадлежашию протоколу NetBIOS

	nbns.flags.opcode == 5				-	Отобразит все пакеты, в которох присутствует запрос на регистрацию имени
	nbns.name contains "keyword"		-	Отобразит все пакеты, содержащие указанный "keyword" в поле имени NetBIOS

	////////////////
	///	Kerberos ///
	////////////////

	kerberos															-	Отобразит все пакеты принадлежашию протоколу Kerberos

	kerberos.CNameString contains "keyword"								-	Отобразит пакеты, строки которых содержат указанное ключевое слово (в нашем примере "keyword") внутри поля CNameString в Kerberos трафике
	kerberos.CNameString && !(kerberos.CNameString contains "$")		-	Отобразит строки имен клиентов, чтобы исключить сервисные аккаунты (которые обычно имеют символ "$" в имени), и возвращает только те строки, которые относятся к обычным пользователям.

	kerberos.pvno == 5						-	Отобразит только те пакеты, в которых используется версия 5 протокола Kerberos
	kerberos.realm contains ".org"			-	Отобразит все реалмы, чьи домены содержат ".org".
	kerberos.SNameString == "krbtg"			-	Выполняет проверку, соответствуют ли записи в журнале безопасности или запросе в Kerberos имени сервиса "krbtg"

	////////////
	///	ICMP ///
	////////////

	icmp						-	Отобразит все пакеты принадлежашию протоколу NetBIOS

	data.len > 64 && icmp		-	Отобразит только ICMP-пакеты длиной данных больше 64 байт.

	///////////
	///	DNS ///
	///////////

	dns									-	Отобразит все пакеты принадлежашию протоколу DNS
	!mdns								-	Исключает пакеты Multicast DNS (mDNS) из результата.
	
	dns contains "dnscat"				-	Отобразит только те DNS-запросы, которые содержат указанноую строку (в нашем примере - "dnscat")
	dns.qry.name.len > 15 && !mdns		-	Отобразит только те DNS-запросы, которые касаются более длинных доменных имен (больше 15 символов) и которые не используют протокол mDNS

	///////////
	///	FTP ///
	///////////

	ftp								-	Отобразит все пакеты принадлежашию протоколу DNS

	ftp-data                        -	Покажет все объекты, переданные по FTP.

	ftp.response.code == ###		-	Отобразит все пакеты, которые содержат определенный FTP код ответа
	
	ftp.request.command == "UESR"	-	Отобразит все пакеты, в которых клиент пытается сделать то, на что указывает название комнады (в нашем примере - авторизоваться, передавая своё FTP-имя пользователя).

	ftp.response.arg contains "username"	-	Отобразит все пакеты, где поле аргументов запроса FTP содержит строку "username".

	////////////
	///	HTTP ///
	////////////

	http                            -	Будет фильтровать любой трафик, соответствующий протоколу http.	
	http2							-	HTTP2 — это пересмотр протокола HTTP для лучшей производительности и безопасности.
										Он поддерживает двоичную передачу данных и мультиплексирование запросов и ответов.
	
	http && image-jfif              -	Этот фильтр отобразит любой пакет с файлом изображения в формате JPEG.	

	http.request					-	Отобразит все запросы HTTP пакетов
	http.request.method == "GET"	-	Отобразит все HTTP пакеты, где был использован метод запроса "GET"

	http.response.code == ###		-	Отобразит только те пакеты, в которых сервер ответил с кодом ###

	http.user_agent contains "nmap"				-	Отобразит HTTP пакеты поле user-agent которых содержит строку XXX (в нашем примере - nmap)
	http.request.uri contains "admin"			-	Отобразит HTTP пакеты название ресурса (URI) которых содержит строку XXX (в нашем примере - admin)
													Например -	https://example.com/admin
	http.request.full_uri contains "admin"		-	Отобразит все HTTP запросы, которые содержат строку "admin" в своём полном URI. 
													Например -	http://example.com/admin/dashboard?id=123.

	http.server contains "apache"			-	Отобразит HTTP пакеты, если в поле Server (запроса или ответа) будет обнаружено наличие строки "apache" 
	http.host contains "keyword"			-	Отобразит HTTP пакеты, если в поле Host будет обнаружено наличие строки "keyword".
												Поле Host содержит доменное имя, к которому осуществляется запрос.
	http.host == "keyword"					-	Отобразит HTTP пакеты, в которых будет точное совпадение значения поля Host с "keyword"
	http.connection == "Keep-Alive"			-	Отобразит HTTP пакеты, если в заголовоках Connection (запросов или ответов) будет на наличие строки "Keep-Alive". 
	data-text-lines contains "keyword"		-	Отобразит HTTP пакеты, у которых в тестовых строках данных будет строка содержащая "keyword"

	/////////////
	///	HTTPS ///
	/////////////

	http2			-	Отобразит HTTPS пакеты, но только при условии, что в WIreshark были загружены ключи дешефрации
	tls				-	Отобразит только пакеты, которые были задействованы в TLS соеденении
	ssdp			-	Отобразит пакеты, связанные с протоколом Simple Service Discovery Protocol (SSDP), который позволяяяет выявить сетевые устройства и службы, использующие этот протокол для обнаружения в локальной сети

	http2.header							-	Отобразит только HTTP2 заголовки
	http2.data								-	Отобразит только фреймы типа DATA
	http2.header.value == ":status: 200"	-	Отобразит пакета по указанному статусу

	tls.handshake.type == 1			-	Отобразит только те пакеты, в которых клиент отправляет сообщение ClientHello
	tls.handshake.type == 2			-	Отобразит только те пакеты, в которых сервер отправляет сообщение ServerHello

	http.request || tls.handshake.type == 1 && !(ssdp)		-	Отфильтрует сетевые пакеты для отображения только тех, которые:
																	-	являются HTTP-запросами,
																	-	содержат сообщение ClientHello для установки защищенного соединения через TLS,
																	-	и не связаны с протоколом SSDP.



++++++++++++++++++++++++++++++++++++
+ Case-Scanario Filtering Commands +
++++++++++++++++++++++++++++++++++++

	ip.ttl < ##													-	Отобразит количество пакетов с параметром TTL меньше указанного значения (##)
	tcp.port == ## && http.request.methond == "GET"				-	Отобразит количество пакетов с запросом «GET», отправленных на порт «##»
	dns.qry.type == 1 && dns.flags.response == 1				-	Отобразит количество «DNS-запросов типа A»
	http.server contains "IIS" && !(tcp.srcport == ##)			-	Отобразит количество пакетов, которые не исходили из «порта 80», и при этом использовался серве "Microsoft IIS"
	http.server contains "IIS" && http.server matches "#.#"		-	Отобразит количество пакетов, в которых версия "Microsoft IIS" указана как «#.#»
	string(ip.ttl) matches “[02468]$							-	Отобразит количество пакетов с «четными числами TTL»
	tcp.checksum.status == 0									-	Отобразит количество пакетов у которых «Контрольная сумма TCP» не совпадает (т.е. помечена как BAD)

	tcp.flags.syn==1 && tcp.flags.ack==0 && tcp.window_size > 1024		-	Фильтрует TCP-пакеты, которые инициируют соединение (SYN), не подтверждены (ACK=0), и имеют размер окна больше 1024 байт.
																			Это может быть полезно, при анализе попыток установления соединений в сети, особенно для выявления активных клиентских соединений.
																			Фильтр можно использовать для выявления исходящих попыток установления соединений (например, при сканировании портов)
																			Или для мониторинга аномальных TCP-пакетов, которые могут указывать на возможные атаки (например, SYN flood), если таких запросов много за короткий промежуток времени.
	
	tcp.flags.syn==1 && tcp.flags.ack==0 && tcp.window_size > 1024		-	Этот фильтр ищет первичные SYN-пакеты (с SYN=1, ACK=0), которые инициируют новое TCP-соединение, но у которых при этом размер TCP окна меньше 1024 байт.
																			Такие пакеты могут свидетельствовать о попытке установить соединение с ограниченным буфером или о нестандартной настройке клиента/сервера.
	
	icmp.type==3 && icmp.code==3		-	Эта комбинация фильтрует ICMP-пакеты, которые указывают, что назначение достигнуто, но указанный порт недоступен.
											Это типичный случай при работе с протоколами UDP, поскольку в отличие от TCP, в UDP нет механизма обратной связи, который говорит, что порт недоступен.
											Вместо этого, если порт недоступен, хост отправляет ICMP сообщение с типом 3 и кодом 3 в ответ на UDP-пакет.
	
	arp.duplicate-address-detected && arp.duplicate-address-frame		-	Эта команда используются для обнаружения конфликтов IP-адресов
																			Когда два устройства на одном сегменте сети пытаются использовать один и тот же IP-адрес.
	
	arp && arp.opcode == 1 && arp.dst == ##:##:##:##:##:##		-	Эта команда предназначена для захвата ARP-запросов с определённого MAC-адреса источника
																	Но, сперва надо определить подозрительный MAC-address
																	***	Однако существует коротка версия данной команды	-	eth.src == ##:##:##:##:##:## and arp.opcode == 1
	
	ftp.response.code == 530	-	Отобразит пакеты с неудачными попытками входа в систему
	
	ftp.response.code == 530 && ftp.response.arg contains "username"	-	Отобразит только те пакеты, где:
																				-	Сервер возвращает код ошибки 530, что указывает на неудачную попытку аутентификации
																				-	В аргументах ответа сервера содержится слово "username", что может указывать на проблему с именем пользователя при попытке входа.

	ftp.response.command == "PASS" && ftp.request.arg == "password"		-	Отобразит FTP-пакеты, связанные с вводом пароля при аутентификации на FTP-сервере.

	ftp.request.command == "RETR"		-	Отобразит пакеты, указывающие, что была осуществленна загрузка файла на сервер
	OR										Чтобы выяснить название файла и какие действия предпринимал злоумышленник надо Follow -> TCP Stream (через правую кномку мыши)			
	ftp.request.command == "STOR"
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
